<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AWS s2n-tls: api/s2n.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="s2n-logo-github.svg"/></td>
  <td id="projectalign">
   <div id="projectname">AWS s2n-tls<span id="projectnumber">&#160;v1.5.25-23cc0580</span>
   </div>
   <div id="projectbrief">s2n-tls is a C99 implementation of the TLS/SSL protocols that is designed to be simple, small, fast, and with security as a priority.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_0188a3e6da905bc60aceb35bf790b8c9.html">api</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">s2n.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;sys/types.h&gt;</code><br />
<code>#include &lt;sys/uio.h&gt;</code><br />
</div>
<p><a href="s2n_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:af1c2b8586154a9094d6978137ef001ac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a></td></tr>
<tr class="separator:af1c2b8586154a9094d6978137ef001ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6129dcaa68297738026d5c973c9aaf6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ab6129dcaa68297738026d5c973c9aaf6">S2N_SUCCESS</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ab6129dcaa68297738026d5c973c9aaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d003c0083278467af77c8cd19fce680"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a1d003c0083278467af77c8cd19fce680">S2N_FAILURE</a>&#160;&#160;&#160;-1</td></tr>
<tr class="separator:a1d003c0083278467af77c8cd19fce680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b035f48c2a75cdb05df51b092b0ec4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a07b035f48c2a75cdb05df51b092b0ec4">S2N_CALLBACK_BLOCKED</a>&#160;&#160;&#160;-2</td></tr>
<tr class="separator:a07b035f48c2a75cdb05df51b092b0ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14b875af86227115821bdbf6e2f0c44"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ac14b875af86227115821bdbf6e2f0c44">S2N_MINIMUM_SUPPORTED_TLS_RECORD_MAJOR_VERSION</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ac14b875af86227115821bdbf6e2f0c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f65e736fafe94e19cddd0c7e0d8b60c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a5f65e736fafe94e19cddd0c7e0d8b60c">S2N_MAXIMUM_SUPPORTED_TLS_RECORD_MAJOR_VERSION</a>&#160;&#160;&#160;3</td></tr>
<tr class="separator:a5f65e736fafe94e19cddd0c7e0d8b60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495735277344c9c306668f6027e3f077"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a495735277344c9c306668f6027e3f077">S2N_SSLv2</a>&#160;&#160;&#160;20</td></tr>
<tr class="separator:a495735277344c9c306668f6027e3f077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457805749bd152786e9e344a5b22ab67"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a457805749bd152786e9e344a5b22ab67">S2N_SSLv3</a>&#160;&#160;&#160;30</td></tr>
<tr class="separator:a457805749bd152786e9e344a5b22ab67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16c04a1d8479546aa124c4e52a1703f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ab16c04a1d8479546aa124c4e52a1703f">S2N_TLS10</a>&#160;&#160;&#160;31</td></tr>
<tr class="separator:ab16c04a1d8479546aa124c4e52a1703f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4a51448d3a9ea14b506ac2573f9bae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a2e4a51448d3a9ea14b506ac2573f9bae">S2N_TLS11</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:a2e4a51448d3a9ea14b506ac2573f9bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17e84046986d49ffd31571b8d32d24e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ab17e84046986d49ffd31571b8d32d24e">S2N_TLS12</a>&#160;&#160;&#160;33</td></tr>
<tr class="separator:ab17e84046986d49ffd31571b8d32d24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0529ae368bcd797cb65244b4ce05a6a6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a0529ae368bcd797cb65244b4ce05a6a6">S2N_TLS13</a>&#160;&#160;&#160;34</td></tr>
<tr class="separator:a0529ae368bcd797cb65244b4ce05a6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda361f68c34e244d0b0c97297fa096f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#afda361f68c34e244d0b0c97297fa096f">S2N_UNKNOWN_PROTOCOL_VERSION</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:afda361f68c34e244d0b0c97297fa096f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0cfed8d65c0e2c33cf666ee90eb06a7e"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a0cfed8d65c0e2c33cf666ee90eb06a7e">s2n_clock_time_nanoseconds</a>) (void *, uint64_t *)</td></tr>
<tr class="separator:a0cfed8d65c0e2c33cf666ee90eb06a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b0785656f577b764e1c3c3844368d4"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a57b0785656f577b764e1c3c3844368d4">s2n_cache_retrieve_callback</a>) (struct s2n_connection *conn, void *, const void *key, uint64_t key_size, void *value, uint64_t *value_size)</td></tr>
<tr class="separator:a57b0785656f577b764e1c3c3844368d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9764b7cab647999aad58c339a42e90e"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ad9764b7cab647999aad58c339a42e90e">s2n_cache_store_callback</a>) (struct s2n_connection *conn, void *, uint64_t ttl_in_seconds, const void *key, uint64_t key_size, const void *value, uint64_t value_size)</td></tr>
<tr class="separator:ad9764b7cab647999aad58c339a42e90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf7cc68d71dd8d960ff078b3a21792f"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#acbf7cc68d71dd8d960ff078b3a21792f">s2n_cache_delete_callback</a>) (struct s2n_connection *conn, void *, const void *key, uint64_t key_size)</td></tr>
<tr class="separator:acbf7cc68d71dd8d960ff078b3a21792f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71033bff0e129f910b87d5fb41798519"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a71033bff0e129f910b87d5fb41798519">s2n_mem_init_callback</a>) (void)</td></tr>
<tr class="separator:a71033bff0e129f910b87d5fb41798519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f75394a380a2764b189ca6662133ba"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ae5f75394a380a2764b189ca6662133ba">s2n_mem_cleanup_callback</a>) (void)</td></tr>
<tr class="separator:ae5f75394a380a2764b189ca6662133ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea7d341ee2969dd1d083fafe13a5d43"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a8ea7d341ee2969dd1d083fafe13a5d43">s2n_mem_malloc_callback</a>) (void **ptr, uint32_t requested, uint32_t *allocated)</td></tr>
<tr class="separator:a8ea7d341ee2969dd1d083fafe13a5d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4014627f6981bc4e533781d29903d5"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a6e4014627f6981bc4e533781d29903d5">s2n_mem_free_callback</a>) (void *ptr, uint32_t size)</td></tr>
<tr class="separator:a6e4014627f6981bc4e533781d29903d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada646d7bfa47772c96b4e4c9dca18dd1"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ada646d7bfa47772c96b4e4c9dca18dd1">s2n_rand_init_callback</a>) (void)</td></tr>
<tr class="separator:ada646d7bfa47772c96b4e4c9dca18dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700f181dd144cbb4161765333a190d01"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a700f181dd144cbb4161765333a190d01">s2n_rand_cleanup_callback</a>) (void)</td></tr>
<tr class="separator:a700f181dd144cbb4161765333a190d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7cf68edcc9173e3ac5383d1fb879d31"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ae7cf68edcc9173e3ac5383d1fb879d31">s2n_rand_seed_callback</a>) (void *data, uint32_t size)</td></tr>
<tr class="separator:ae7cf68edcc9173e3ac5383d1fb879d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6891b58a1c9a957d299177497e7896"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a4b6891b58a1c9a957d299177497e7896">s2n_rand_mix_callback</a>) (void *data, uint32_t size)</td></tr>
<tr class="separator:a4b6891b58a1c9a957d299177497e7896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c668f3559688152919b062f260f7c3"><td class="memItemLeft" align="right" valign="top">typedef struct s2n_pkey&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a69c668f3559688152919b062f260f7c3">s2n_cert_public_key</a></td></tr>
<tr class="separator:a69c668f3559688152919b062f260f7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abfa5333181eedc5c2e59bccbe60700"><td class="memItemLeft" align="right" valign="top">typedef struct s2n_pkey&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a9abfa5333181eedc5c2e59bccbe60700">s2n_cert_private_key</a></td></tr>
<tr class="separator:a9abfa5333181eedc5c2e59bccbe60700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0363fdf570a5451facfa12eb0a679586"><td class="memItemLeft" align="right" valign="top">typedef struct s2n_cert_chain_and_key *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a0363fdf570a5451facfa12eb0a679586">s2n_cert_tiebreak_callback</a>) (struct s2n_cert_chain_and_key *cert1, struct s2n_cert_chain_and_key *cert2, uint8_t *name, uint32_t name_len)</td></tr>
<tr class="separator:a0363fdf570a5451facfa12eb0a679586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa56850695a02753f726ea9860ec383"><td class="memItemLeft" align="right" valign="top">typedef uint8_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a8aa56850695a02753f726ea9860ec383">s2n_verify_host_fn</a>) (const char *host_name, size_t host_name_len, void *data)</td></tr>
<tr class="separator:a8aa56850695a02753f726ea9860ec383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0451dcbf88fdf09f36a82cab4d25d44e"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a0451dcbf88fdf09f36a82cab4d25d44e">s2n_client_hello_fn</a>(struct s2n_connection *conn, void *ctx)</td></tr>
<tr class="separator:a0451dcbf88fdf09f36a82cab4d25d44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5d6b77e35bf16aee077fe1c5860cc9"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a0b5d6b77e35bf16aee077fe1c5860cc9">s2n_recv_fn</a>(void *io_context, uint8_t *buf, uint32_t len)</td></tr>
<tr class="separator:a0b5d6b77e35bf16aee077fe1c5860cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ae4eeefcfc81bc4daf429512612687"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ad8ae4eeefcfc81bc4daf429512612687">s2n_send_fn</a>(void *io_context, const uint8_t *buf, uint32_t len)</td></tr>
<tr class="separator:ad8ae4eeefcfc81bc4daf429512612687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a1b430e8782d95dc60efbec7cd6118"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a87a1b430e8782d95dc60efbec7cd6118">s2n_session_ticket_fn</a>) (struct s2n_connection *conn, void *ctx, struct s2n_session_ticket *ticket)</td></tr>
<tr class="separator:a87a1b430e8782d95dc60efbec7cd6118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37dd435b749a207739d64b22837a9ba1"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a37dd435b749a207739d64b22837a9ba1">s2n_psk_selection_callback</a>) (struct s2n_connection *conn, void *context, struct s2n_offered_psk_list *psk_list)</td></tr>
<tr class="separator:a37dd435b749a207739d64b22837a9ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ecb6a187e25469c3fd108a873da1cce"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a2ecb6a187e25469c3fd108a873da1cce">s2n_async_pkey_fn</a>) (struct s2n_connection *conn, struct s2n_async_pkey_op *op)</td></tr>
<tr class="separator:a2ecb6a187e25469c3fd108a873da1cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad3e5f171648fb7fb55109d623cb13e"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a4ad3e5f171648fb7fb55109d623cb13e">s2n_key_log_fn</a>) (void *ctx, struct s2n_connection *conn, uint8_t *logline, size_t len)</td></tr>
<tr class="separator:a4ad3e5f171648fb7fb55109d623cb13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adebd93e979b53293c106cc2a44f79607"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#adebd93e979b53293c106cc2a44f79607">s2n_early_data_cb</a>) (struct s2n_connection *conn, struct s2n_offered_early_data *early_data)</td></tr>
<tr class="separator:adebd93e979b53293c106cc2a44f79607"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a41f8ab66d28ce2f33fa8dbf858c0ac44"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a41f8ab66d28ce2f33fa8dbf858c0ac44">s2n_error_type</a> { <br />
&#160;&#160;<a class="el" href="s2n_8h.html#a41f8ab66d28ce2f33fa8dbf858c0ac44a09221eeb73c34d50145b9c7c0eb21f25">S2N_ERR_T_OK</a> = 0
, <a class="el" href="s2n_8h.html#a41f8ab66d28ce2f33fa8dbf858c0ac44a37308c203b80ac55ca9fe47af71a4461">S2N_ERR_T_IO</a>
, <a class="el" href="s2n_8h.html#a41f8ab66d28ce2f33fa8dbf858c0ac44a0cbe0424403a2678cf7ece737b2203e1">S2N_ERR_T_CLOSED</a>
, <a class="el" href="s2n_8h.html#a41f8ab66d28ce2f33fa8dbf858c0ac44a5bcbdbf63fe745654c4ae0fb8d28bbd2">S2N_ERR_T_BLOCKED</a>
, <br />
&#160;&#160;<a class="el" href="s2n_8h.html#a41f8ab66d28ce2f33fa8dbf858c0ac44a12d57bda93bac5e14ae6d7c78717e122">S2N_ERR_T_ALERT</a>
, <a class="el" href="s2n_8h.html#a41f8ab66d28ce2f33fa8dbf858c0ac44af7032a0138492c552fc04b9198259cd7">S2N_ERR_T_PROTO</a>
, <a class="el" href="s2n_8h.html#a41f8ab66d28ce2f33fa8dbf858c0ac44a2c6b4ff243a28b86ef701206023339ca">S2N_ERR_T_INTERNAL</a>
, <a class="el" href="s2n_8h.html#a41f8ab66d28ce2f33fa8dbf858c0ac44a0d2eba6e7ff752e54c0aa004fd53f176">S2N_ERR_T_USAGE</a>
<br />
 }</td></tr>
<tr class="separator:a41f8ab66d28ce2f33fa8dbf858c0ac44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca8aa07679a8a51477bf73a2159b8b2"><td class="memItemLeft" align="right" valign="top"><a id="afca8aa07679a8a51477bf73a2159b8b2" name="afca8aa07679a8a51477bf73a2159b8b2"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>s2n_fips_mode</b> { <b>S2N_FIPS_MODE_DISABLED</b> = 0
, <b>S2N_FIPS_MODE_ENABLED</b>
 }</td></tr>
<tr class="separator:afca8aa07679a8a51477bf73a2159b8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b46f61765da5529f931afb8dd8a1f8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ab2b46f61765da5529f931afb8dd8a1f8">s2n_tls_extension_type</a> { <br />
&#160;&#160;<b>S2N_EXTENSION_SERVER_NAME</b> = 0
, <b>S2N_EXTENSION_MAX_FRAG_LEN</b> = 1
, <b>S2N_EXTENSION_OCSP_STAPLING</b> = 5
, <b>S2N_EXTENSION_SUPPORTED_GROUPS</b> = 10
, <br />
&#160;&#160;<b>S2N_EXTENSION_EC_POINT_FORMATS</b> = 11
, <b>S2N_EXTENSION_SIGNATURE_ALGORITHMS</b> = 13
, <b>S2N_EXTENSION_ALPN</b> = 16
, <b>S2N_EXTENSION_CERTIFICATE_TRANSPARENCY</b> = 18
, <br />
&#160;&#160;<b>S2N_EXTENSION_SUPPORTED_VERSIONS</b> = 43
, <b>S2N_EXTENSION_RENEGOTIATION_INFO</b> = 65281
<br />
 }</td></tr>
<tr class="separator:ab2b46f61765da5529f931afb8dd8a1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1976b2365808c341247e03131c2423ac"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a1976b2365808c341247e03131c2423ac">s2n_max_frag_len</a> { <b>S2N_TLS_MAX_FRAG_LEN_512</b> = 1
, <b>S2N_TLS_MAX_FRAG_LEN_1024</b> = 2
, <b>S2N_TLS_MAX_FRAG_LEN_2048</b> = 3
, <b>S2N_TLS_MAX_FRAG_LEN_4096</b> = 4
 }</td></tr>
<tr class="separator:a1976b2365808c341247e03131c2423ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798ae75eec4c2c7c27289195cd7c15ef"><td class="memItemLeft" align="right" valign="top"><a id="a798ae75eec4c2c7c27289195cd7c15ef" name="a798ae75eec4c2c7c27289195cd7c15ef"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>s2n_verify_after_sign</b> { <b>S2N_VERIFY_AFTER_SIGN_DISABLED</b>
, <b>S2N_VERIFY_AFTER_SIGN_ENABLED</b>
 }</td></tr>
<tr class="separator:a798ae75eec4c2c7c27289195cd7c15ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d38e45340d223d0100a2d4bc0526635"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a7d38e45340d223d0100a2d4bc0526635">s2n_status_request_type</a> { <b>S2N_STATUS_REQUEST_NONE</b> = 0
, <b>S2N_STATUS_REQUEST_OCSP</b> = 1
 }</td></tr>
<tr class="separator:a7d38e45340d223d0100a2d4bc0526635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f37b612310a3594b019b88ebd8fa1a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ae8f37b612310a3594b019b88ebd8fa1a">s2n_ct_support_level</a> { <b>S2N_CT_SUPPORT_NONE</b> = 0
, <b>S2N_CT_SUPPORT_REQUEST</b> = 1
 }</td></tr>
<tr class="separator:ae8f37b612310a3594b019b88ebd8fa1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d3f62254ec4211d47cc841dea76abd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ab8d3f62254ec4211d47cc841dea76abd">s2n_alert_behavior</a> { <b>S2N_ALERT_FAIL_ON_WARNINGS</b> = 0
, <b>S2N_ALERT_IGNORE_WARNINGS</b> = 1
 }</td></tr>
<tr class="separator:ab8d3f62254ec4211d47cc841dea76abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a64e3b657f90d221c5faf99c643cdb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a77a64e3b657f90d221c5faf99c643cdb">s2n_mode</a> { <b>S2N_SERVER</b>
, <b>S2N_CLIENT</b>
 }</td></tr>
<tr class="separator:a77a64e3b657f90d221c5faf99c643cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa9070e5b2de634b4a6fcb2bde98e68"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a7aa9070e5b2de634b4a6fcb2bde98e68">s2n_client_hello_cb_mode</a> { <b>S2N_CLIENT_HELLO_CB_BLOCKING</b>
, <b>S2N_CLIENT_HELLO_CB_NONBLOCKING</b>
 }</td></tr>
<tr class="separator:a7aa9070e5b2de634b4a6fcb2bde98e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364ad496c9dd42fd3117a2f9d3289e62"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a364ad496c9dd42fd3117a2f9d3289e62">s2n_blinding</a> { <b>S2N_BUILT_IN_BLINDING</b>
, <b>S2N_SELF_SERVICE_BLINDING</b>
 }</td></tr>
<tr class="separator:a364ad496c9dd42fd3117a2f9d3289e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ab6cd4a526f781116a39bd16bab9ba"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#aa8ab6cd4a526f781116a39bd16bab9ba">s2n_peer_key_update</a> { <b>S2N_KEY_UPDATE_NOT_REQUESTED</b> = 0
, <b>S2N_KEY_UPDATE_REQUESTED</b>
 }</td></tr>
<tr class="separator:aa8ab6cd4a526f781116a39bd16bab9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70ca0b089daa98cd79a424d3f6af15d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#af70ca0b089daa98cd79a424d3f6af15d">s2n_blocked_status</a> { <br />
&#160;&#160;<b>S2N_NOT_BLOCKED</b> = 0
, <b>S2N_BLOCKED_ON_READ</b>
, <b>S2N_BLOCKED_ON_WRITE</b>
, <b>S2N_BLOCKED_ON_APPLICATION_INPUT</b>
, <br />
&#160;&#160;<b>S2N_BLOCKED_ON_EARLY_DATA</b>
<br />
 }</td></tr>
<tr class="separator:af70ca0b089daa98cd79a424d3f6af15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8757c094681bb8151329c8dc067106b8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a8757c094681bb8151329c8dc067106b8">s2n_cert_auth_type</a> { <b>S2N_CERT_AUTH_NONE</b>
, <b>S2N_CERT_AUTH_REQUIRED</b>
, <b>S2N_CERT_AUTH_OPTIONAL</b>
 }</td></tr>
<tr class="separator:a8757c094681bb8151329c8dc067106b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9812997751f63ac2d5ab70852792a689"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a9812997751f63ac2d5ab70852792a689">s2n_tls_signature_algorithm</a> { <br />
&#160;&#160;<b>S2N_TLS_SIGNATURE_ANONYMOUS</b> = 0
, <b>S2N_TLS_SIGNATURE_RSA</b> = 1
, <b>S2N_TLS_SIGNATURE_ECDSA</b> = 3
, <b>S2N_TLS_SIGNATURE_MLDSA</b> = 9
, <br />
&#160;&#160;<b>S2N_TLS_SIGNATURE_RSA_PSS_RSAE</b> = 224
, <b>S2N_TLS_SIGNATURE_RSA_PSS_PSS</b>
<br />
 }</td></tr>
<tr class="separator:a9812997751f63ac2d5ab70852792a689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08eccb21b18130aef8c19a288801f379"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a08eccb21b18130aef8c19a288801f379">s2n_tls_hash_algorithm</a> { <br />
&#160;&#160;<b>S2N_TLS_HASH_NONE</b> = 0
, <b>S2N_TLS_HASH_MD5</b> = 1
, <b>S2N_TLS_HASH_SHA1</b> = 2
, <b>S2N_TLS_HASH_SHA224</b> = 3
, <br />
&#160;&#160;<b>S2N_TLS_HASH_SHA256</b> = 4
, <b>S2N_TLS_HASH_SHA384</b> = 5
, <b>S2N_TLS_HASH_SHA512</b> = 6
, <b>S2N_TLS_HASH_MD5_SHA1</b> = 224
<br />
 }</td></tr>
<tr class="separator:a08eccb21b18130aef8c19a288801f379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b2409fe4420987dcb5d1ed905e81fc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a85b2409fe4420987dcb5d1ed905e81fc">s2n_psk_hmac</a> { <b>S2N_PSK_HMAC_SHA256</b>
, <b>S2N_PSK_HMAC_SHA384</b>
 }</td></tr>
<tr class="separator:a85b2409fe4420987dcb5d1ed905e81fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5d0a0d8a1092a60dd0f50cdf969524"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a3c5d0a0d8a1092a60dd0f50cdf969524">s2n_psk_mode</a> { <b>S2N_PSK_MODE_RESUMPTION</b>
, <b>S2N_PSK_MODE_EXTERNAL</b>
 }</td></tr>
<tr class="separator:a3c5d0a0d8a1092a60dd0f50cdf969524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388f87d7049392968cf4fba3bdefa197"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a388f87d7049392968cf4fba3bdefa197">s2n_cert_sni_match</a> { <b>S2N_SNI_NONE</b> = 1
, <b>S2N_SNI_EXACT_MATCH</b>
, <b>S2N_SNI_WILDCARD_MATCH</b>
, <b>S2N_SNI_NO_MATCH</b>
 }</td></tr>
<tr class="separator:a388f87d7049392968cf4fba3bdefa197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0e141e39d6fd9782af697513933995"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a3b0e141e39d6fd9782af697513933995">s2n_async_pkey_validation_mode</a> { <b>S2N_ASYNC_PKEY_VALIDATION_FAST</b>
, <b>S2N_ASYNC_PKEY_VALIDATION_STRICT</b>
 }</td></tr>
<tr class="separator:a3b0e141e39d6fd9782af697513933995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedafc6dd8cb741ba7001beb50f3aa972"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#aedafc6dd8cb741ba7001beb50f3aa972">s2n_async_pkey_op_type</a> { <b>S2N_ASYNC_DECRYPT</b>
, <b>S2N_ASYNC_SIGN</b>
 }</td></tr>
<tr class="separator:aedafc6dd8cb741ba7001beb50f3aa972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11b47e128bd2074bf486e1e47864033"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ab11b47e128bd2074bf486e1e47864033">s2n_early_data_status_t</a> { <b>S2N_EARLY_DATA_STATUS_OK</b>
, <b>S2N_EARLY_DATA_STATUS_NOT_REQUESTED</b>
, <b>S2N_EARLY_DATA_STATUS_REJECTED</b>
, <b>S2N_EARLY_DATA_STATUS_END</b>
 }</td></tr>
<tr class="separator:ab11b47e128bd2074bf486e1e47864033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d830314bad02fd3dea9e9e7b7c8db8c"><td class="memItemLeft" align="right" valign="top"><a id="a8d830314bad02fd3dea9e9e7b7c8db8c" name="a8d830314bad02fd3dea9e9e7b7c8db8c"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>s2n_serialization_version</b> { <b>S2N_SERIALIZED_CONN_NONE</b> = 0
, <b>S2N_SERIALIZED_CONN_V1</b> = 1
 }</td></tr>
<tr class="separator:a8d830314bad02fd3dea9e9e7b7c8db8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afc791e3052429bdeb4428ef3acab7f27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#afc791e3052429bdeb4428ef3acab7f27">s2n_errno_location</a> (void)</td></tr>
<tr class="separator:afc791e3052429bdeb4428ef3acab7f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebff13e0704f879abbb6a3a7cbbe62c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#aebff13e0704f879abbb6a3a7cbbe62c2">s2n_error_get_type</a> (int error)</td></tr>
<tr class="separator:aebff13e0704f879abbb6a3a7cbbe62c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b12103d1358a4c15f3630401d1e932"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ac4b12103d1358a4c15f3630401d1e932">s2n_crypto_disable_init</a> (void)</td></tr>
<tr class="separator:ac4b12103d1358a4c15f3630401d1e932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0e6f150b48022f73ab5282e50de6a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#aeb0e6f150b48022f73ab5282e50de6a6">s2n_disable_atexit</a> (void)</td></tr>
<tr class="separator:aeb0e6f150b48022f73ab5282e50de6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af149f0a7173ca87281b568fa87e46db7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#af149f0a7173ca87281b568fa87e46db7">s2n_get_openssl_version</a> (void)</td></tr>
<tr class="separator:af149f0a7173ca87281b568fa87e46db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b65ad20272f232f12c8ae36578d372"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a41b65ad20272f232f12c8ae36578d372">s2n_init</a> (void)</td></tr>
<tr class="separator:a41b65ad20272f232f12c8ae36578d372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bec40a852f3766f4e419684036e7550"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a6bec40a852f3766f4e419684036e7550">s2n_cleanup</a> (void)</td></tr>
<tr class="separator:a6bec40a852f3766f4e419684036e7550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f36379e13f9e3f1646ccb1f02cc4b4f"><td class="memItemLeft" align="right" valign="top"><a id="a7f36379e13f9e3f1646ccb1f02cc4b4f" name="a7f36379e13f9e3f1646ccb1f02cc4b4f"></a>
<a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><b>s2n_cleanup_final</b> (void)</td></tr>
<tr class="separator:a7f36379e13f9e3f1646ccb1f02cc4b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f5f01eb4a3c924ffb8674bd3256601"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ae2f5f01eb4a3c924ffb8674bd3256601">s2n_get_fips_mode</a> (s2n_fips_mode *fips_mode)</td></tr>
<tr class="separator:ae2f5f01eb4a3c924ffb8674bd3256601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4a525b68ba7bd181a27de9ea2fcd1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> struct s2n_config *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#aae4a525b68ba7bd181a27de9ea2fcd1a">s2n_config_new</a> (void)</td></tr>
<tr class="separator:aae4a525b68ba7bd181a27de9ea2fcd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ea3e214391965d7edb0efa6bf1e4cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> struct s2n_config *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ab4ea3e214391965d7edb0efa6bf1e4cd">s2n_config_new_minimal</a> (void)</td></tr>
<tr class="separator:ab4ea3e214391965d7edb0efa6bf1e4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414a19458d8ce45e039dbd01e7dd67f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a414a19458d8ce45e039dbd01e7dd67f4">s2n_config_free</a> (struct s2n_config *config)</td></tr>
<tr class="separator:a414a19458d8ce45e039dbd01e7dd67f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a04d9eaa39a0145f16dd819fe60fc0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a5a04d9eaa39a0145f16dd819fe60fc0b">s2n_config_free_dhparams</a> (struct s2n_config *config)</td></tr>
<tr class="separator:a5a04d9eaa39a0145f16dd819fe60fc0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867af1779dd5a21b944239eb932c0744"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a867af1779dd5a21b944239eb932c0744">s2n_config_free_cert_chain_and_key</a> (struct s2n_config *config)</td></tr>
<tr class="separator:a867af1779dd5a21b944239eb932c0744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c8ab4e5c773d3e0464ed41cc51bd5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a43c8ab4e5c773d3e0464ed41cc51bd5d">s2n_config_set_wall_clock</a> (struct s2n_config *config, <a class="el" href="s2n_8h.html#a0cfed8d65c0e2c33cf666ee90eb06a7e">s2n_clock_time_nanoseconds</a> clock_fn, void *ctx)</td></tr>
<tr class="separator:a43c8ab4e5c773d3e0464ed41cc51bd5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b11c2ca37417cf74606870711a08741"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a7b11c2ca37417cf74606870711a08741">s2n_config_set_monotonic_clock</a> (struct s2n_config *config, <a class="el" href="s2n_8h.html#a0cfed8d65c0e2c33cf666ee90eb06a7e">s2n_clock_time_nanoseconds</a> clock_fn, void *ctx)</td></tr>
<tr class="separator:a7b11c2ca37417cf74606870711a08741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e354c1c73d75888997a81353ea616b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a57e354c1c73d75888997a81353ea616b">s2n_strerror</a> (int error, const char *lang)</td></tr>
<tr class="separator:a57e354c1c73d75888997a81353ea616b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe953bd1887fbd7812beebc180639baa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#abe953bd1887fbd7812beebc180639baa">s2n_strerror_debug</a> (int error, const char *lang)</td></tr>
<tr class="separator:abe953bd1887fbd7812beebc180639baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114d3d3ce1bb2a59ee44434af04b068c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a114d3d3ce1bb2a59ee44434af04b068c">s2n_strerror_name</a> (int error)</td></tr>
<tr class="separator:a114d3d3ce1bb2a59ee44434af04b068c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f6086b173925bd39185c79538dfdf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a87f6086b173925bd39185c79538dfdf5">s2n_strerror_source</a> (int error)</td></tr>
<tr class="separator:a87f6086b173925bd39185c79538dfdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2220ac8657a5417ee02e8da3b7789b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ad2220ac8657a5417ee02e8da3b7789b1">s2n_stack_traces_enabled</a> (void)</td></tr>
<tr class="separator:ad2220ac8657a5417ee02e8da3b7789b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997548b3339d0ee7d154911c733f2126"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a997548b3339d0ee7d154911c733f2126">s2n_stack_traces_enabled_set</a> (bool newval)</td></tr>
<tr class="separator:a997548b3339d0ee7d154911c733f2126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc456819a4334258c0e9076cf59f4a37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#adc456819a4334258c0e9076cf59f4a37">s2n_calculate_stacktrace</a> (void)</td></tr>
<tr class="separator:adc456819a4334258c0e9076cf59f4a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3795be9933007194977318e19e7fb8ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a3795be9933007194977318e19e7fb8ea">s2n_print_stacktrace</a> (FILE *fptr)</td></tr>
<tr class="separator:a3795be9933007194977318e19e7fb8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7794e4ff39ad4a15b310136fcd4ac079"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a7794e4ff39ad4a15b310136fcd4ac079">s2n_free_stacktrace</a> (void)</td></tr>
<tr class="separator:a7794e4ff39ad4a15b310136fcd4ac079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb6aca0767b83c072629041a30f263b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a7bb6aca0767b83c072629041a30f263b">s2n_get_stacktrace</a> (struct s2n_stacktrace *trace)</td></tr>
<tr class="separator:a7bb6aca0767b83c072629041a30f263b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1c9c7110d9e3c18d48fbf8ee655318"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a8c1c9c7110d9e3c18d48fbf8ee655318">s2n_config_set_cache_store_callback</a> (struct s2n_config *config, <a class="el" href="s2n_8h.html#ad9764b7cab647999aad58c339a42e90e">s2n_cache_store_callback</a> cache_store_callback, void *data)</td></tr>
<tr class="separator:a8c1c9c7110d9e3c18d48fbf8ee655318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab40fa6123aedb83f5fab8ef1922fa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a0ab40fa6123aedb83f5fab8ef1922fa9">s2n_config_set_cache_retrieve_callback</a> (struct s2n_config *config, <a class="el" href="s2n_8h.html#a57b0785656f577b764e1c3c3844368d4">s2n_cache_retrieve_callback</a> cache_retrieve_callback, void *data)</td></tr>
<tr class="separator:a0ab40fa6123aedb83f5fab8ef1922fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83593aa49ca8a9cff7c2678acf943f4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a83593aa49ca8a9cff7c2678acf943f4f">s2n_config_set_cache_delete_callback</a> (struct s2n_config *config, <a class="el" href="s2n_8h.html#acbf7cc68d71dd8d960ff078b3a21792f">s2n_cache_delete_callback</a> cache_delete_callback, void *data)</td></tr>
<tr class="separator:a83593aa49ca8a9cff7c2678acf943f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664b222a36088c06c4580653971f03a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a664b222a36088c06c4580653971f03a5">s2n_mem_set_callbacks</a> (<a class="el" href="s2n_8h.html#a71033bff0e129f910b87d5fb41798519">s2n_mem_init_callback</a> mem_init_callback, <a class="el" href="s2n_8h.html#ae5f75394a380a2764b189ca6662133ba">s2n_mem_cleanup_callback</a> mem_cleanup_callback, <a class="el" href="s2n_8h.html#a8ea7d341ee2969dd1d083fafe13a5d43">s2n_mem_malloc_callback</a> mem_malloc_callback, <a class="el" href="s2n_8h.html#a6e4014627f6981bc4e533781d29903d5">s2n_mem_free_callback</a> mem_free_callback)</td></tr>
<tr class="separator:a664b222a36088c06c4580653971f03a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f23014a1e26a8849f9b35208c7fdcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#af3f23014a1e26a8849f9b35208c7fdcc">s2n_rand_set_callbacks</a> (<a class="el" href="s2n_8h.html#ada646d7bfa47772c96b4e4c9dca18dd1">s2n_rand_init_callback</a> rand_init_callback, <a class="el" href="s2n_8h.html#a700f181dd144cbb4161765333a190d01">s2n_rand_cleanup_callback</a> rand_cleanup_callback, <a class="el" href="s2n_8h.html#ae7cf68edcc9173e3ac5383d1fb879d31">s2n_rand_seed_callback</a> rand_seed_callback, <a class="el" href="s2n_8h.html#a4b6891b58a1c9a957d299177497e7896">s2n_rand_mix_callback</a> rand_mix_callback)</td></tr>
<tr class="separator:af3f23014a1e26a8849f9b35208c7fdcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba831685480db5b9be2ff1c4070008c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> struct s2n_cert_chain_and_key *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a3ba831685480db5b9be2ff1c4070008c">s2n_cert_chain_and_key_new</a> (void)</td></tr>
<tr class="separator:a3ba831685480db5b9be2ff1c4070008c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeca285084f87f4c21298ea21ed057a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#aeeca285084f87f4c21298ea21ed057a7">s2n_cert_chain_and_key_load_pem</a> (struct s2n_cert_chain_and_key *chain_and_key, const char *chain_pem, const char *private_key_pem)</td></tr>
<tr class="separator:aeeca285084f87f4c21298ea21ed057a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ab6e8c3724d54c79e6efdb8c9f65dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a53ab6e8c3724d54c79e6efdb8c9f65dd">s2n_cert_chain_and_key_load_pem_bytes</a> (struct s2n_cert_chain_and_key *chain_and_key, uint8_t *chain_pem, uint32_t chain_pem_len, uint8_t *private_key_pem, uint32_t private_key_pem_len)</td></tr>
<tr class="separator:a53ab6e8c3724d54c79e6efdb8c9f65dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e22738ac5230c0cf643b71eee702e76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a0e22738ac5230c0cf643b71eee702e76">s2n_cert_chain_and_key_load_public_pem_bytes</a> (struct s2n_cert_chain_and_key *chain_and_key, uint8_t *chain_pem, uint32_t chain_pem_len)</td></tr>
<tr class="separator:a0e22738ac5230c0cf643b71eee702e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfe337472559cc966e735604bc8090b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a7bfe337472559cc966e735604bc8090b">s2n_cert_chain_and_key_free</a> (struct s2n_cert_chain_and_key *cert_and_key)</td></tr>
<tr class="separator:a7bfe337472559cc966e735604bc8090b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1ca142d9e92dca8255e4d978d33e1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a4b1ca142d9e92dca8255e4d978d33e1d">s2n_cert_chain_and_key_set_ctx</a> (struct s2n_cert_chain_and_key *cert_and_key, void *ctx)</td></tr>
<tr class="separator:a4b1ca142d9e92dca8255e4d978d33e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566c861bda05b2a1a2ba28e10648b2d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a566c861bda05b2a1a2ba28e10648b2d8">s2n_cert_chain_and_key_get_ctx</a> (struct s2n_cert_chain_and_key *cert_and_key)</td></tr>
<tr class="separator:a566c861bda05b2a1a2ba28e10648b2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5196bcf5caf7093c7cef2a87029877be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> <a class="el" href="s2n_8h.html#a9abfa5333181eedc5c2e59bccbe60700">s2n_cert_private_key</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a5196bcf5caf7093c7cef2a87029877be">s2n_cert_chain_and_key_get_private_key</a> (struct s2n_cert_chain_and_key *cert_and_key)</td></tr>
<tr class="separator:a5196bcf5caf7093c7cef2a87029877be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b775d2673486ebb5520f36ed2d0038c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a9b775d2673486ebb5520f36ed2d0038c">s2n_cert_chain_and_key_set_ocsp_data</a> (struct s2n_cert_chain_and_key *chain_and_key, const uint8_t *data, uint32_t length)</td></tr>
<tr class="separator:a9b775d2673486ebb5520f36ed2d0038c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63cdab069deae3adaf560b298c8b837"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ad63cdab069deae3adaf560b298c8b837">s2n_cert_chain_and_key_set_sct_list</a> (struct s2n_cert_chain_and_key *chain_and_key, const uint8_t *data, uint32_t length)</td></tr>
<tr class="separator:ad63cdab069deae3adaf560b298c8b837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f2dab761bbb4b3eec095763a28f7af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a08f2dab761bbb4b3eec095763a28f7af">s2n_config_set_cert_tiebreak_callback</a> (struct s2n_config *config, <a class="el" href="s2n_8h.html#a0363fdf570a5451facfa12eb0a679586">s2n_cert_tiebreak_callback</a> cert_tiebreak_cb)</td></tr>
<tr class="separator:a08f2dab761bbb4b3eec095763a28f7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2c5705a56cdb5f9ca4932a24f838e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a5f2c5705a56cdb5f9ca4932a24f838e1">s2n_config_add_cert_chain_and_key</a> (struct s2n_config *config, const char *cert_chain_pem, const char *private_key_pem)</td></tr>
<tr class="separator:a5f2c5705a56cdb5f9ca4932a24f838e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb875eff7e81b22378e4ae5b313169f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#abfb875eff7e81b22378e4ae5b313169f">s2n_config_add_cert_chain_and_key_to_store</a> (struct s2n_config *config, struct s2n_cert_chain_and_key *cert_key_pair)</td></tr>
<tr class="separator:abfb875eff7e81b22378e4ae5b313169f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d021a10ad7183c995d6d2a65926272"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a30d021a10ad7183c995d6d2a65926272">s2n_config_set_cert_chain_and_key_defaults</a> (struct s2n_config *config, struct s2n_cert_chain_and_key **cert_key_pairs, uint32_t num_cert_key_pairs)</td></tr>
<tr class="separator:a30d021a10ad7183c995d6d2a65926272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85545629ce095ed44de580592eecf50e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a85545629ce095ed44de580592eecf50e">s2n_config_set_verification_ca_location</a> (struct s2n_config *config, const char *ca_pem_filename, const char *ca_dir)</td></tr>
<tr class="separator:a85545629ce095ed44de580592eecf50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de5c0b7a1029ee248947835d4e170bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a1de5c0b7a1029ee248947835d4e170bc">s2n_config_add_pem_to_trust_store</a> (struct s2n_config *config, const char *pem)</td></tr>
<tr class="separator:a1de5c0b7a1029ee248947835d4e170bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e2759066521827269d56d4da063f7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#af7e2759066521827269d56d4da063f7b">s2n_config_wipe_trust_store</a> (struct s2n_config *config)</td></tr>
<tr class="separator:af7e2759066521827269d56d4da063f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f99ca29318603bee3d3e1fb713e4577"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a3f99ca29318603bee3d3e1fb713e4577">s2n_config_load_system_certs</a> (struct s2n_config *config)</td></tr>
<tr class="separator:a3f99ca29318603bee3d3e1fb713e4577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0729c67323dbe0604e6b55f82afb6f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#aa0729c67323dbe0604e6b55f82afb6f6">s2n_config_set_verify_after_sign</a> (struct s2n_config *config, s2n_verify_after_sign mode)</td></tr>
<tr class="separator:aa0729c67323dbe0604e6b55f82afb6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de9d794c410474e9851880bd4914025"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a6de9d794c410474e9851880bd4914025">s2n_config_set_send_buffer_size</a> (struct s2n_config *config, uint32_t size)</td></tr>
<tr class="separator:a6de9d794c410474e9851880bd4914025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873c1969c18fdf8663a9b593e62b9460"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a873c1969c18fdf8663a9b593e62b9460">s2n_config_set_recv_multi_record</a> (struct s2n_config *config, bool enabled)</td></tr>
<tr class="separator:a873c1969c18fdf8663a9b593e62b9460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079022d5c18f4ffd64c1c6dedb3bbc66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a079022d5c18f4ffd64c1c6dedb3bbc66">s2n_config_set_verify_host_callback</a> (struct s2n_config *config, <a class="el" href="s2n_8h.html#a8aa56850695a02753f726ea9860ec383">s2n_verify_host_fn</a>, void *data)</td></tr>
<tr class="separator:a079022d5c18f4ffd64c1c6dedb3bbc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affff244d7ed6f3b8d1f885df1b307f4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#affff244d7ed6f3b8d1f885df1b307f4e">s2n_config_set_check_stapled_ocsp_response</a> (struct s2n_config *config, uint8_t check_ocsp)</td></tr>
<tr class="separator:affff244d7ed6f3b8d1f885df1b307f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdc139b4a68057aa0ce812b5f07138d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#abbdc139b4a68057aa0ce812b5f07138d">s2n_config_disable_x509_time_verification</a> (struct s2n_config *config)</td></tr>
<tr class="separator:abbdc139b4a68057aa0ce812b5f07138d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d89fb59987254fe2546881d172be18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#aa9d89fb59987254fe2546881d172be18">s2n_config_disable_x509_verification</a> (struct s2n_config *config)</td></tr>
<tr class="separator:aa9d89fb59987254fe2546881d172be18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe1f248fa4510df373890a70f6f39b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#adbe1f248fa4510df373890a70f6f39b9">s2n_config_set_max_cert_chain_depth</a> (struct s2n_config *config, uint16_t max_depth)</td></tr>
<tr class="separator:adbe1f248fa4510df373890a70f6f39b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9f9e33817a4984217de79b55b7c607"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a8e9f9e33817a4984217de79b55b7c607">s2n_config_add_dhparams</a> (struct s2n_config *config, const char *dhparams_pem)</td></tr>
<tr class="separator:a8e9f9e33817a4984217de79b55b7c607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afea5198d804621399d8fd9875cfdb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a3afea5198d804621399d8fd9875cfdb0">s2n_config_set_cipher_preferences</a> (struct s2n_config *config, const char *version)</td></tr>
<tr class="separator:a3afea5198d804621399d8fd9875cfdb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d822c2cf75cdb9d28f0b3cdf8edab02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a2d822c2cf75cdb9d28f0b3cdf8edab02">s2n_config_append_protocol_preference</a> (struct s2n_config *config, const uint8_t *protocol, uint8_t protocol_len)</td></tr>
<tr class="separator:a2d822c2cf75cdb9d28f0b3cdf8edab02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983bbc96f19466c51529501c63004910"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a983bbc96f19466c51529501c63004910">s2n_config_set_protocol_preferences</a> (struct s2n_config *config, const char *const *protocols, int protocol_count)</td></tr>
<tr class="separator:a983bbc96f19466c51529501c63004910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380252ebdd5077b7436a23c2cf7458c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a380252ebdd5077b7436a23c2cf7458c0">s2n_config_set_status_request_type</a> (struct s2n_config *config, <a class="el" href="s2n_8h.html#a7d38e45340d223d0100a2d4bc0526635">s2n_status_request_type</a> type)</td></tr>
<tr class="separator:a380252ebdd5077b7436a23c2cf7458c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604de45a27044a3eeb7c58575604bcee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a604de45a27044a3eeb7c58575604bcee">s2n_config_set_ct_support_level</a> (struct s2n_config *config, <a class="el" href="s2n_8h.html#ae8f37b612310a3594b019b88ebd8fa1a">s2n_ct_support_level</a> level)</td></tr>
<tr class="separator:a604de45a27044a3eeb7c58575604bcee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b3ba39cc1b929310270d4fe5ac1b02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a59b3ba39cc1b929310270d4fe5ac1b02">s2n_config_set_alert_behavior</a> (struct s2n_config *config, <a class="el" href="s2n_8h.html#ab8d3f62254ec4211d47cc841dea76abd">s2n_alert_behavior</a> alert_behavior)</td></tr>
<tr class="separator:a59b3ba39cc1b929310270d4fe5ac1b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2250c2b461d0814c4e5dd969d0f372f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a2250c2b461d0814c4e5dd969d0f372f1">s2n_config_set_extension_data</a> (struct s2n_config *config, <a class="el" href="s2n_8h.html#ab2b46f61765da5529f931afb8dd8a1f8">s2n_tls_extension_type</a> type, const uint8_t *data, uint32_t length)</td></tr>
<tr class="separator:a2250c2b461d0814c4e5dd969d0f372f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2ab042e1f9dea7ff02b3746dc16188"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a0f2ab042e1f9dea7ff02b3746dc16188">s2n_config_send_max_fragment_length</a> (struct s2n_config *config, <a class="el" href="s2n_8h.html#a1976b2365808c341247e03131c2423ac">s2n_max_frag_len</a> mfl_code)</td></tr>
<tr class="separator:a0f2ab042e1f9dea7ff02b3746dc16188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d36a77c4bbcd04ea33b84ffd074fb8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a1d36a77c4bbcd04ea33b84ffd074fb8f">s2n_config_accept_max_fragment_length</a> (struct s2n_config *config)</td></tr>
<tr class="separator:a1d36a77c4bbcd04ea33b84ffd074fb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012950b0841dad53f4ce0b7bd9892757"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a012950b0841dad53f4ce0b7bd9892757">s2n_config_set_session_state_lifetime</a> (struct s2n_config *config, uint64_t lifetime_in_secs)</td></tr>
<tr class="separator:a012950b0841dad53f4ce0b7bd9892757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb17f02a0b6a6c74e3db143c7c3d62a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#afb17f02a0b6a6c74e3db143c7c3d62a6">s2n_config_set_session_tickets_onoff</a> (struct s2n_config *config, uint8_t enabled)</td></tr>
<tr class="separator:afb17f02a0b6a6c74e3db143c7c3d62a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746edac026a2d26f4a09ff4183beb9e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a746edac026a2d26f4a09ff4183beb9e9">s2n_config_set_session_cache_onoff</a> (struct s2n_config *config, uint8_t enabled)</td></tr>
<tr class="separator:a746edac026a2d26f4a09ff4183beb9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ac0a3900f9784804dff154ea404f83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a54ac0a3900f9784804dff154ea404f83">s2n_config_set_ticket_encrypt_decrypt_key_lifetime</a> (struct s2n_config *config, uint64_t lifetime_in_secs)</td></tr>
<tr class="separator:a54ac0a3900f9784804dff154ea404f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59be9ad4336811d9910f07bb74edb364"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a59be9ad4336811d9910f07bb74edb364">s2n_config_set_ticket_decrypt_key_lifetime</a> (struct s2n_config *config, uint64_t lifetime_in_secs)</td></tr>
<tr class="separator:a59be9ad4336811d9910f07bb74edb364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d6a59a875a39fdd9f81ae02595173d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ae6d6a59a875a39fdd9f81ae02595173d">s2n_config_add_ticket_crypto_key</a> (struct s2n_config *config, const uint8_t *name, uint32_t name_len, uint8_t *key, uint32_t key_len, uint64_t intro_time_in_seconds_from_epoch)</td></tr>
<tr class="separator:ae6d6a59a875a39fdd9f81ae02595173d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b61c7518ebbb88cf0c481dd3412b48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a83b61c7518ebbb88cf0c481dd3412b48">s2n_config_require_ticket_forward_secrecy</a> (struct s2n_config *config, bool enabled)</td></tr>
<tr class="separator:a83b61c7518ebbb88cf0c481dd3412b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99493d7c1f33f5f5390dd0fdd95ab431"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a99493d7c1f33f5f5390dd0fdd95ab431">s2n_config_set_ctx</a> (struct s2n_config *config, void *ctx)</td></tr>
<tr class="separator:a99493d7c1f33f5f5390dd0fdd95ab431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab325136d7c254e6f72d2a134ad59f759"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ab325136d7c254e6f72d2a134ad59f759">s2n_config_get_ctx</a> (struct s2n_config *config, void **ctx)</td></tr>
<tr class="separator:ab325136d7c254e6f72d2a134ad59f759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58005ebdc3e4caf6b6f40321bbc5b1e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> struct s2n_connection *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a58005ebdc3e4caf6b6f40321bbc5b1e5">s2n_connection_new</a> (<a class="el" href="s2n_8h.html#a77a64e3b657f90d221c5faf99c643cdb">s2n_mode</a> mode)</td></tr>
<tr class="separator:a58005ebdc3e4caf6b6f40321bbc5b1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4b60e86b018ff4b354421e526c6bd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#abe4b60e86b018ff4b354421e526c6bd1">s2n_connection_set_config</a> (struct s2n_connection *conn, struct s2n_config *config)</td></tr>
<tr class="separator:abe4b60e86b018ff4b354421e526c6bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe22b04670c9345ed5c25b261ee4de72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#abe22b04670c9345ed5c25b261ee4de72">s2n_connection_set_ctx</a> (struct s2n_connection *conn, void *ctx)</td></tr>
<tr class="separator:abe22b04670c9345ed5c25b261ee4de72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a3ba62c0029c622de99c7edbddfb9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ad2a3ba62c0029c622de99c7edbddfb9c">s2n_connection_get_ctx</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:ad2a3ba62c0029c622de99c7edbddfb9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae98777bf82821ce4d1989d224a50c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#aaae98777bf82821ce4d1989d224a50c0">s2n_config_set_client_hello_cb</a> (struct s2n_config *config, <a class="el" href="s2n_8h.html#a0451dcbf88fdf09f36a82cab4d25d44e">s2n_client_hello_fn</a> client_hello_callback, void *ctx)</td></tr>
<tr class="separator:aaae98777bf82821ce4d1989d224a50c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e005fa4cdf98cbf99dac6f592f7b39b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a0e005fa4cdf98cbf99dac6f592f7b39b">s2n_config_set_client_hello_cb_mode</a> (struct s2n_config *config, <a class="el" href="s2n_8h.html#a7aa9070e5b2de634b4a6fcb2bde98e68">s2n_client_hello_cb_mode</a> cb_mode)</td></tr>
<tr class="separator:a0e005fa4cdf98cbf99dac6f592f7b39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6345dc29f734d06419e7788024b557a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#af6345dc29f734d06419e7788024b557a">s2n_client_hello_cb_done</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:af6345dc29f734d06419e7788024b557a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cfccf774ddf237a30eb9c2fc9b0831"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a71cfccf774ddf237a30eb9c2fc9b0831">s2n_connection_server_name_extension_used</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:a71cfccf774ddf237a30eb9c2fc9b0831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c64d96b5b9a4cb600a22157d6743e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> struct s2n_client_hello *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ac0c64d96b5b9a4cb600a22157d6743e3">s2n_connection_get_client_hello</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:ac0c64d96b5b9a4cb600a22157d6743e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf329c844fa13ec9ccef34da945d7f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> struct s2n_client_hello *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#aacf329c844fa13ec9ccef34da945d7f2">s2n_client_hello_parse_message</a> (const uint8_t *bytes, uint32_t size)</td></tr>
<tr class="separator:aacf329c844fa13ec9ccef34da945d7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad664daed9d1c437460c563c6f02157d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ad664daed9d1c437460c563c6f02157d9">s2n_client_hello_free</a> (struct s2n_client_hello **ch)</td></tr>
<tr class="separator:ad664daed9d1c437460c563c6f02157d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2c0de61921c9ddc8e8c4e56084cc6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a4c2c0de61921c9ddc8e8c4e56084cc6c">s2n_client_hello_get_raw_message_length</a> (struct s2n_client_hello *ch)</td></tr>
<tr class="separator:a4c2c0de61921c9ddc8e8c4e56084cc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fc624f4ffe9378ad77eea895bb52d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ac1fc624f4ffe9378ad77eea895bb52d6">s2n_client_hello_get_raw_message</a> (struct s2n_client_hello *ch, uint8_t *out, uint32_t max_length)</td></tr>
<tr class="separator:ac1fc624f4ffe9378ad77eea895bb52d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836ac7d852fbb18b790c8084878e1b5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a836ac7d852fbb18b790c8084878e1b5d">s2n_client_hello_get_cipher_suites_length</a> (struct s2n_client_hello *ch)</td></tr>
<tr class="separator:a836ac7d852fbb18b790c8084878e1b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83eff4e25edddcd4688854e0c4d8e62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ab83eff4e25edddcd4688854e0c4d8e62">s2n_client_hello_get_cipher_suites</a> (struct s2n_client_hello *ch, uint8_t *out, uint32_t max_length)</td></tr>
<tr class="separator:ab83eff4e25edddcd4688854e0c4d8e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c10c0917fcda2f6a546310f7b80b8fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a9c10c0917fcda2f6a546310f7b80b8fa">s2n_client_hello_get_extensions_length</a> (struct s2n_client_hello *ch)</td></tr>
<tr class="separator:a9c10c0917fcda2f6a546310f7b80b8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae872d221c8d47cab5178cfd3ca00bca4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ae872d221c8d47cab5178cfd3ca00bca4">s2n_client_hello_get_extensions</a> (struct s2n_client_hello *ch, uint8_t *out, uint32_t max_length)</td></tr>
<tr class="separator:ae872d221c8d47cab5178cfd3ca00bca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6709ea1bac503daf846990821d8f36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#aba6709ea1bac503daf846990821d8f36">s2n_client_hello_get_extension_length</a> (struct s2n_client_hello *ch, <a class="el" href="s2n_8h.html#ab2b46f61765da5529f931afb8dd8a1f8">s2n_tls_extension_type</a> extension_type)</td></tr>
<tr class="separator:aba6709ea1bac503daf846990821d8f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad69c8c71521b13b69bcd77fea92b74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a5ad69c8c71521b13b69bcd77fea92b74">s2n_client_hello_get_extension_by_id</a> (struct s2n_client_hello *ch, <a class="el" href="s2n_8h.html#ab2b46f61765da5529f931afb8dd8a1f8">s2n_tls_extension_type</a> extension_type, uint8_t *out, uint32_t max_length)</td></tr>
<tr class="separator:a5ad69c8c71521b13b69bcd77fea92b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be05b74838db77a70ce8aba82b284fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a1be05b74838db77a70ce8aba82b284fa">s2n_client_hello_has_extension</a> (struct s2n_client_hello *ch, uint16_t extension_iana, bool *exists)</td></tr>
<tr class="separator:a1be05b74838db77a70ce8aba82b284fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803cebda25d3d8beadfd2981bfc0faa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a803cebda25d3d8beadfd2981bfc0faa2">s2n_client_hello_get_session_id_length</a> (struct s2n_client_hello *ch, uint32_t *out_length)</td></tr>
<tr class="separator:a803cebda25d3d8beadfd2981bfc0faa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86458717edccfb2f58b86f3991af1a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ae86458717edccfb2f58b86f3991af1a9">s2n_client_hello_get_session_id</a> (struct s2n_client_hello *ch, uint8_t *out, uint32_t *out_length, uint32_t max_length)</td></tr>
<tr class="separator:ae86458717edccfb2f58b86f3991af1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a3487dda504244c2b81978de6d79bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a76a3487dda504244c2b81978de6d79bb">s2n_client_hello_get_compression_methods_length</a> (struct s2n_client_hello *ch, uint32_t *out_length)</td></tr>
<tr class="separator:a76a3487dda504244c2b81978de6d79bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbab79e2b5c583efaf918283fb0222bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#adbab79e2b5c583efaf918283fb0222bf">s2n_client_hello_get_compression_methods</a> (struct s2n_client_hello *ch, uint8_t *list, uint32_t list_length, uint32_t *out_length)</td></tr>
<tr class="separator:adbab79e2b5c583efaf918283fb0222bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff080b07553418e574fa5907c6d2ca0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#aeff080b07553418e574fa5907c6d2ca0">s2n_client_hello_get_legacy_protocol_version</a> (struct s2n_client_hello *ch, uint8_t *out)</td></tr>
<tr class="separator:aeff080b07553418e574fa5907c6d2ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a751eb59517406db2439a88e94d8d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a68a751eb59517406db2439a88e94d8d1">s2n_client_hello_get_supported_groups</a> (struct s2n_client_hello *ch, uint16_t *groups, uint16_t groups_count_max, uint16_t *groups_count)</td></tr>
<tr class="separator:a68a751eb59517406db2439a88e94d8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4345089b56dee57f4c6f97c04588289e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a4345089b56dee57f4c6f97c04588289e">s2n_client_hello_get_server_name_length</a> (struct s2n_client_hello *ch, uint16_t *length)</td></tr>
<tr class="separator:a4345089b56dee57f4c6f97c04588289e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b362b99e61c3da07b6be2f9c4cff3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a13b362b99e61c3da07b6be2f9c4cff3f">s2n_client_hello_get_server_name</a> (struct s2n_client_hello *ch, uint8_t *server_name, uint16_t length, uint16_t *out_length)</td></tr>
<tr class="separator:a13b362b99e61c3da07b6be2f9c4cff3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67962bf835ce5145d215a9ee8f4985d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a67962bf835ce5145d215a9ee8f4985d3">s2n_connection_set_fd</a> (struct s2n_connection *conn, int fd)</td></tr>
<tr class="separator:a67962bf835ce5145d215a9ee8f4985d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75014bd12d682e91ab2812c2e92c16d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#aa75014bd12d682e91ab2812c2e92c16d">s2n_connection_set_read_fd</a> (struct s2n_connection *conn, int readfd)</td></tr>
<tr class="separator:aa75014bd12d682e91ab2812c2e92c16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8153e24a1b79e7b68ac7a1f7f7d8d0ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a8153e24a1b79e7b68ac7a1f7f7d8d0ea">s2n_connection_set_write_fd</a> (struct s2n_connection *conn, int writefd)</td></tr>
<tr class="separator:a8153e24a1b79e7b68ac7a1f7f7d8d0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17cb0e4df7046226139408cfe7b3688d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a17cb0e4df7046226139408cfe7b3688d">s2n_connection_get_read_fd</a> (struct s2n_connection *conn, int *readfd)</td></tr>
<tr class="separator:a17cb0e4df7046226139408cfe7b3688d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b65b19decd099dfe580306c04cb210"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a91b65b19decd099dfe580306c04cb210">s2n_connection_get_write_fd</a> (struct s2n_connection *conn, int *writefd)</td></tr>
<tr class="separator:a91b65b19decd099dfe580306c04cb210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d835f1152a699dfd00ff781c86774e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a91d835f1152a699dfd00ff781c86774e">s2n_connection_use_corked_io</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:a91d835f1152a699dfd00ff781c86774e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e1ad17b8453e9ef8ca1df35b7f0ae7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a67e1ad17b8453e9ef8ca1df35b7f0ae7">s2n_connection_set_recv_ctx</a> (struct s2n_connection *conn, void *ctx)</td></tr>
<tr class="separator:a67e1ad17b8453e9ef8ca1df35b7f0ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4857138d82f79f939546693b587a61d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a4857138d82f79f939546693b587a61d4">s2n_connection_set_send_ctx</a> (struct s2n_connection *conn, void *ctx)</td></tr>
<tr class="separator:a4857138d82f79f939546693b587a61d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699fd9e05a8e8163811db6cab01af973"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a699fd9e05a8e8163811db6cab01af973">s2n_connection_set_recv_cb</a> (struct s2n_connection *conn, <a class="el" href="s2n_8h.html#a0b5d6b77e35bf16aee077fe1c5860cc9">s2n_recv_fn</a> recv)</td></tr>
<tr class="separator:a699fd9e05a8e8163811db6cab01af973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b73b9a8fa03500d5bc609d09035cd45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a4b73b9a8fa03500d5bc609d09035cd45">s2n_connection_set_send_cb</a> (struct s2n_connection *conn, <a class="el" href="s2n_8h.html#ad8ae4eeefcfc81bc4daf429512612687">s2n_send_fn</a> send)</td></tr>
<tr class="separator:a4b73b9a8fa03500d5bc609d09035cd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c72914bfc09a9174b6a7b019e5aa5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a11c72914bfc09a9174b6a7b019e5aa5c">s2n_connection_prefer_throughput</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:a11c72914bfc09a9174b6a7b019e5aa5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4fafb7e9b8277f408af0ad17ab6e19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a9b4fafb7e9b8277f408af0ad17ab6e19">s2n_connection_prefer_low_latency</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:a9b4fafb7e9b8277f408af0ad17ab6e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30791c458875956ef9f4cdbd8c8c19f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ae30791c458875956ef9f4cdbd8c8c19f">s2n_connection_set_recv_buffering</a> (struct s2n_connection *conn, bool enabled)</td></tr>
<tr class="separator:ae30791c458875956ef9f4cdbd8c8c19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e66cd9a37ddf82419039cdc60b28895"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a9e66cd9a37ddf82419039cdc60b28895">s2n_peek_buffered</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:a9e66cd9a37ddf82419039cdc60b28895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5399ba44a921d36ed34661038a509d1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a5399ba44a921d36ed34661038a509d1a">s2n_connection_set_dynamic_buffers</a> (struct s2n_connection *conn, bool enabled)</td></tr>
<tr class="separator:a5399ba44a921d36ed34661038a509d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5f14855b2810a9857b1a41f2cc92f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#add5f14855b2810a9857b1a41f2cc92f9">s2n_connection_set_dynamic_record_threshold</a> (struct s2n_connection *conn, uint32_t resize_threshold, uint16_t timeout_threshold)</td></tr>
<tr class="separator:add5f14855b2810a9857b1a41f2cc92f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39f5c65f5c201d7af140baff29a02eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ad39f5c65f5c201d7af140baff29a02eb">s2n_connection_set_verify_host_callback</a> (struct s2n_connection *conn, <a class="el" href="s2n_8h.html#a8aa56850695a02753f726ea9860ec383">s2n_verify_host_fn</a> host_fn, void *data)</td></tr>
<tr class="separator:ad39f5c65f5c201d7af140baff29a02eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684b2e5c86c85f089392bd1a49d38e17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a684b2e5c86c85f089392bd1a49d38e17">s2n_connection_set_blinding</a> (struct s2n_connection *conn, <a class="el" href="s2n_8h.html#a364ad496c9dd42fd3117a2f9d3289e62">s2n_blinding</a> blinding)</td></tr>
<tr class="separator:a684b2e5c86c85f089392bd1a49d38e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a2a372d2d13cef62357473b7fea568"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ab8a2a372d2d13cef62357473b7fea568">s2n_connection_get_delay</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:ab8a2a372d2d13cef62357473b7fea568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6202daaf67fa8e47cb8d79071ff5066"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#aa6202daaf67fa8e47cb8d79071ff5066">s2n_config_set_max_blinding_delay</a> (struct s2n_config *config, uint32_t seconds)</td></tr>
<tr class="separator:aa6202daaf67fa8e47cb8d79071ff5066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4544d664e827a426b484b3eaa62063d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ab4544d664e827a426b484b3eaa62063d">s2n_connection_set_cipher_preferences</a> (struct s2n_connection *conn, const char *version)</td></tr>
<tr class="separator:ab4544d664e827a426b484b3eaa62063d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824fed871df4202b6bd5428ee791f660"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a824fed871df4202b6bd5428ee791f660">s2n_connection_request_key_update</a> (struct s2n_connection *conn, <a class="el" href="s2n_8h.html#aa8ab6cd4a526f781116a39bd16bab9ba">s2n_peer_key_update</a> peer_request)</td></tr>
<tr class="separator:a824fed871df4202b6bd5428ee791f660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbf7aa3eb0834357994ea902d6c4847"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a1cbf7aa3eb0834357994ea902d6c4847">s2n_connection_append_protocol_preference</a> (struct s2n_connection *conn, const uint8_t *protocol, uint8_t protocol_len)</td></tr>
<tr class="separator:a1cbf7aa3eb0834357994ea902d6c4847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7fc1efa730562ff9a804fe578235b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a1e7fc1efa730562ff9a804fe578235b4">s2n_connection_set_protocol_preferences</a> (struct s2n_connection *conn, const char *const *protocols, int protocol_count)</td></tr>
<tr class="separator:a1e7fc1efa730562ff9a804fe578235b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c2488271997ea0b0b21d3937e612f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#af5c2488271997ea0b0b21d3937e612f6">s2n_set_server_name</a> (struct s2n_connection *conn, const char *server_name)</td></tr>
<tr class="separator:af5c2488271997ea0b0b21d3937e612f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22dc30ff2bf6f66673b8a175fdfe0c29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a22dc30ff2bf6f66673b8a175fdfe0c29">s2n_get_server_name</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:a22dc30ff2bf6f66673b8a175fdfe0c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53faa26669e258afff875d45140f14e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ae53faa26669e258afff875d45140f14e">s2n_get_application_protocol</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:ae53faa26669e258afff875d45140f14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad8092d7c616efd40bb0145c4895f1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a8ad8092d7c616efd40bb0145c4895f1f">s2n_connection_get_ocsp_response</a> (struct s2n_connection *conn, uint32_t *length)</td></tr>
<tr class="separator:a8ad8092d7c616efd40bb0145c4895f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd40473bc173fc0cfedc43fe469732d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a5dd40473bc173fc0cfedc43fe469732d">s2n_connection_get_sct_list</a> (struct s2n_connection *conn, uint32_t *length)</td></tr>
<tr class="separator:a5dd40473bc173fc0cfedc43fe469732d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3222e7aacf35a56be842678171be440"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ad3222e7aacf35a56be842678171be440">s2n_negotiate</a> (struct s2n_connection *conn, <a class="el" href="s2n_8h.html#af70ca0b089daa98cd79a424d3f6af15d">s2n_blocked_status</a> *blocked)</td></tr>
<tr class="separator:ad3222e7aacf35a56be842678171be440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9afeb514731fa9d74edf6b9e1348c067"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a9afeb514731fa9d74edf6b9e1348c067">s2n_send</a> (struct s2n_connection *conn, const void *buf, ssize_t size, <a class="el" href="s2n_8h.html#af70ca0b089daa98cd79a424d3f6af15d">s2n_blocked_status</a> *blocked)</td></tr>
<tr class="separator:a9afeb514731fa9d74edf6b9e1348c067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726589f5cc8871b5efe9740aca05ed97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a726589f5cc8871b5efe9740aca05ed97">s2n_sendv</a> (struct s2n_connection *conn, const struct iovec *bufs, ssize_t count, <a class="el" href="s2n_8h.html#af70ca0b089daa98cd79a424d3f6af15d">s2n_blocked_status</a> *blocked)</td></tr>
<tr class="separator:a726589f5cc8871b5efe9740aca05ed97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b09f96a5f4fe3b78a08e76e7304853f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a1b09f96a5f4fe3b78a08e76e7304853f">s2n_sendv_with_offset</a> (struct s2n_connection *conn, const struct iovec *bufs, ssize_t count, ssize_t offs, <a class="el" href="s2n_8h.html#af70ca0b089daa98cd79a424d3f6af15d">s2n_blocked_status</a> *blocked)</td></tr>
<tr class="separator:a1b09f96a5f4fe3b78a08e76e7304853f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b67ff058796d4c6c6caddfd0f10274e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a3b67ff058796d4c6c6caddfd0f10274e">s2n_recv</a> (struct s2n_connection *conn, void *buf, ssize_t size, <a class="el" href="s2n_8h.html#af70ca0b089daa98cd79a424d3f6af15d">s2n_blocked_status</a> *blocked)</td></tr>
<tr class="separator:a3b67ff058796d4c6c6caddfd0f10274e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b49cd285e03ba447a8250f01864cca5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a1b49cd285e03ba447a8250f01864cca5">s2n_peek</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:a1b49cd285e03ba447a8250f01864cca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcc520aac12e66149d83859e8e62d92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a0dcc520aac12e66149d83859e8e62d92">s2n_connection_free_handshake</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:a0dcc520aac12e66149d83859e8e62d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86a8545d176c7097fa036649968a896"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#af86a8545d176c7097fa036649968a896">s2n_connection_release_buffers</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:af86a8545d176c7097fa036649968a896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42c3c7b37df666c2b3e6a53c1ea5f76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ae42c3c7b37df666c2b3e6a53c1ea5f76">s2n_connection_wipe</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:ae42c3c7b37df666c2b3e6a53c1ea5f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7664ec2fe4c694148ad303f4229f94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a9c7664ec2fe4c694148ad303f4229f94">s2n_connection_free</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:a9c7664ec2fe4c694148ad303f4229f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6abacafd51a48a2870755d765f56e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#aff6abacafd51a48a2870755d765f56e8">s2n_shutdown</a> (struct s2n_connection *conn, <a class="el" href="s2n_8h.html#af70ca0b089daa98cd79a424d3f6af15d">s2n_blocked_status</a> *blocked)</td></tr>
<tr class="separator:aff6abacafd51a48a2870755d765f56e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed14fae7ae16fffda06087b8aec78035"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#aed14fae7ae16fffda06087b8aec78035">s2n_shutdown_send</a> (struct s2n_connection *conn, <a class="el" href="s2n_8h.html#af70ca0b089daa98cd79a424d3f6af15d">s2n_blocked_status</a> *blocked)</td></tr>
<tr class="separator:aed14fae7ae16fffda06087b8aec78035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2229eaee45a85050eae6b12924e6fea3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a2229eaee45a85050eae6b12924e6fea3">s2n_config_get_client_auth_type</a> (struct s2n_config *config, <a class="el" href="s2n_8h.html#a8757c094681bb8151329c8dc067106b8">s2n_cert_auth_type</a> *client_auth_type)</td></tr>
<tr class="separator:a2229eaee45a85050eae6b12924e6fea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923be772e04a448409f93d4cf234ca33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a923be772e04a448409f93d4cf234ca33">s2n_config_set_client_auth_type</a> (struct s2n_config *config, <a class="el" href="s2n_8h.html#a8757c094681bb8151329c8dc067106b8">s2n_cert_auth_type</a> client_auth_type)</td></tr>
<tr class="separator:a923be772e04a448409f93d4cf234ca33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6dbfb5892b7cc52a759422ab478a77c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#aa6dbfb5892b7cc52a759422ab478a77c">s2n_connection_get_client_auth_type</a> (struct s2n_connection *conn, <a class="el" href="s2n_8h.html#a8757c094681bb8151329c8dc067106b8">s2n_cert_auth_type</a> *client_auth_type)</td></tr>
<tr class="separator:aa6dbfb5892b7cc52a759422ab478a77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2985adfcaa565bf3cf35edb4ae4f854"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ad2985adfcaa565bf3cf35edb4ae4f854">s2n_connection_set_client_auth_type</a> (struct s2n_connection *conn, <a class="el" href="s2n_8h.html#a8757c094681bb8151329c8dc067106b8">s2n_cert_auth_type</a> client_auth_type)</td></tr>
<tr class="separator:ad2985adfcaa565bf3cf35edb4ae4f854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2758d2962e1ad05b369452d5a6a674"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a5f2758d2962e1ad05b369452d5a6a674">s2n_connection_get_client_cert_chain</a> (struct s2n_connection *conn, uint8_t **der_cert_chain_out, uint32_t *cert_chain_len)</td></tr>
<tr class="separator:a5f2758d2962e1ad05b369452d5a6a674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fbabcd7bc5673315db4c4570d451d02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a4fbabcd7bc5673315db4c4570d451d02">s2n_config_set_initial_ticket_count</a> (struct s2n_config *config, uint8_t num)</td></tr>
<tr class="separator:a4fbabcd7bc5673315db4c4570d451d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9e5abc313209df9dea126fb44f750a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a0c9e5abc313209df9dea126fb44f750a">s2n_connection_add_new_tickets_to_send</a> (struct s2n_connection *conn, uint8_t num)</td></tr>
<tr class="separator:a0c9e5abc313209df9dea126fb44f750a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a28dbd00b5ac7941f6620241bad9ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a56a28dbd00b5ac7941f6620241bad9ba">s2n_connection_get_tickets_sent</a> (struct s2n_connection *conn, uint16_t *num)</td></tr>
<tr class="separator:a56a28dbd00b5ac7941f6620241bad9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37cb3fbcfef883aa637322152fe75819"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a37cb3fbcfef883aa637322152fe75819">s2n_connection_set_server_keying_material_lifetime</a> (struct s2n_connection *conn, uint32_t lifetime_in_secs)</td></tr>
<tr class="separator:a37cb3fbcfef883aa637322152fe75819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa823f209bd1e3b046887a5ed32b685a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#aa823f209bd1e3b046887a5ed32b685a5">s2n_config_set_session_ticket_cb</a> (struct s2n_config *config, <a class="el" href="s2n_8h.html#a87a1b430e8782d95dc60efbec7cd6118">s2n_session_ticket_fn</a> callback, void *ctx)</td></tr>
<tr class="separator:aa823f209bd1e3b046887a5ed32b685a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe49863d3ac879da25dab8536da65450"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#afe49863d3ac879da25dab8536da65450">s2n_session_ticket_get_data_len</a> (struct s2n_session_ticket *ticket, size_t *data_len)</td></tr>
<tr class="separator:afe49863d3ac879da25dab8536da65450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa104cedfc08cb14579a6ee93c468b3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#afa104cedfc08cb14579a6ee93c468b3a">s2n_session_ticket_get_data</a> (struct s2n_session_ticket *ticket, size_t max_data_len, uint8_t *data)</td></tr>
<tr class="separator:afa104cedfc08cb14579a6ee93c468b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac4aef516a29664d6a771dbef829330"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a5ac4aef516a29664d6a771dbef829330">s2n_session_ticket_get_lifetime</a> (struct s2n_session_ticket *ticket, uint32_t *session_lifetime)</td></tr>
<tr class="separator:a5ac4aef516a29664d6a771dbef829330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf779e2e30ec1881f5f63bfae5dc3303"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#aaf779e2e30ec1881f5f63bfae5dc3303">s2n_connection_set_session</a> (struct s2n_connection *conn, const uint8_t *session, size_t length)</td></tr>
<tr class="separator:aaf779e2e30ec1881f5f63bfae5dc3303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ed55a367727eea8e041630406bb144"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ae1ed55a367727eea8e041630406bb144">s2n_connection_get_session</a> (struct s2n_connection *conn, uint8_t *session, size_t max_length)</td></tr>
<tr class="separator:ae1ed55a367727eea8e041630406bb144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8f58e34e1fc8eb35f7ac8fe55123a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a8a8f58e34e1fc8eb35f7ac8fe55123a5">s2n_connection_get_session_ticket_lifetime_hint</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:a8a8f58e34e1fc8eb35f7ac8fe55123a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b2840c308f1e6d9a5a47631e9991c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ab0b2840c308f1e6d9a5a47631e9991c2">s2n_connection_get_session_length</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:ab0b2840c308f1e6d9a5a47631e9991c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc34cfe4ca708912cf9309cc98000c08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#acc34cfe4ca708912cf9309cc98000c08">s2n_connection_get_session_id_length</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:acc34cfe4ca708912cf9309cc98000c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242a28fb68a8903416dc0de77ff4b1bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a242a28fb68a8903416dc0de77ff4b1bc">s2n_connection_get_session_id</a> (struct s2n_connection *conn, uint8_t *session_id, size_t max_length)</td></tr>
<tr class="separator:a242a28fb68a8903416dc0de77ff4b1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3657d081eb0957f87d93391653eb20c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ae3657d081eb0957f87d93391653eb20c">s2n_connection_is_session_resumed</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:ae3657d081eb0957f87d93391653eb20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfbc4fdc9d191bb4d6d9040762b208b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#addfbc4fdc9d191bb4d6d9040762b208b">s2n_connection_is_ocsp_stapled</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:addfbc4fdc9d191bb4d6d9040762b208b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37352212fe3ebb17b9bf8ca9cc9ea7fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a37352212fe3ebb17b9bf8ca9cc9ea7fd">s2n_connection_get_selected_signature_algorithm</a> (struct s2n_connection *conn, <a class="el" href="s2n_8h.html#a9812997751f63ac2d5ab70852792a689">s2n_tls_signature_algorithm</a> *chosen_alg)</td></tr>
<tr class="separator:a37352212fe3ebb17b9bf8ca9cc9ea7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c882c74b21dd1e36d40e5b2a5beea5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a13c882c74b21dd1e36d40e5b2a5beea5">s2n_connection_get_selected_digest_algorithm</a> (struct s2n_connection *conn, <a class="el" href="s2n_8h.html#a08eccb21b18130aef8c19a288801f379">s2n_tls_hash_algorithm</a> *chosen_alg)</td></tr>
<tr class="separator:a13c882c74b21dd1e36d40e5b2a5beea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4311542818a2f029b2f157803949faa4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a4311542818a2f029b2f157803949faa4">s2n_connection_get_selected_client_cert_signature_algorithm</a> (struct s2n_connection *conn, <a class="el" href="s2n_8h.html#a9812997751f63ac2d5ab70852792a689">s2n_tls_signature_algorithm</a> *chosen_alg)</td></tr>
<tr class="separator:a4311542818a2f029b2f157803949faa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3201f28508d383632996dcc861a521d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a3201f28508d383632996dcc861a521d4">s2n_connection_get_selected_client_cert_digest_algorithm</a> (struct s2n_connection *conn, <a class="el" href="s2n_8h.html#a08eccb21b18130aef8c19a288801f379">s2n_tls_hash_algorithm</a> *chosen_alg)</td></tr>
<tr class="separator:a3201f28508d383632996dcc861a521d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42c827e46b894c9cbf5ed309852526f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#af42c827e46b894c9cbf5ed309852526f">s2n_connection_get_signature_scheme</a> (struct s2n_connection *conn, const char **scheme_name)</td></tr>
<tr class="separator:af42c827e46b894c9cbf5ed309852526f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ec12d27f27f757ddfaf2bcadc9956a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> struct s2n_cert_chain_and_key *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#aa2ec12d27f27f757ddfaf2bcadc9956a">s2n_connection_get_selected_cert</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:aa2ec12d27f27f757ddfaf2bcadc9956a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346a183c22e8b394c17bd22ac54b1553"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a346a183c22e8b394c17bd22ac54b1553">s2n_cert_chain_get_length</a> (const struct s2n_cert_chain_and_key *chain_and_key, uint32_t *cert_length)</td></tr>
<tr class="separator:a346a183c22e8b394c17bd22ac54b1553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff55ae6c460d145a33e59392d92e81a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#aff55ae6c460d145a33e59392d92e81a1">s2n_cert_chain_get_cert</a> (const struct s2n_cert_chain_and_key *chain_and_key, struct s2n_cert **out_cert, const uint32_t cert_idx)</td></tr>
<tr class="separator:aff55ae6c460d145a33e59392d92e81a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff84930291800897ca24eeaa0e3ad8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#afff84930291800897ca24eeaa0e3ad8a">s2n_cert_get_der</a> (const struct s2n_cert *cert, const uint8_t **out_cert_der, uint32_t *cert_length)</td></tr>
<tr class="separator:afff84930291800897ca24eeaa0e3ad8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea94d670ca52905adad56cb3e2ef187b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#aea94d670ca52905adad56cb3e2ef187b">s2n_connection_get_peer_cert_chain</a> (const struct s2n_connection *conn, struct s2n_cert_chain_and_key *cert_chain)</td></tr>
<tr class="separator:aea94d670ca52905adad56cb3e2ef187b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac894d4595895577e79f0e6b4d0be4477"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ac894d4595895577e79f0e6b4d0be4477">s2n_cert_get_x509_extension_value_length</a> (struct s2n_cert *cert, const uint8_t *oid, uint32_t *ext_value_len)</td></tr>
<tr class="separator:ac894d4595895577e79f0e6b4d0be4477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a76b1f91bd6cb0132a768ab00680f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ab7a76b1f91bd6cb0132a768ab00680f3">s2n_cert_get_x509_extension_value</a> (struct s2n_cert *cert, const uint8_t *oid, uint8_t *ext_value, uint32_t *ext_value_len, bool *critical)</td></tr>
<tr class="separator:ab7a76b1f91bd6cb0132a768ab00680f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e50322739b7d5025d71684e400bcee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a83e50322739b7d5025d71684e400bcee">s2n_cert_get_utf8_string_from_extension_data_length</a> (const uint8_t *extension_data, uint32_t extension_len, uint32_t *utf8_str_len)</td></tr>
<tr class="separator:a83e50322739b7d5025d71684e400bcee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f746088134992ddc34bb6dbcb7f993"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#af7f746088134992ddc34bb6dbcb7f993">s2n_cert_get_utf8_string_from_extension_data</a> (const uint8_t *extension_data, uint32_t extension_len, uint8_t *out_data, uint32_t *out_len)</td></tr>
<tr class="separator:af7f746088134992ddc34bb6dbcb7f993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2213d536228ff00449ecef87ca6006c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> struct s2n_psk *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ab2213d536228ff00449ecef87ca6006c">s2n_external_psk_new</a> (void)</td></tr>
<tr class="separator:ab2213d536228ff00449ecef87ca6006c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d81a1590c967f58b2a5d5acbf1cb33f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a7d81a1590c967f58b2a5d5acbf1cb33f">s2n_psk_free</a> (struct s2n_psk **psk)</td></tr>
<tr class="separator:a7d81a1590c967f58b2a5d5acbf1cb33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e056dcc33bad30db288ca43026d87b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a62e056dcc33bad30db288ca43026d87b">s2n_psk_set_identity</a> (struct s2n_psk *psk, const uint8_t *identity, uint16_t identity_size)</td></tr>
<tr class="separator:a62e056dcc33bad30db288ca43026d87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95f6b44cd77ae6fd057185040697f22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ad95f6b44cd77ae6fd057185040697f22">s2n_psk_set_secret</a> (struct s2n_psk *psk, const uint8_t *secret, uint16_t secret_size)</td></tr>
<tr class="separator:ad95f6b44cd77ae6fd057185040697f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e08ceb8cc253bd4f9448ee10a11a7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a49e08ceb8cc253bd4f9448ee10a11a7b">s2n_psk_set_hmac</a> (struct s2n_psk *psk, <a class="el" href="s2n_8h.html#a85b2409fe4420987dcb5d1ed905e81fc">s2n_psk_hmac</a> hmac)</td></tr>
<tr class="separator:a49e08ceb8cc253bd4f9448ee10a11a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01514c68f7b4d7926f6435e4beec8de0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a01514c68f7b4d7926f6435e4beec8de0">s2n_connection_append_psk</a> (struct s2n_connection *conn, struct s2n_psk *psk)</td></tr>
<tr class="separator:a01514c68f7b4d7926f6435e4beec8de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201761e445dcdb7d65e0e1ebf893c7d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a201761e445dcdb7d65e0e1ebf893c7d9">s2n_config_set_psk_mode</a> (struct s2n_config *config, <a class="el" href="s2n_8h.html#a3c5d0a0d8a1092a60dd0f50cdf969524">s2n_psk_mode</a> mode)</td></tr>
<tr class="separator:a201761e445dcdb7d65e0e1ebf893c7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1777a3ba66fe8ee81f0512c961797d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#abb1777a3ba66fe8ee81f0512c961797d">s2n_connection_set_psk_mode</a> (struct s2n_connection *conn, <a class="el" href="s2n_8h.html#a3c5d0a0d8a1092a60dd0f50cdf969524">s2n_psk_mode</a> mode)</td></tr>
<tr class="separator:abb1777a3ba66fe8ee81f0512c961797d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414d9640d38a2f55cc2025d8fb6f9061"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a414d9640d38a2f55cc2025d8fb6f9061">s2n_connection_get_negotiated_psk_identity_length</a> (struct s2n_connection *conn, uint16_t *identity_length)</td></tr>
<tr class="separator:a414d9640d38a2f55cc2025d8fb6f9061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0abfdc17f22aa1a1b7bbca9fde0d5319"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a0abfdc17f22aa1a1b7bbca9fde0d5319">s2n_connection_get_negotiated_psk_identity</a> (struct s2n_connection *conn, uint8_t *identity, uint16_t max_identity_length)</td></tr>
<tr class="separator:a0abfdc17f22aa1a1b7bbca9fde0d5319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1add39d3f454da2ca54b5f13fe4d89fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> struct s2n_offered_psk *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a1add39d3f454da2ca54b5f13fe4d89fd">s2n_offered_psk_new</a> (void)</td></tr>
<tr class="separator:a1add39d3f454da2ca54b5f13fe4d89fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4dcfe9736f75c1f8fa1c75e43cb16d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a8e4dcfe9736f75c1f8fa1c75e43cb16d">s2n_offered_psk_free</a> (struct s2n_offered_psk **psk)</td></tr>
<tr class="separator:a8e4dcfe9736f75c1f8fa1c75e43cb16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc2bee93a578a8ea3d1f90ada7139ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a0fc2bee93a578a8ea3d1f90ada7139ad">s2n_offered_psk_get_identity</a> (struct s2n_offered_psk *psk, uint8_t **identity, uint16_t *size)</td></tr>
<tr class="separator:a0fc2bee93a578a8ea3d1f90ada7139ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2cd9df8a941688c493a7efbbcd5fe7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a1f2cd9df8a941688c493a7efbbcd5fe7">s2n_offered_psk_list_has_next</a> (struct s2n_offered_psk_list *psk_list)</td></tr>
<tr class="separator:a1f2cd9df8a941688c493a7efbbcd5fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1c3e31302576eda99ba71b430fb6e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a8b1c3e31302576eda99ba71b430fb6e8">s2n_offered_psk_list_next</a> (struct s2n_offered_psk_list *psk_list, struct s2n_offered_psk *psk)</td></tr>
<tr class="separator:a8b1c3e31302576eda99ba71b430fb6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37d76852ede42bb5eabada732667147"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ac37d76852ede42bb5eabada732667147">s2n_offered_psk_list_reread</a> (struct s2n_offered_psk_list *psk_list)</td></tr>
<tr class="separator:ac37d76852ede42bb5eabada732667147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b738ac812a3e48b71c0dbb5761c9c07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a5b738ac812a3e48b71c0dbb5761c9c07">s2n_offered_psk_list_choose_psk</a> (struct s2n_offered_psk_list *psk_list, struct s2n_offered_psk *psk)</td></tr>
<tr class="separator:a5b738ac812a3e48b71c0dbb5761c9c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb61d1a41a53e3de04988b5ea0109953"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#aeb61d1a41a53e3de04988b5ea0109953">s2n_config_set_psk_selection_callback</a> (struct s2n_config *config, <a class="el" href="s2n_8h.html#a37dd435b749a207739d64b22837a9ba1">s2n_psk_selection_callback</a> cb, void *context)</td></tr>
<tr class="separator:aeb61d1a41a53e3de04988b5ea0109953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3815d469b844d5eb192a04998bd12944"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a3815d469b844d5eb192a04998bd12944">s2n_connection_get_wire_bytes_in</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:a3815d469b844d5eb192a04998bd12944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134ca7e01d14f709750ef420440b238b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a134ca7e01d14f709750ef420440b238b">s2n_connection_get_wire_bytes_out</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:a134ca7e01d14f709750ef420440b238b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa9d12438841f2a47907b244eccd7cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#aafa9d12438841f2a47907b244eccd7cc">s2n_connection_get_client_protocol_version</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:aafa9d12438841f2a47907b244eccd7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db32818718bceb6f927a07cd068eb45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a7db32818718bceb6f927a07cd068eb45">s2n_connection_get_server_protocol_version</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:a7db32818718bceb6f927a07cd068eb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f52395125df9876ebf18964f582883"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a67f52395125df9876ebf18964f582883">s2n_connection_get_actual_protocol_version</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:a67f52395125df9876ebf18964f582883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a608603c7dbe9203a7c8f8b63ee1b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ad2a608603c7dbe9203a7c8f8b63ee1b8">s2n_connection_get_client_hello_version</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:ad2a608603c7dbe9203a7c8f8b63ee1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c9fa3dea9e458f259c142c01537e4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ad2c9fa3dea9e458f259c142c01537e4f">s2n_client_hello_get_legacy_record_version</a> (struct s2n_client_hello *ch, uint8_t *out)</td></tr>
<tr class="separator:ad2c9fa3dea9e458f259c142c01537e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249408b5a39897276524176bb951dba5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a249408b5a39897276524176bb951dba5">s2n_connection_client_cert_used</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:a249408b5a39897276524176bb951dba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6c509e7ec18b2a9ddb47e3e595b565"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#aed6c509e7ec18b2a9ddb47e3e595b565">s2n_connection_get_cipher</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:aed6c509e7ec18b2a9ddb47e3e595b565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762ffd38a013dba0c9266dd90b91183b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a762ffd38a013dba0c9266dd90b91183b">s2n_connection_get_certificate_match</a> (struct s2n_connection *conn, <a class="el" href="s2n_8h.html#a388f87d7049392968cf4fba3bdefa197">s2n_cert_sni_match</a> *match_status)</td></tr>
<tr class="separator:a762ffd38a013dba0c9266dd90b91183b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34a96dd1e2cae7dd2da4812576a65fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ad34a96dd1e2cae7dd2da4812576a65fc">s2n_connection_get_master_secret</a> (const struct s2n_connection *conn, uint8_t *secret_bytes, size_t max_size)</td></tr>
<tr class="separator:ad34a96dd1e2cae7dd2da4812576a65fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c865863e6dcfa38d4de30cd11f7c40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ae8c865863e6dcfa38d4de30cd11f7c40">s2n_connection_tls_exporter</a> (struct s2n_connection *conn, const uint8_t *label, uint32_t label_length, const uint8_t *context, uint32_t context_length, uint8_t *output, uint32_t output_length)</td></tr>
<tr class="separator:ae8c865863e6dcfa38d4de30cd11f7c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc11d4e901bae3b322a5a3bc5dc9a5d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#abc11d4e901bae3b322a5a3bc5dc9a5d1">s2n_connection_get_cipher_iana_value</a> (struct s2n_connection *conn, uint8_t *first, uint8_t *second)</td></tr>
<tr class="separator:abc11d4e901bae3b322a5a3bc5dc9a5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac396d45fe79efa2142be8cf491dfdbeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ac396d45fe79efa2142be8cf491dfdbeb">s2n_connection_is_valid_for_cipher_preferences</a> (struct s2n_connection *conn, const char *version)</td></tr>
<tr class="separator:ac396d45fe79efa2142be8cf491dfdbeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64cc57ff39c25444877136f6e3558c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#af64cc57ff39c25444877136f6e3558c1">s2n_connection_get_curve</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:af64cc57ff39c25444877136f6e3558c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c26b7b10e7ed39a6cd3aeaab0f4066a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a5c26b7b10e7ed39a6cd3aeaab0f4066a">s2n_connection_get_kem_name</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:a5c26b7b10e7ed39a6cd3aeaab0f4066a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c116afc860c9273c32126617881f4b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a1c116afc860c9273c32126617881f4b5">s2n_connection_get_kem_group_name</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:a1c116afc860c9273c32126617881f4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad782d2e72055ddfc4ce8768c163f4c6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ad782d2e72055ddfc4ce8768c163f4c6b">s2n_connection_get_key_exchange_group</a> (struct s2n_connection *conn, const char **group_name)</td></tr>
<tr class="separator:ad782d2e72055ddfc4ce8768c163f4c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5612a3161a2dcb4dd7fcb04aaf8845a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a5612a3161a2dcb4dd7fcb04aaf8845a8">s2n_connection_get_alert</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:a5612a3161a2dcb4dd7fcb04aaf8845a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8649c4ff89e91c0a2278c139bc033449"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a8649c4ff89e91c0a2278c139bc033449">s2n_connection_get_handshake_type_name</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:a8649c4ff89e91c0a2278c139bc033449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c50354985713f6dff1d4ae87fbc442"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#af3c50354985713f6dff1d4ae87fbc442">s2n_connection_get_last_message_name</a> (struct s2n_connection *conn)</td></tr>
<tr class="separator:af3c50354985713f6dff1d4ae87fbc442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28fc426b41fe7e3349f562bb7883448e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a28fc426b41fe7e3349f562bb7883448e">s2n_config_set_async_pkey_callback</a> (struct s2n_config *config, <a class="el" href="s2n_8h.html#a2ecb6a187e25469c3fd108a873da1cce">s2n_async_pkey_fn</a> fn)</td></tr>
<tr class="separator:a28fc426b41fe7e3349f562bb7883448e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98d7c23a90e072172d2e0e5f94b5919"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ae98d7c23a90e072172d2e0e5f94b5919">s2n_async_pkey_op_perform</a> (struct s2n_async_pkey_op *op, <a class="el" href="s2n_8h.html#a9abfa5333181eedc5c2e59bccbe60700">s2n_cert_private_key</a> *key)</td></tr>
<tr class="separator:ae98d7c23a90e072172d2e0e5f94b5919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410b7982584c24d60d25012322e38594"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a410b7982584c24d60d25012322e38594">s2n_async_pkey_op_apply</a> (struct s2n_async_pkey_op *op, struct s2n_connection *conn)</td></tr>
<tr class="separator:a410b7982584c24d60d25012322e38594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c2b74b21a46d45baa29d74cf6db401"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a95c2b74b21a46d45baa29d74cf6db401">s2n_async_pkey_op_free</a> (struct s2n_async_pkey_op *op)</td></tr>
<tr class="separator:a95c2b74b21a46d45baa29d74cf6db401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfdfd2bd7b564f720709482ac4736dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a7bfdfd2bd7b564f720709482ac4736dc">s2n_config_set_async_pkey_validation_mode</a> (struct s2n_config *config, <a class="el" href="s2n_8h.html#a3b0e141e39d6fd9782af697513933995">s2n_async_pkey_validation_mode</a> mode)</td></tr>
<tr class="separator:a7bfdfd2bd7b564f720709482ac4736dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa606bfbdb6c43d79113668999b79b8bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#aa606bfbdb6c43d79113668999b79b8bb">s2n_async_pkey_op_get_op_type</a> (struct s2n_async_pkey_op *op, <a class="el" href="s2n_8h.html#aedafc6dd8cb741ba7001beb50f3aa972">s2n_async_pkey_op_type</a> *type)</td></tr>
<tr class="separator:aa606bfbdb6c43d79113668999b79b8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4b41b09b6004bd28460f62377d400f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#adb4b41b09b6004bd28460f62377d400f">s2n_async_pkey_op_get_input_size</a> (struct s2n_async_pkey_op *op, uint32_t *data_len)</td></tr>
<tr class="separator:adb4b41b09b6004bd28460f62377d400f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03486ad1c3bd4bfbea168e696c23b880"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a03486ad1c3bd4bfbea168e696c23b880">s2n_async_pkey_op_get_input</a> (struct s2n_async_pkey_op *op, uint8_t *data, uint32_t data_len)</td></tr>
<tr class="separator:a03486ad1c3bd4bfbea168e696c23b880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769c62f99a188ed7f3a793f57d198853"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a769c62f99a188ed7f3a793f57d198853">s2n_async_pkey_op_set_output</a> (struct s2n_async_pkey_op *op, const uint8_t *data, uint32_t data_len)</td></tr>
<tr class="separator:a769c62f99a188ed7f3a793f57d198853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8f3979557fc3d58b8618230bc5c332"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a0d8f3979557fc3d58b8618230bc5c332">s2n_config_set_key_log_cb</a> (struct s2n_config *config, <a class="el" href="s2n_8h.html#a4ad3e5f171648fb7fb55109d623cb13e">s2n_key_log_fn</a> callback, void *ctx)</td></tr>
<tr class="separator:a0d8f3979557fc3d58b8618230bc5c332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fa5cce10719fe7f5730c5419f63910"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a20fa5cce10719fe7f5730c5419f63910">s2n_config_enable_cert_req_dss_legacy_compat</a> (struct s2n_config *config)</td></tr>
<tr class="separator:a20fa5cce10719fe7f5730c5419f63910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf75ca7a2f3ac18b228e8b3509c35895"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#abf75ca7a2f3ac18b228e8b3509c35895">s2n_config_set_server_max_early_data_size</a> (struct s2n_config *config, uint32_t max_early_data_size)</td></tr>
<tr class="separator:abf75ca7a2f3ac18b228e8b3509c35895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6257425f035920a67185f96a78a1c97d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a6257425f035920a67185f96a78a1c97d">s2n_connection_set_server_max_early_data_size</a> (struct s2n_connection *conn, uint32_t max_early_data_size)</td></tr>
<tr class="separator:a6257425f035920a67185f96a78a1c97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7781fbe1e216918737f9d53c4a49764f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a7781fbe1e216918737f9d53c4a49764f">s2n_connection_set_server_early_data_context</a> (struct s2n_connection *conn, const uint8_t *context, uint16_t context_size)</td></tr>
<tr class="separator:a7781fbe1e216918737f9d53c4a49764f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c25dc1760ec458de592d477ebe941a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a20c25dc1760ec458de592d477ebe941a">s2n_psk_configure_early_data</a> (struct s2n_psk *psk, uint32_t max_early_data_size, uint8_t cipher_suite_first_byte, uint8_t cipher_suite_second_byte)</td></tr>
<tr class="separator:a20c25dc1760ec458de592d477ebe941a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3999109378fb5b930b0aa201a20276f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a3999109378fb5b930b0aa201a20276f5">s2n_psk_set_application_protocol</a> (struct s2n_psk *psk, const uint8_t *application_protocol, uint8_t size)</td></tr>
<tr class="separator:a3999109378fb5b930b0aa201a20276f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a2a31ffee337b539e6a9578680d18d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a04a2a31ffee337b539e6a9578680d18d">s2n_psk_set_early_data_context</a> (struct s2n_psk *psk, const uint8_t *context, uint16_t size)</td></tr>
<tr class="separator:a04a2a31ffee337b539e6a9578680d18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb0431ad129a9c41ae80205f4020974"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#abeb0431ad129a9c41ae80205f4020974">s2n_connection_get_early_data_status</a> (struct s2n_connection *conn, <a class="el" href="s2n_8h.html#ab11b47e128bd2074bf486e1e47864033">s2n_early_data_status_t</a> *status)</td></tr>
<tr class="separator:abeb0431ad129a9c41ae80205f4020974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7efe33feb364f2215a2df1bc88fcaac1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a7efe33feb364f2215a2df1bc88fcaac1">s2n_connection_get_remaining_early_data_size</a> (struct s2n_connection *conn, uint32_t *allowed_early_data_size)</td></tr>
<tr class="separator:a7efe33feb364f2215a2df1bc88fcaac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e112c9be28b49af8d257b1c3a6a2764"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a8e112c9be28b49af8d257b1c3a6a2764">s2n_connection_get_max_early_data_size</a> (struct s2n_connection *conn, uint32_t *max_early_data_size)</td></tr>
<tr class="separator:a8e112c9be28b49af8d257b1c3a6a2764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd564dedb16a7aa99863137a36bb8e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a1dd564dedb16a7aa99863137a36bb8e8">s2n_send_early_data</a> (struct s2n_connection *conn, const uint8_t *data, ssize_t data_len, ssize_t *data_sent, <a class="el" href="s2n_8h.html#af70ca0b089daa98cd79a424d3f6af15d">s2n_blocked_status</a> *blocked)</td></tr>
<tr class="separator:a1dd564dedb16a7aa99863137a36bb8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11320d9103cdfea8b24c7e9961e1b90c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a11320d9103cdfea8b24c7e9961e1b90c">s2n_recv_early_data</a> (struct s2n_connection *conn, uint8_t *data, ssize_t max_data_len, ssize_t *data_received, <a class="el" href="s2n_8h.html#af70ca0b089daa98cd79a424d3f6af15d">s2n_blocked_status</a> *blocked)</td></tr>
<tr class="separator:a11320d9103cdfea8b24c7e9961e1b90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39414e78d4a383df083b8a6924ee495"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ac39414e78d4a383df083b8a6924ee495">s2n_config_set_early_data_cb</a> (struct s2n_config *config, <a class="el" href="s2n_8h.html#adebd93e979b53293c106cc2a44f79607">s2n_early_data_cb</a> cb)</td></tr>
<tr class="separator:ac39414e78d4a383df083b8a6924ee495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dff236f4bb72cd1acea4887d8044f82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a8dff236f4bb72cd1acea4887d8044f82">s2n_offered_early_data_get_context_length</a> (struct s2n_offered_early_data *early_data, uint16_t *context_len)</td></tr>
<tr class="separator:a8dff236f4bb72cd1acea4887d8044f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074ab5b724adcf90f98d4150c0b14342"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a074ab5b724adcf90f98d4150c0b14342">s2n_offered_early_data_get_context</a> (struct s2n_offered_early_data *early_data, uint8_t *context, uint16_t max_len)</td></tr>
<tr class="separator:a074ab5b724adcf90f98d4150c0b14342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b80aded2ad1f434662ae5b76f176f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a23b80aded2ad1f434662ae5b76f176f2">s2n_offered_early_data_reject</a> (struct s2n_offered_early_data *early_data)</td></tr>
<tr class="separator:a23b80aded2ad1f434662ae5b76f176f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675dc5ad09b3950ef36c62f4a43a7414"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a675dc5ad09b3950ef36c62f4a43a7414">s2n_offered_early_data_accept</a> (struct s2n_offered_early_data *early_data)</td></tr>
<tr class="separator:a675dc5ad09b3950ef36c62f4a43a7414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1465c4cb90a8956a26a32aa8e53808c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#ad1465c4cb90a8956a26a32aa8e53808c">s2n_config_get_supported_groups</a> (struct s2n_config *config, uint16_t *groups, uint16_t groups_count_max, uint16_t *groups_count)</td></tr>
<tr class="separator:ad1465c4cb90a8956a26a32aa8e53808c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619375c69a21184f06fb22d7810c3831"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a619375c69a21184f06fb22d7810c3831">s2n_config_set_serialization_version</a> (struct s2n_config *config, s2n_serialization_version version)</td></tr>
<tr class="separator:a619375c69a21184f06fb22d7810c3831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978a1d8977b97f7f4faae7111a0404d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a978a1d8977b97f7f4faae7111a0404d3">s2n_connection_serialization_length</a> (struct s2n_connection *conn, uint32_t *length)</td></tr>
<tr class="separator:a978a1d8977b97f7f4faae7111a0404d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d020f94e2f7324b8a5eee91287c18b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a5d020f94e2f7324b8a5eee91287c18b3">s2n_connection_serialize</a> (struct s2n_connection *conn, uint8_t *buffer, uint32_t buffer_length)</td></tr>
<tr class="separator:a5d020f94e2f7324b8a5eee91287c18b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79859a910905832157c08251d1a76888"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a79859a910905832157c08251d1a76888">s2n_connection_deserialize</a> (struct s2n_connection *conn, uint8_t *buffer, uint32_t buffer_length)</td></tr>
<tr class="separator:a79859a910905832157c08251d1a76888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a870cb61cc69457a41f2bcee5f365a5"><td class="memItemLeft" align="right" valign="top"><a id="a0a870cb61cc69457a41f2bcee5f365a5" name="a0a870cb61cc69457a41f2bcee5f365a5"></a>
<a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><b>s2n_config_set_cert_authorities_from_trust_store</b> (struct s2n_config *config)</td></tr>
<tr class="separator:a0a870cb61cc69457a41f2bcee5f365a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a24fa509b7e7b509825866d83a00333d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> __thread int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="s2n_8h.html#a24fa509b7e7b509825866d83a00333d1">s2n_errno</a></td></tr>
<tr class="separator:a24fa509b7e7b509825866d83a00333d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >s2n-tls is a C99 implementation of the TLS/SSL protocols that is designed to be simple, small, fast, and with security as a priority. <br  />
 It is released and licensed under the Apache License 2.0. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="af1c2b8586154a9094d6978137ef001ac" name="af1c2b8586154a9094d6978137ef001ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c2b8586154a9094d6978137ef001ac">&#9670;&#160;</a></span>S2N_API</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define S2N_API</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Marks a function as belonging to the public s2n API. </p>

</div>
</div>
<a id="a07b035f48c2a75cdb05df51b092b0ec4" name="a07b035f48c2a75cdb05df51b092b0ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b035f48c2a75cdb05df51b092b0ec4">&#9670;&#160;</a></span>S2N_CALLBACK_BLOCKED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define S2N_CALLBACK_BLOCKED&#160;&#160;&#160;-2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Callback return code </p>

</div>
</div>
<a id="a1d003c0083278467af77c8cd19fce680" name="a1d003c0083278467af77c8cd19fce680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d003c0083278467af77c8cd19fce680">&#9670;&#160;</a></span>S2N_FAILURE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define S2N_FAILURE&#160;&#160;&#160;-1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Function return code </p>

</div>
</div>
<a id="a5f65e736fafe94e19cddd0c7e0d8b60c" name="a5f65e736fafe94e19cddd0c7e0d8b60c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f65e736fafe94e19cddd0c7e0d8b60c">&#9670;&#160;</a></span>S2N_MAXIMUM_SUPPORTED_TLS_RECORD_MAJOR_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define S2N_MAXIMUM_SUPPORTED_TLS_RECORD_MAJOR_VERSION&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >s2n maximum supported TLS record major version </p>

</div>
</div>
<a id="ac14b875af86227115821bdbf6e2f0c44" name="ac14b875af86227115821bdbf6e2f0c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14b875af86227115821bdbf6e2f0c44">&#9670;&#160;</a></span>S2N_MINIMUM_SUPPORTED_TLS_RECORD_MAJOR_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define S2N_MINIMUM_SUPPORTED_TLS_RECORD_MAJOR_VERSION&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >s2n minimum supported TLS record major version </p>

</div>
</div>
<a id="a495735277344c9c306668f6027e3f077" name="a495735277344c9c306668f6027e3f077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495735277344c9c306668f6027e3f077">&#9670;&#160;</a></span>S2N_SSLv2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define S2N_SSLv2&#160;&#160;&#160;20</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >s2n SSL 2.0 Version Constant </p>

</div>
</div>
<a id="a457805749bd152786e9e344a5b22ab67" name="a457805749bd152786e9e344a5b22ab67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457805749bd152786e9e344a5b22ab67">&#9670;&#160;</a></span>S2N_SSLv3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define S2N_SSLv3&#160;&#160;&#160;30</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >s2n SSL 3.0 Version Constant </p>

</div>
</div>
<a id="ab6129dcaa68297738026d5c973c9aaf6" name="ab6129dcaa68297738026d5c973c9aaf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6129dcaa68297738026d5c973c9aaf6">&#9670;&#160;</a></span>S2N_SUCCESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define S2N_SUCCESS&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Function return code </p>

</div>
</div>
<a id="ab16c04a1d8479546aa124c4e52a1703f" name="ab16c04a1d8479546aa124c4e52a1703f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab16c04a1d8479546aa124c4e52a1703f">&#9670;&#160;</a></span>S2N_TLS10</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define S2N_TLS10&#160;&#160;&#160;31</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >s2n TLS 1.0 Version Constant </p>

</div>
</div>
<a id="a2e4a51448d3a9ea14b506ac2573f9bae" name="a2e4a51448d3a9ea14b506ac2573f9bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4a51448d3a9ea14b506ac2573f9bae">&#9670;&#160;</a></span>S2N_TLS11</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define S2N_TLS11&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >s2n TLS 1.1 Version Constant </p>

</div>
</div>
<a id="ab17e84046986d49ffd31571b8d32d24e" name="ab17e84046986d49ffd31571b8d32d24e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17e84046986d49ffd31571b8d32d24e">&#9670;&#160;</a></span>S2N_TLS12</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define S2N_TLS12&#160;&#160;&#160;33</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >s2n TLS 1.2 Version Constant </p>

</div>
</div>
<a id="a0529ae368bcd797cb65244b4ce05a6a6" name="a0529ae368bcd797cb65244b4ce05a6a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0529ae368bcd797cb65244b4ce05a6a6">&#9670;&#160;</a></span>S2N_TLS13</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define S2N_TLS13&#160;&#160;&#160;34</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >s2n TLS 1.3 Version Constant </p>

</div>
</div>
<a id="afda361f68c34e244d0b0c97297fa096f" name="afda361f68c34e244d0b0c97297fa096f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda361f68c34e244d0b0c97297fa096f">&#9670;&#160;</a></span>S2N_UNKNOWN_PROTOCOL_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define S2N_UNKNOWN_PROTOCOL_VERSION&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >s2n Unknown TLS Version </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a2ecb6a187e25469c3fd108a873da1cce" name="a2ecb6a187e25469c3fd108a873da1cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ecb6a187e25469c3fd108a873da1cce">&#9670;&#160;</a></span>s2n_async_pkey_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* s2n_async_pkey_fn) (struct s2n_connection *conn, struct s2n_async_pkey_op *op)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Callback function for handling private key operations</p>
<p >Invoked every time an operation requiring the private key is encountered during the handshake.</p>
<h1><a class="anchor" id="autotoc_md11"></a>
Safety</h1>
<ul>
<li><code>op</code> is owned by the application and MUST be freed.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Connection which triggered the callback </td></tr>
    <tr><td class="paramname">op</td><td>An opaque object representing the private key operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbf7cc68d71dd8d960ff078b3a21792f" name="acbf7cc68d71dd8d960ff078b3a21792f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf7cc68d71dd8d960ff078b3a21792f">&#9670;&#160;</a></span>s2n_cache_delete_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* s2n_cache_delete_callback) (struct s2n_connection *conn, void *, const void *key, uint64_t key_size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Cache callback function that allows the caller to set a callback function that will be used to delete SSL session data from a cache.</p>
<p >The callback function takes four arguments: a pointer to s2n_connection object, a pointer to arbitrary data for use within the callback, a pointer to a key which can be used to delete the cached entry, and a 64 bit unsigned integer specifying the size of this key. </p>

</div>
</div>
<a id="a57b0785656f577b764e1c3c3844368d4" name="a57b0785656f577b764e1c3c3844368d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b0785656f577b764e1c3c3844368d4">&#9670;&#160;</a></span>s2n_cache_retrieve_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* s2n_cache_retrieve_callback) (struct s2n_connection *conn, void *, const void *key, uint64_t key_size, void *value, uint64_t *value_size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Cache callback function that allows the caller to retrieve SSL session data from a cache.</p>
<p >The callback function takes six arguments: a pointer to the s2n_connection object, a pointer to arbitrary data for use within the callback, a pointer to a key which can be used to retrieve the cached entry, a 64 bit unsigned integer specifying the size of this key, a pointer to a memory location where the value should be stored, and a pointer to a 64 bit unsigned integer specifying the size of this value.</p>
<p >Initially *value_size will be set to the amount of space allocated for the value, the callback should set *value_size to the actual size of the data returned. If there is insufficient space, -1 should be returned. If the cache is not ready to provide data for the request, S2N_CALLBACK_BLOCKED should be returned.</p>
<p >This will cause <a class="el" href="s2n_8h.html#ad3222e7aacf35a56be842678171be440">s2n_negotiate()</a> to return S2N_BLOCKED_ON_APPLICATION_INPUT. </p>

</div>
</div>
<a id="ad9764b7cab647999aad58c339a42e90e" name="ad9764b7cab647999aad58c339a42e90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9764b7cab647999aad58c339a42e90e">&#9670;&#160;</a></span>s2n_cache_store_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* s2n_cache_store_callback) (struct s2n_connection *conn, void *, uint64_t ttl_in_seconds, const void *key, uint64_t key_size, const void *value, uint64_t value_size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Cache callback function that allows the caller to store SSL session data in a cache.</p>
<p >The callback function takes seven arguments: a pointer to the s2n_connection object, a pointer to arbitrary data for use within the callback, a 64-bit unsigned integer specifying the number of seconds the session data may be stored for, a pointer to a key which can be used to retrieve the cached entry, a 64 bit unsigned integer specifying the size of this key, a pointer to a value which should be stored, and a 64 bit unsigned integer specified the size of this value. </p>

</div>
</div>
<a id="a9abfa5333181eedc5c2e59bccbe60700" name="a9abfa5333181eedc5c2e59bccbe60700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abfa5333181eedc5c2e59bccbe60700">&#9670;&#160;</a></span>s2n_cert_private_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct s2n_pkey <a class="el" href="s2n_8h.html#a9abfa5333181eedc5c2e59bccbe60700">s2n_cert_private_key</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Opaque private key type. </p>

</div>
</div>
<a id="a69c668f3559688152919b062f260f7c3" name="a69c668f3559688152919b062f260f7c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c668f3559688152919b062f260f7c3">&#9670;&#160;</a></span>s2n_cert_public_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct s2n_pkey <a class="el" href="s2n_8h.html#a69c668f3559688152919b062f260f7c3">s2n_cert_public_key</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Opaque public key type. </p>

</div>
</div>
<a id="a0363fdf570a5451facfa12eb0a679586" name="a0363fdf570a5451facfa12eb0a679586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0363fdf570a5451facfa12eb0a679586">&#9670;&#160;</a></span>s2n_cert_tiebreak_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct s2n_cert_chain_and_key *(* s2n_cert_tiebreak_callback) (struct s2n_cert_chain_and_key *cert1, struct s2n_cert_chain_and_key *cert2, uint8_t *name, uint32_t name_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A callback function that is invoked if s2n-tls cannot resolve a conflict between two certificates with the same domain name. This function is invoked while certificates are added to an <code>s2n_config</code>.</p>
<p >Currently, the only builtin resolution for domain name conflicts is certificate type(RSA, 
ECDSA, etc). The callback should return a pointer to the <code>s2n_cert_chain_and_key</code> that should be used for dns name <code>name</code>.</p>
<p >If NULL is returned, the first certificate will be used. Typically an application will use properties like trust and expiry to implement tiebreaking. </p>

</div>
</div>
<a id="a0451dcbf88fdf09f36a82cab4d25d44e" name="a0451dcbf88fdf09f36a82cab4d25d44e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0451dcbf88fdf09f36a82cab4d25d44e">&#9670;&#160;</a></span>s2n_client_hello_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int s2n_client_hello_fn(struct s2n_connection *conn, void *ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The callback function takes a s2n-tls connection as input, which receives the ClientHello and the context previously provided in <code>s2n_config_set_client_hello_cb</code>. The callback can access any ClientHello information from the connection and use the <code>s2n_connection_set_config</code> call to change the config of the connection. </p>

</div>
</div>
<a id="a0cfed8d65c0e2c33cf666ee90eb06a7e" name="a0cfed8d65c0e2c33cf666ee90eb06a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cfed8d65c0e2c33cf666ee90eb06a7e">&#9670;&#160;</a></span>s2n_clock_time_nanoseconds</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* s2n_clock_time_nanoseconds) (void *, uint64_t *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Callback function type used to get the system time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">void*</td><td>A pointer to arbitrary data for use within the callback </td></tr>
    <tr><td class="paramname">uint64_t*</td><td>A pointer that the callback will set to the time in nanoseconds The function should return 0 on success and -1 on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adebd93e979b53293c106cc2a44f79607" name="adebd93e979b53293c106cc2a44f79607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adebd93e979b53293c106cc2a44f79607">&#9670;&#160;</a></span>s2n_early_data_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* s2n_early_data_cb) (struct s2n_connection *conn, struct s2n_offered_early_data *early_data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A callback which can be implemented to accept or reject early data.</p>
<p >This callback is triggered only after the server has determined early data is otherwise acceptable according to the TLS early data specification. Implementations therefore only need to cover application-specific checks, not the standard TLS early data validation.</p>
<p >This callback can be synchronous or asynchronous. For asynchronous behavior, return success without calling <code>s2n_offered_early_data_reject</code> or <code>s2n_offered_early_data_accept</code>. <code>early_data</code> will still be a valid reference, and the connection will block until <code>s2n_offered_early_data_reject</code> or <code>s2n_offered_early_data_accept</code> is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the connection </td></tr>
    <tr><td class="paramname">early_data</td><td>A pointer which can be used to access information about the proposed early data and then accept or reject it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A POSIX error signal. If unsuccessful, the connection will be closed with an error. </dd></dl>

</div>
</div>
<a id="a4ad3e5f171648fb7fb55109d623cb13e" name="a4ad3e5f171648fb7fb55109d623cb13e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad3e5f171648fb7fb55109d623cb13e">&#9670;&#160;</a></span>s2n_key_log_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* s2n_key_log_fn) (void *ctx, struct s2n_connection *conn, uint8_t *logline, size_t len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Callback function for handling key log events</p>
<p >THIS SHOULD BE USED FOR DEBUGGING PURPOSES ONLY!</p>
<p >Each log line is formatted with the <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format">NSS Key Log Format</a> without a newline.</p>
<h1><a class="anchor" id="autotoc_md17"></a>
Safety</h1>
<ul>
<li><code>ctx</code> MUST be cast into the same type of pointer that was originally created</li>
<li><code>logline</code> bytes MUST be copied or discarded before this function returns</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Context for the callback </td></tr>
    <tr><td class="paramname">conn</td><td>Connection for which the log line is being emitted </td></tr>
    <tr><td class="paramname">logline</td><td>Pointer to the log line data </td></tr>
    <tr><td class="paramname">len</td><td>Length of the log line data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5f75394a380a2764b189ca6662133ba" name="ae5f75394a380a2764b189ca6662133ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f75394a380a2764b189ca6662133ba">&#9670;&#160;</a></span>s2n_mem_cleanup_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* s2n_mem_cleanup_callback) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Will be called when <code>s2n_cleanup</code> is executed. </p>

</div>
</div>
<a id="a6e4014627f6981bc4e533781d29903d5" name="a6e4014627f6981bc4e533781d29903d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4014627f6981bc4e533781d29903d5">&#9670;&#160;</a></span>s2n_mem_free_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* s2n_mem_free_callback) (void *ptr, uint32_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Frees memory allocated by s2n_mem_malloc_callback. </p>

</div>
</div>
<a id="a71033bff0e129f910b87d5fb41798519" name="a71033bff0e129f910b87d5fb41798519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71033bff0e129f910b87d5fb41798519">&#9670;&#160;</a></span>s2n_mem_init_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* s2n_mem_init_callback) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Called when <code>s2n_init</code> is executed. </p>

</div>
</div>
<a id="a8ea7d341ee2969dd1d083fafe13a5d43" name="a8ea7d341ee2969dd1d083fafe13a5d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea7d341ee2969dd1d083fafe13a5d43">&#9670;&#160;</a></span>s2n_mem_malloc_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* s2n_mem_malloc_callback) (void **ptr, uint32_t requested, uint32_t *allocated)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A function that can allocate at least <code>requested</code> bytes of memory.</p>
<p >It stores the location of that memory in ***ptr** and the size of the allocated data in ***allocated**. The function may choose to allocate more memory than was requested. s2n-tls will consider all allocated memory available for use, and will attempt to free all allocated memory when able. </p>

</div>
</div>
<a id="a37dd435b749a207739d64b22837a9ba1" name="a37dd435b749a207739d64b22837a9ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37dd435b749a207739d64b22837a9ba1">&#9670;&#160;</a></span>s2n_psk_selection_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* s2n_psk_selection_callback) (struct s2n_connection *conn, void *context, struct s2n_offered_psk_list *psk_list)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Callback function to select a PSK from a list of offered PSKs. Use this callback to implement custom PSK selection logic. The s2n-tls default PSK selection logic chooses the first matching PSK from the list of offered PSKs sent by the client.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Safety</h1>
<p ><code>context</code> is a void pointer and the caller is responsible for ensuring it is cast to the correct type. After the completion of this callback, the pointer to <code>psk_list</code> is invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object. </td></tr>
    <tr><td class="paramname">context</td><td>A pointer to a context for the caller to pass state to the callback, if needed. </td></tr>
    <tr><td class="paramname">psk_list</td><td>A pointer to the offered PSK list being read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a700f181dd144cbb4161765333a190d01" name="a700f181dd144cbb4161765333a190d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a700f181dd144cbb4161765333a190d01">&#9670;&#160;</a></span>s2n_rand_cleanup_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* s2n_rand_cleanup_callback) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A callback function that will be called when <code>s2n_cleanup</code> is executed. </p>

</div>
</div>
<a id="ada646d7bfa47772c96b4e4c9dca18dd1" name="ada646d7bfa47772c96b4e4c9dca18dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada646d7bfa47772c96b4e4c9dca18dd1">&#9670;&#160;</a></span>s2n_rand_init_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* s2n_rand_init_callback) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A callback function that will be called when s2n-tls is initialized. </p>

</div>
</div>
<a id="a4b6891b58a1c9a957d299177497e7896" name="a4b6891b58a1c9a957d299177497e7896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6891b58a1c9a957d299177497e7896">&#9670;&#160;</a></span>s2n_rand_mix_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* s2n_rand_mix_callback) (void *data, uint32_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A callback function that will be used to mix in entropy every time the RNG is invoked. </p>

</div>
</div>
<a id="ae7cf68edcc9173e3ac5383d1fb879d31" name="ae7cf68edcc9173e3ac5383d1fb879d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7cf68edcc9173e3ac5383d1fb879d31">&#9670;&#160;</a></span>s2n_rand_seed_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* s2n_rand_seed_callback) (void *data, uint32_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A callback function that will be used to provide entropy to the s2n-tls random number generators. </p>

</div>
</div>
<a id="a0b5d6b77e35bf16aee077fe1c5860cc9" name="a0b5d6b77e35bf16aee077fe1c5860cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b5d6b77e35bf16aee077fe1c5860cc9">&#9670;&#160;</a></span>s2n_recv_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int s2n_recv_fn(void *io_context, uint8_t *buf, uint32_t len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Function pointer for a user provided recv callback. </p>

</div>
</div>
<a id="ad8ae4eeefcfc81bc4daf429512612687" name="ad8ae4eeefcfc81bc4daf429512612687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ae4eeefcfc81bc4daf429512612687">&#9670;&#160;</a></span>s2n_send_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int s2n_send_fn(void *io_context, const uint8_t *buf, uint32_t len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Function pointer for a user provided send callback. </p>

</div>
</div>
<a id="a87a1b430e8782d95dc60efbec7cd6118" name="a87a1b430e8782d95dc60efbec7cd6118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a1b430e8782d95dc60efbec7cd6118">&#9670;&#160;</a></span>s2n_session_ticket_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* s2n_session_ticket_fn) (struct s2n_connection *conn, void *ctx, struct s2n_session_ticket *ticket)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Callback function for receiving a session ticket.</p>
<p >This function will be called each time a session ticket is received, which may be multiple times for TLS1.3.</p>
<h1><a class="anchor" id="autotoc_md0"></a>
Safety</h1>
<p ><code>ctx</code> is a void pointer and the caller is responsible for ensuring it is cast to the correct type. <code>ticket</code> is valid only within the scope of this callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the connection object. </td></tr>
    <tr><td class="paramname">ctx</td><td>Context for the session ticket callback function. </td></tr>
    <tr><td class="paramname">ticket</td><td>Pointer to the received session ticket object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8aa56850695a02753f726ea9860ec383" name="a8aa56850695a02753f726ea9860ec383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa56850695a02753f726ea9860ec383">&#9670;&#160;</a></span>s2n_verify_host_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint8_t(* s2n_verify_host_fn) (const char *host_name, size_t host_name_len, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A callback function invoked (usually multiple times) during X.509 validation for each name encountered in the leaf certificate.</p>
<p >Return 1 to trust that hostname or 0 to not trust the hostname.</p>
<p >If this function returns 1, then the certificate is considered trusted and that portion of the X.509 validation will succeed.</p>
<p >If no hostname results in a 1 being returned, the certificate will be untrusted and the validation will terminate immediately.</p>
<p >Data is a opaque user context set in <a class="el" href="s2n_8h.html#a079022d5c18f4ffd64c1c6dedb3bbc66">s2n_config_set_verify_host_callback()</a> or <a class="el" href="s2n_8h.html#ad39f5c65f5c201d7af140baff29a02eb">s2n_connection_set_verify_host_callback()</a>. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ab8d3f62254ec4211d47cc841dea76abd" name="ab8d3f62254ec4211d47cc841dea76abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d3f62254ec4211d47cc841dea76abd">&#9670;&#160;</a></span>s2n_alert_behavior</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="s2n_8h.html#ab8d3f62254ec4211d47cc841dea76abd">s2n_alert_behavior</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets whether or not a connection should terminate on receiving a WARNING alert from its peer.</p>
<p ><code>alert_behavior</code> can take the following values:</p><ul>
<li><code>S2N_ALERT_FAIL_ON_WARNINGS</code> default behavior: s2n-tls will terminate the connection if its peer sends a WARNING alert.</li>
<li><code>S2N_ALERT_IGNORE_WARNINGS</code> - with the exception of <code>close_notify</code> s2n-tls will ignore all WARNING alerts and keep communicating with its peer. This setting is ignored in TLS1.3</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>TLS1.3 terminates a connection for all alerts except user_canceled. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>S2N_ALERT_FAIL_ON_WARNINGS is the recommended behavior. Past TLS protocol vulnerabilities have involved downgrading alerts to warnings. </dd></dl>

</div>
</div>
<a id="aedafc6dd8cb741ba7001beb50f3aa972" name="aedafc6dd8cb741ba7001beb50f3aa972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedafc6dd8cb741ba7001beb50f3aa972">&#9670;&#160;</a></span>s2n_async_pkey_op_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="s2n_8h.html#aedafc6dd8cb741ba7001beb50f3aa972">s2n_async_pkey_op_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The type of private key operation </p>

</div>
</div>
<a id="a3b0e141e39d6fd9782af697513933995" name="a3b0e141e39d6fd9782af697513933995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0e141e39d6fd9782af697513933995">&#9670;&#160;</a></span>s2n_async_pkey_validation_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="s2n_8h.html#a3b0e141e39d6fd9782af697513933995">s2n_async_pkey_validation_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets whether or not a connection should enforce strict signature validation during the <code>s2n_async_pkey_op_apply</code> call.</p>
<p ><code>mode</code> can take the following values:</p><ul>
<li><code>S2N_ASYNC_PKEY_VALIDATION_FAST</code> - default behavior: s2n-tls will perform only the minimum validation required for safe use of the asyn pkey operation.</li>
<li><code>S2N_ASYNC_PKEY_VALIDATION_STRICT</code> - in addition to the previous checks, s2n-tls will also ensure that the signature created as a result of the async private key sign operation matches the public key on the connection. </li>
</ul>

</div>
</div>
<a id="a364ad496c9dd42fd3117a2f9d3289e62" name="a364ad496c9dd42fd3117a2f9d3289e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a364ad496c9dd42fd3117a2f9d3289e62">&#9670;&#160;</a></span>s2n_blinding</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="s2n_8h.html#a364ad496c9dd42fd3117a2f9d3289e62">s2n_blinding</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Used to opt-out of s2n-tls's built-in blinding. Blinding is a mitigation against timing side-channels which in some cases can leak information about encrypted data. By default s2n-tls will cause a thread to sleep between 10 and 30 seconds whenever tampering is detected.</p>
<p >Setting the S2N_SELF_SERVICE_BLINDING option with <a class="el" href="s2n_8h.html#a684b2e5c86c85f089392bd1a49d38e17">s2n_connection_set_blinding()</a> turns off this behavior. This is useful for applications that are handling many connections in a single thread. In that case, if <a class="el" href="s2n_8h.html#a3b67ff058796d4c6c6caddfd0f10274e">s2n_recv()</a> or <a class="el" href="s2n_8h.html#ad3222e7aacf35a56be842678171be440">s2n_negotiate()</a> return an error, self-service applications should call <a class="el" href="s2n_8h.html#ab8a2a372d2d13cef62357473b7fea568">s2n_connection_get_delay()</a> and pause activity on the connection for the specified number of nanoseconds before calling close() or shutdown(). </p>

</div>
</div>
<a id="af70ca0b089daa98cd79a424d3f6af15d" name="af70ca0b089daa98cd79a424d3f6af15d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70ca0b089daa98cd79a424d3f6af15d">&#9670;&#160;</a></span>s2n_blocked_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="s2n_8h.html#af70ca0b089daa98cd79a424d3f6af15d">s2n_blocked_status</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Used in non-blocking mode to indicate in which direction s2n-tls became blocked on I/O before it returned control to the caller. This allows an application to avoid retrying s2n-tls operations until I/O is possible in that direction. </p>

</div>
</div>
<a id="a8757c094681bb8151329c8dc067106b8" name="a8757c094681bb8151329c8dc067106b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8757c094681bb8151329c8dc067106b8">&#9670;&#160;</a></span>s2n_cert_auth_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="s2n_8h.html#a8757c094681bb8151329c8dc067106b8">s2n_cert_auth_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Used to declare what type of client certificate authentication to use.</p>
<p >A s2n_connection will enforce client certificate authentication (mTLS) differently based on the <code>s2n_cert_auth_type</code> and <code>s2n_mode</code> (client/server) of the connection, as described below.</p>
<p >Server behavior:</p><ul>
<li>None (default): Will not request client authentication.</li>
<li>Optional: Request the client's certificate and validate it. If no certificate is received then no validation is performed.</li>
<li>Required: Request the client's certificate and validate it. Abort the handshake if a client certificate is not received.</li>
</ul>
<p >Client behavior:</p><ul>
<li>None: Abort the handshake if the server requests client authentication.</li>
<li>Optional (default): Sends the client certificate if the server requests client authentication. No certificate is sent if the application hasn't provided a certificate.</li>
<li>Required: Send the client certificate. Abort the handshake if the server doesn't request client authentication or if the application hasn't provided a certificate. </li>
</ul>

</div>
</div>
<a id="a388f87d7049392968cf4fba3bdefa197" name="a388f87d7049392968cf4fba3bdefa197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388f87d7049392968cf4fba3bdefa197">&#9670;&#160;</a></span>s2n_cert_sni_match</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="s2n_8h.html#a388f87d7049392968cf4fba3bdefa197">s2n_cert_sni_match</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A metric to determine whether or not the server found a certificate that matched the client's SNI extension.</p>
<p >S2N_SNI_NONE: Client did not send the SNI extension. S2N_SNI_EXACT_MATCH: Server had a certificate that matched the client's SNI extension. S2N_SNI_WILDCARD_MATCH: Server had a certificate with a domain name containing a wildcard character that could be matched to the client's SNI extension. S2N_SNI_NO_MATCH: Server did not have a certificate that could be matched to the client's SNI extension. </p>

</div>
</div>
<a id="a7aa9070e5b2de634b4a6fcb2bde98e68" name="a7aa9070e5b2de634b4a6fcb2bde98e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa9070e5b2de634b4a6fcb2bde98e68">&#9670;&#160;</a></span>s2n_client_hello_cb_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="s2n_8h.html#a7aa9070e5b2de634b4a6fcb2bde98e68">s2n_client_hello_cb_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Client Hello callback modes</p><ul>
<li><code>S2N_CLIENT_HELLO_CB_BLOCKING</code> (default):<ul>
<li>In this mode s2n-tls expects the callback to complete its work and return the appropriate response code before the handshake continues. If any of the connection properties were changed based on the server_name extension the callback must either return a value greater than 0 or invoke <code>s2n_connection_server_name_extension_used</code>, otherwise the callback returns 0 to continue the handshake.</li>
</ul>
</li>
<li><code>S2N_CLIENT_HELLO_CB_NONBLOCKING</code>:<ul>
<li>In non-blocking mode, s2n-tls expects the callback to not complete its work. If the callback returns a response code of 0, s2n-tls will return <code>S2N_FAILURE</code> with <code>S2N_ERR_T_BLOCKED</code> error type and <code>s2n_blocked_status</code> set to <code>S2N_BLOCKED_ON_APPLICATION_INPUT</code>. The handshake is paused and further calls to <code>s2n_negotiate</code> will continue to return the same error until <code>s2n_client_hello_cb_done</code> is invoked for the <code>s2n_connection</code> to resume the handshake. If any of the connection properties were changed on the basis of the server_name extension then <code>s2n_connection_server_name_extension_used</code> must be invoked before marking the callback done. </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="ae8f37b612310a3594b019b88ebd8fa1a" name="ae8f37b612310a3594b019b88ebd8fa1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f37b612310a3594b019b88ebd8fa1a">&#9670;&#160;</a></span>s2n_ct_support_level</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="s2n_8h.html#ae8f37b612310a3594b019b88ebd8fa1a">s2n_ct_support_level</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Enum to set Certificate Transparency Support level. </p>

</div>
</div>
<a id="ab11b47e128bd2074bf486e1e47864033" name="ab11b47e128bd2074bf486e1e47864033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab11b47e128bd2074bf486e1e47864033">&#9670;&#160;</a></span>s2n_early_data_status_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="s2n_8h.html#ab11b47e128bd2074bf486e1e47864033">s2n_early_data_status_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The status of early data on a connection.</p>
<p >S2N_EARLY_DATA_STATUS_OK: Early data is in progress. S2N_EARLY_DATA_STATUS_NOT_REQUESTED: The client did not request early data, so none was sent or received. S2N_EARLY_DATA_STATUS_REJECTED: The client requested early data, but the server rejected the request. Early data may have been sent, but was not received. S2N_EARLY_DATA_STATUS_END: All early data was successfully sent and received. </p>

</div>
</div>
<a id="a41f8ab66d28ce2f33fa8dbf858c0ac44" name="a41f8ab66d28ce2f33fa8dbf858c0ac44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f8ab66d28ce2f33fa8dbf858c0ac44">&#9670;&#160;</a></span>s2n_error_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="s2n_8h.html#a41f8ab66d28ce2f33fa8dbf858c0ac44">s2n_error_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Used to help applications determine why an s2n-tls function failed.</p>
<p >This enum is optimized for use in C switch statements. Each value in the enum represents an error "category".</p>
<p >s2n-tls organizes errors into different "types" to allow applications to handle error values without catching all possibilities. Applications using non-blocking I/O should check the error type to determine if the I/O operation failed because it would block or for some other error. To retrieve the type for a given error use <code><a class="el" href="s2n_8h.html#aebff13e0704f879abbb6a3a7cbbe62c2">s2n_error_get_type()</a></code>. Applications should perform any error handling logic using these high level types.</p>
<p >See the <a href="https://github.com/aws/s2n-tls/blob/main/docs/usage-guide/topics/ch03-error-handling.md">Error Handling</a> section for how the errors should be interpreted. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a41f8ab66d28ce2f33fa8dbf858c0ac44a09221eeb73c34d50145b9c7c0eb21f25" name="a41f8ab66d28ce2f33fa8dbf858c0ac44a09221eeb73c34d50145b9c7c0eb21f25"></a>S2N_ERR_T_OK&#160;</td><td class="fielddoc"><p >No error </p>
</td></tr>
<tr><td class="fieldname"><a id="a41f8ab66d28ce2f33fa8dbf858c0ac44a37308c203b80ac55ca9fe47af71a4461" name="a41f8ab66d28ce2f33fa8dbf858c0ac44a37308c203b80ac55ca9fe47af71a4461"></a>S2N_ERR_T_IO&#160;</td><td class="fielddoc"><p >Underlying I/O operation failed, check system errno </p>
</td></tr>
<tr><td class="fieldname"><a id="a41f8ab66d28ce2f33fa8dbf858c0ac44a0cbe0424403a2678cf7ece737b2203e1" name="a41f8ab66d28ce2f33fa8dbf858c0ac44a0cbe0424403a2678cf7ece737b2203e1"></a>S2N_ERR_T_CLOSED&#160;</td><td class="fielddoc"><p >EOF </p>
</td></tr>
<tr><td class="fieldname"><a id="a41f8ab66d28ce2f33fa8dbf858c0ac44a5bcbdbf63fe745654c4ae0fb8d28bbd2" name="a41f8ab66d28ce2f33fa8dbf858c0ac44a5bcbdbf63fe745654c4ae0fb8d28bbd2"></a>S2N_ERR_T_BLOCKED&#160;</td><td class="fielddoc"><p >Underlying I/O operation would block </p>
</td></tr>
<tr><td class="fieldname"><a id="a41f8ab66d28ce2f33fa8dbf858c0ac44a12d57bda93bac5e14ae6d7c78717e122" name="a41f8ab66d28ce2f33fa8dbf858c0ac44a12d57bda93bac5e14ae6d7c78717e122"></a>S2N_ERR_T_ALERT&#160;</td><td class="fielddoc"><p >Incoming Alert </p>
</td></tr>
<tr><td class="fieldname"><a id="a41f8ab66d28ce2f33fa8dbf858c0ac44af7032a0138492c552fc04b9198259cd7" name="a41f8ab66d28ce2f33fa8dbf858c0ac44af7032a0138492c552fc04b9198259cd7"></a>S2N_ERR_T_PROTO&#160;</td><td class="fielddoc"><p >Failure in some part of the TLS protocol. Ex: CBC verification failure </p>
</td></tr>
<tr><td class="fieldname"><a id="a41f8ab66d28ce2f33fa8dbf858c0ac44a2c6b4ff243a28b86ef701206023339ca" name="a41f8ab66d28ce2f33fa8dbf858c0ac44a2c6b4ff243a28b86ef701206023339ca"></a>S2N_ERR_T_INTERNAL&#160;</td><td class="fielddoc"><p >Error internal to s2n-tls. A precondition could have failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a41f8ab66d28ce2f33fa8dbf858c0ac44a0d2eba6e7ff752e54c0aa004fd53f176" name="a41f8ab66d28ce2f33fa8dbf858c0ac44a0d2eba6e7ff752e54c0aa004fd53f176"></a>S2N_ERR_T_USAGE&#160;</td><td class="fielddoc"><p >User input error. Ex: Providing an invalid cipher preference version </p>
</td></tr>
</table>

</div>
</div>
<a id="a1976b2365808c341247e03131c2423ac" name="a1976b2365808c341247e03131c2423ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1976b2365808c341247e03131c2423ac">&#9670;&#160;</a></span>s2n_max_frag_len</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="s2n_8h.html#a1976b2365808c341247e03131c2423ac">s2n_max_frag_len</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >MFL configurations from <a href="https://datatracker.ietf.org/doc/html/rfc6066#section-4">https://datatracker.ietf.org/doc/html/rfc6066#section-4</a>. </p>

</div>
</div>
<a id="a77a64e3b657f90d221c5faf99c643cdb" name="a77a64e3b657f90d221c5faf99c643cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a64e3b657f90d221c5faf99c643cdb">&#9670;&#160;</a></span>s2n_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="s2n_8h.html#a77a64e3b657f90d221c5faf99c643cdb">s2n_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Used to declare connections as server or client type, respectively. </p>

</div>
</div>
<a id="aa8ab6cd4a526f781116a39bd16bab9ba" name="aa8ab6cd4a526f781116a39bd16bab9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ab6cd4a526f781116a39bd16bab9ba">&#9670;&#160;</a></span>s2n_peer_key_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="s2n_8h.html#aa8ab6cd4a526f781116a39bd16bab9ba">s2n_peer_key_update</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Used to indicate the type of key update that is being requested. For further information refer to <code>s2n_connection_request_key_update</code>. </p>

</div>
</div>
<a id="a85b2409fe4420987dcb5d1ed905e81fc" name="a85b2409fe4420987dcb5d1ed905e81fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b2409fe4420987dcb5d1ed905e81fc">&#9670;&#160;</a></span>s2n_psk_hmac</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="s2n_8h.html#a85b2409fe4420987dcb5d1ed905e81fc">s2n_psk_hmac</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Pre-shared key (PSK) Hash Algorithm - RFC 8446 Section-2.2 </p>

</div>
</div>
<a id="a3c5d0a0d8a1092a60dd0f50cdf969524" name="a3c5d0a0d8a1092a60dd0f50cdf969524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5d0a0d8a1092a60dd0f50cdf969524">&#9670;&#160;</a></span>s2n_psk_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="s2n_8h.html#a3c5d0a0d8a1092a60dd0f50cdf969524">s2n_psk_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The list of PSK modes supported by s2n-tls for TLS versions &gt;= TLS1.3. Currently s2n-tls supports two modes - <code>S2N_PSK_MODE_RESUMPTION</code>, which represents the PSKs established using the previous connection via session resumption, and <code>S2N_PSK_MODE_EXTERNAL</code>, which represents PSKs established out-of-band/externally using a secure mutually agreed upon mechanism. </p>

</div>
</div>
<a id="a7d38e45340d223d0100a2d4bc0526635" name="a7d38e45340d223d0100a2d4bc0526635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d38e45340d223d0100a2d4bc0526635">&#9670;&#160;</a></span>s2n_status_request_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="s2n_8h.html#a7d38e45340d223d0100a2d4bc0526635">s2n_status_request_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Enum used to define the type, if any, of certificate status request a connection should make during the handshake. The only supported status request type is OCSP, <code>S2N_STATUS_REQUEST_OCSP</code>. </p>

</div>
</div>
<a id="ab2b46f61765da5529f931afb8dd8a1f8" name="ab2b46f61765da5529f931afb8dd8a1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b46f61765da5529f931afb8dd8a1f8">&#9670;&#160;</a></span>s2n_tls_extension_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="s2n_8h.html#ab2b46f61765da5529f931afb8dd8a1f8">s2n_tls_extension_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >TLS extensions supported by s2n-tls </p>

</div>
</div>
<a id="a08eccb21b18130aef8c19a288801f379" name="a08eccb21b18130aef8c19a288801f379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08eccb21b18130aef8c19a288801f379">&#9670;&#160;</a></span>s2n_tls_hash_algorithm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="s2n_8h.html#a08eccb21b18130aef8c19a288801f379">s2n_tls_hash_algorithm</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >TLS Hash Algorithms - <a href="https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1">https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1</a> <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-18">https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-18</a> </p>

</div>
</div>
<a id="a9812997751f63ac2d5ab70852792a689" name="a9812997751f63ac2d5ab70852792a689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9812997751f63ac2d5ab70852792a689">&#9670;&#160;</a></span>s2n_tls_signature_algorithm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="s2n_8h.html#a9812997751f63ac2d5ab70852792a689">s2n_tls_signature_algorithm</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >TLS Signature Algorithms - RFC 5246 7.4.1.4.1 <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-16">https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-16</a> </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a410b7982584c24d60d25012322e38594" name="a410b7982584c24d60d25012322e38594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410b7982584c24d60d25012322e38594">&#9670;&#160;</a></span>s2n_async_pkey_op_apply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_async_pkey_op_apply </td>
          <td>(</td>
          <td class="paramtype">struct s2n_async_pkey_op *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Finalizes a private key operation and unblocks the connection.</p>
<h1><a class="anchor" id="autotoc_md13"></a>
Safety</h1>
<ul>
<li><code>conn</code> must match the connection that originally triggered the callback.</li>
<li>Must be called after the operation is performed.</li>
<li>Can only be called once. Any subsequent calls will produce a <code>S2N_ERR_T_USAGE</code> error.</li>
<li>Safe to call from inside s2n_async_pkey_fn</li>
<li>Safe to call from a different thread, as long as no other thread is operating on <code>op</code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>An opaque object representing the private key operation </td></tr>
    <tr><td class="paramname">conn</td><td>The connection associated with the operation that should be unblocked </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95c2b74b21a46d45baa29d74cf6db401" name="a95c2b74b21a46d45baa29d74cf6db401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95c2b74b21a46d45baa29d74cf6db401">&#9670;&#160;</a></span>s2n_async_pkey_op_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_async_pkey_op_free </td>
          <td>(</td>
          <td class="paramtype">struct s2n_async_pkey_op *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Frees the opaque structure representing a private key operation.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
Safety</h1>
<ul>
<li>MUST be called for every operation passed to s2n_async_pkey_fn</li>
<li>Safe to call before or after the connection that created the operation is freed</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>An opaque object representing the private key operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03486ad1c3bd4bfbea168e696c23b880" name="a03486ad1c3bd4bfbea168e696c23b880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03486ad1c3bd4bfbea168e696c23b880">&#9670;&#160;</a></span>s2n_async_pkey_op_get_input()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_async_pkey_op_get_input </td>
          <td>(</td>
          <td class="paramtype">struct s2n_async_pkey_op *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the input to the private key operation.</p>
<p >When signing, the input is the digest to sign. When decrypting, the input is the data to decrypt.</p>
<p >When signing with ML-DSA, the input is the "external mu" pre-hash value described in <a href="https://www.ietf.org/archive/id/draft-ietf-lamps-dilithium-certificates-09.html#appendix-D">https://www.ietf.org/archive/id/draft-ietf-lamps-dilithium-certificates-09.html#appendix-D</a></p>
<h1><a class="anchor" id="autotoc_md15"></a>
Safety</h1>
<ul>
<li><code>data</code> must be sufficiently large to contain the input. <code>s2n_async_pkey_op_get_input_size</code> can be called to determine how much memory is required.</li>
<li>s2n-tls does not take ownership of <code>data</code>. The application still owns the memory and must free it if necessary.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>An opaque object representing the private key operation </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to a buffer to copy the input into </td></tr>
    <tr><td class="paramname">data_len</td><td>The maximum size of the <code>data</code> buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb4b41b09b6004bd28460f62377d400f" name="adb4b41b09b6004bd28460f62377d400f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb4b41b09b6004bd28460f62377d400f">&#9670;&#160;</a></span>s2n_async_pkey_op_get_input_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_async_pkey_op_get_input_size </td>
          <td>(</td>
          <td class="paramtype">struct s2n_async_pkey_op *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the size of the input to the private key operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>An opaque object representing the private key operation </td></tr>
    <tr><td class="paramname">data_len</td><td>A pointer to be set to the size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa606bfbdb6c43d79113668999b79b8bb" name="aa606bfbdb6c43d79113668999b79b8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa606bfbdb6c43d79113668999b79b8bb">&#9670;&#160;</a></span>s2n_async_pkey_op_get_op_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_async_pkey_op_get_op_type </td>
          <td>(</td>
          <td class="paramtype">struct s2n_async_pkey_op *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#aedafc6dd8cb741ba7001beb50f3aa972">s2n_async_pkey_op_type</a> *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the type of the private key operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>An opaque object representing the private key operation </td></tr>
    <tr><td class="paramname">type</td><td>A pointer to be set to the type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae98d7c23a90e072172d2e0e5f94b5919" name="ae98d7c23a90e072172d2e0e5f94b5919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae98d7c23a90e072172d2e0e5f94b5919">&#9670;&#160;</a></span>s2n_async_pkey_op_perform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_async_pkey_op_perform </td>
          <td>(</td>
          <td class="paramtype">struct s2n_async_pkey_op *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a9abfa5333181eedc5c2e59bccbe60700">s2n_cert_private_key</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Performs a private key operation using the given private key.</p>
<h1><a class="anchor" id="autotoc_md12"></a>
Safety</h1>
<ul>
<li>Can only be called once. Any subsequent calls will produce a <code>S2N_ERR_T_USAGE</code> error.</li>
<li>Safe to call from inside s2n_async_pkey_fn</li>
<li>Safe to call from a different thread, as long as no other thread is operating on <code>op</code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>An opaque object representing the private key operation </td></tr>
    <tr><td class="paramname">key</td><td>The private key used for the operation. It can be extracted from <code>conn</code> through the <code>s2n_connection_get_selected_cert</code> and <code>s2n_cert_chain_and_key_get_private_key</code> calls </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a769c62f99a188ed7f3a793f57d198853" name="a769c62f99a188ed7f3a793f57d198853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a769c62f99a188ed7f3a793f57d198853">&#9670;&#160;</a></span>s2n_async_pkey_op_set_output()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_async_pkey_op_set_output </td>
          <td>(</td>
          <td class="paramtype">struct s2n_async_pkey_op *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the output of the private key operation.</p>
<h1><a class="anchor" id="autotoc_md16"></a>
Safety</h1>
<ul>
<li>s2n-tls does not take ownership of <code>data</code>. The application still owns the memory and must free it if necessary.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>An opaque object representing the private key operation </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to a buffer containing the output </td></tr>
    <tr><td class="paramname">data_len</td><td>The size of the <code>data</code> buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc456819a4334258c0e9076cf59f4a37" name="adc456819a4334258c0e9076cf59f4a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc456819a4334258c0e9076cf59f4a37">&#9670;&#160;</a></span>s2n_calculate_stacktrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_calculate_stacktrace </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculates the s2n stack trace.</p>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a7bfe337472559cc966e735604bc8090b" name="a7bfe337472559cc966e735604bc8090b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bfe337472559cc966e735604bc8090b">&#9670;&#160;</a></span>s2n_cert_chain_and_key_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_cert_chain_and_key_free </td>
          <td>(</td>
          <td class="paramtype">struct s2n_cert_chain_and_key *&#160;</td>
          <td class="paramname"><em>cert_and_key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Frees the memory associated with an <code>s2n_cert_chain_and_key</code> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert_and_key</td><td>The certificate chain and private key handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a566c861bda05b2a1a2ba28e10648b2d8" name="a566c861bda05b2a1a2ba28e10648b2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566c861bda05b2a1a2ba28e10648b2d8">&#9670;&#160;</a></span>s2n_cert_chain_and_key_get_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> void * s2n_cert_chain_and_key_get_ctx </td>
          <td>(</td>
          <td class="paramtype">struct s2n_cert_chain_and_key *&#160;</td>
          <td class="paramname"><em>cert_and_key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the user supplied context from the <code>s2n_cert_chain_and_key</code> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert_and_key</td><td>The certificate chain and private key handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The user supplied pointer from <a class="el" href="s2n_8h.html#a4b1ca142d9e92dca8255e4d978d33e1d">s2n_cert_chain_and_key_set_ctx()</a> </dd></dl>

</div>
</div>
<a id="a5196bcf5caf7093c7cef2a87029877be" name="a5196bcf5caf7093c7cef2a87029877be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5196bcf5caf7093c7cef2a87029877be">&#9670;&#160;</a></span>s2n_cert_chain_and_key_get_private_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> <a class="el" href="s2n_8h.html#a9abfa5333181eedc5c2e59bccbe60700">s2n_cert_private_key</a> * s2n_cert_chain_and_key_get_private_key </td>
          <td>(</td>
          <td class="paramtype">struct s2n_cert_chain_and_key *&#160;</td>
          <td class="paramname"><em>cert_and_key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the private key from the <code>s2n_cert_chain_and_key</code> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert_and_key</td><td>The certificate chain and private key handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the <code>s2n_cert_private_key</code> </dd></dl>

</div>
</div>
<a id="aeeca285084f87f4c21298ea21ed057a7" name="aeeca285084f87f4c21298ea21ed057a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeca285084f87f4c21298ea21ed057a7">&#9670;&#160;</a></span>s2n_cert_chain_and_key_load_pem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_cert_chain_and_key_load_pem </td>
          <td>(</td>
          <td class="paramtype">struct s2n_cert_chain_and_key *&#160;</td>
          <td class="paramname"><em>chain_and_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>chain_pem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>private_key_pem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Associates a certificate chain and private key with an <code>s2n_cert_chain_and_key</code> object.</p>
<p ><code>cert_chain_pem</code> should be a PEM encoded certificate chain, with the first certificate in the chain being your leaf certificate. <code>private_key_pem</code> should be a PEM encoded private key corresponding to the leaf certificate.</p>
<dl class="section note"><dt>Note</dt><dd>Prefer using s2n_cert_chain_and_key_load_pem_bytes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chain_and_key</td><td>The certificate chain and private key handle </td></tr>
    <tr><td class="paramname">chain_pem</td><td>A byte array of a PEM encoded certificate chain. </td></tr>
    <tr><td class="paramname">private_key_pem</td><td>A byte array of a PEM encoded key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a53ab6e8c3724d54c79e6efdb8c9f65dd" name="a53ab6e8c3724d54c79e6efdb8c9f65dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ab6e8c3724d54c79e6efdb8c9f65dd">&#9670;&#160;</a></span>s2n_cert_chain_and_key_load_pem_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_cert_chain_and_key_load_pem_bytes </td>
          <td>(</td>
          <td class="paramtype">struct s2n_cert_chain_and_key *&#160;</td>
          <td class="paramname"><em>chain_and_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>chain_pem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>chain_pem_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>private_key_pem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>private_key_pem_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Associates a certificate chain and private key with an <code>s2n_cert_chain_and_key</code> object.</p>
<p ><code>cert_chain_pem</code> should be a PEM encoded certificate chain, with the first certificate in the chain being your leaf certificate. <code>private_key_pem</code> should be a PEM encoded private key corresponding to the leaf certificate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chain_and_key</td><td>The certificate chain and private key handle </td></tr>
    <tr><td class="paramname">chain_pem</td><td>A byte array of a PEM encoded certificate chain. </td></tr>
    <tr><td class="paramname">chain_pem_len</td><td>Size of <code>chain_pem</code> </td></tr>
    <tr><td class="paramname">private_key_pem</td><td>A byte array of a PEM encoded key. </td></tr>
    <tr><td class="paramname">private_key_pem_len</td><td>Size of <code>private_key_pem</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a0e22738ac5230c0cf643b71eee702e76" name="a0e22738ac5230c0cf643b71eee702e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e22738ac5230c0cf643b71eee702e76">&#9670;&#160;</a></span>s2n_cert_chain_and_key_load_public_pem_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_cert_chain_and_key_load_public_pem_bytes </td>
          <td>(</td>
          <td class="paramtype">struct s2n_cert_chain_and_key *&#160;</td>
          <td class="paramname"><em>chain_and_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>chain_pem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>chain_pem_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Associates a public certificate chain with a <code>s2n_cert_chain_and_key</code> object. It does NOT set a private key, so the connection will need to be configured to <a href="https://github.com/aws/s2n-tls/blob/main/docs/usage-guide/topics/ch12-private-key-ops.md">offload private key operations</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chain_and_key</td><td>The certificate chain and private key handle </td></tr>
    <tr><td class="paramname">chain_pem</td><td>A byte array of a PEM encoded certificate chain. </td></tr>
    <tr><td class="paramname">chain_pem_len</td><td>Size of <code>chain_pem</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a3ba831685480db5b9be2ff1c4070008c" name="a3ba831685480db5b9be2ff1c4070008c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba831685480db5b9be2ff1c4070008c">&#9670;&#160;</a></span>s2n_cert_chain_and_key_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> struct s2n_cert_chain_and_key * s2n_cert_chain_and_key_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new s2n_cert_chain_and_key object. This object can be associated with many config objects. It is used to represent a certificate and key pair.</p>
<dl class="section return"><dt>Returns</dt><dd>A new object used to represent a certificate-chain/key pair </dd></dl>

</div>
</div>
<a id="a4b1ca142d9e92dca8255e4d978d33e1d" name="a4b1ca142d9e92dca8255e4d978d33e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1ca142d9e92dca8255e4d978d33e1d">&#9670;&#160;</a></span>s2n_cert_chain_and_key_set_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_cert_chain_and_key_set_ctx </td>
          <td>(</td>
          <td class="paramtype">struct s2n_cert_chain_and_key *&#160;</td>
          <td class="paramname"><em>cert_and_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds a context to the <code>s2n_cert_chain_and_key</code> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert_and_key</td><td>The certificate chain and private key handle </td></tr>
    <tr><td class="paramname">ctx</td><td>An opaque pointer to user supplied data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a9b775d2673486ebb5520f36ed2d0038c" name="a9b775d2673486ebb5520f36ed2d0038c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b775d2673486ebb5520f36ed2d0038c">&#9670;&#160;</a></span>s2n_cert_chain_and_key_set_ocsp_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_cert_chain_and_key_set_ocsp_data </td>
          <td>(</td>
          <td class="paramtype">struct s2n_cert_chain_and_key *&#160;</td>
          <td class="paramname"><em>chain_and_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the raw OCSP stapling data for a certificate chain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chain_and_key</td><td>The certificate chain handle </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the raw OCSP stapling data bytes. The data will be copied. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the data bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="ad63cdab069deae3adaf560b298c8b837" name="ad63cdab069deae3adaf560b298c8b837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63cdab069deae3adaf560b298c8b837">&#9670;&#160;</a></span>s2n_cert_chain_and_key_set_sct_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_cert_chain_and_key_set_sct_list </td>
          <td>(</td>
          <td class="paramtype">struct s2n_cert_chain_and_key *&#160;</td>
          <td class="paramname"><em>chain_and_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the signed certificate timestamp (SCT) for a certificate chain. This is used for Certificate Transparency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chain_and_key</td><td>The certificate chain handle </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the SCT data. The data will be copied. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the data bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="aff55ae6c460d145a33e59392d92e81a1" name="aff55ae6c460d145a33e59392d92e81a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff55ae6c460d145a33e59392d92e81a1">&#9670;&#160;</a></span>s2n_cert_chain_get_cert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_cert_chain_get_cert </td>
          <td>(</td>
          <td class="paramtype">const struct s2n_cert_chain_and_key *&#160;</td>
          <td class="paramname"><em>chain_and_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct s2n_cert **&#160;</td>
          <td class="paramname"><em>out_cert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>cert_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the certificate <code>out_cert</code> present at the index <code>cert_idx</code> of the certificate chain <code>chain_and_key</code>.</p>
<p >Note that the index of the leaf certificate is zero. If the certificate chain <code>chain_and_key</code> is NULL or the certificate index value is not in the acceptable range for the input certificate chain, an error is returned.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Safety</h1>
<p >There is no memory allocation required for <code>out_cert</code> buffer prior to calling the <code>s2n_cert_chain_get_cert</code> API. The <code>out_cert</code> will contain the pointer to the s2n_cert initialized within the input s2n_cert_chain_and_key <code>chain_and_key</code>. The pointer to the output s2n certificate <code>out_cert</code> is valid until <code>chain_and_key</code> is freed up. If a caller wishes to persist the <code>out_cert</code> beyond the lifetime of <code>chain_and_key</code>, the contents would need to be copied prior to freeing <code>chain_and_key</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chain_and_key</td><td>A pointer to the s2n_cert_chain_and_key object being read. </td></tr>
    <tr><td class="paramname">out_cert</td><td>A pointer to the output s2n_cert <code>out_cert</code> present at the index <code>cert_idx</code> of the certificate chain <code>chain_and_key</code>. </td></tr>
    <tr><td class="paramname">cert_idx</td><td>The certificate index for the requested certificate within the s2n certificate chain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a346a183c22e8b394c17bd22ac54b1553" name="a346a183c22e8b394c17bd22ac54b1553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a346a183c22e8b394c17bd22ac54b1553">&#9670;&#160;</a></span>s2n_cert_chain_get_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_cert_chain_get_length </td>
          <td>(</td>
          <td class="paramtype">const struct s2n_cert_chain_and_key *&#160;</td>
          <td class="paramname"><em>chain_and_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>cert_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chain_and_key</td><td>A pointer to the s2n_cert_chain_and_key object being read. </td></tr>
    <tr><td class="paramname">cert_length</td><td>This return value represents the length of the s2n certificate chain <code>chain_and_key</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the s2n certificate chain <code>chain_and_key</code>. </dd></dl>

</div>
</div>
<a id="afff84930291800897ca24eeaa0e3ad8a" name="afff84930291800897ca24eeaa0e3ad8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff84930291800897ca24eeaa0e3ad8a">&#9670;&#160;</a></span>s2n_cert_get_der()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_cert_get_der </td>
          <td>(</td>
          <td class="paramtype">const struct s2n_cert *&#160;</td>
          <td class="paramname"><em>cert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t **&#160;</td>
          <td class="paramname"><em>out_cert_der</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>cert_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the s2n certificate in DER format along with its length.</p>
<p >The API gets the s2n certificate <code>cert</code> in DER format. The certificate is returned in the <code>out_cert_der</code> buffer. Here, <code>cert_len</code> represents the length of the certificate.</p>
<p >A caller can use certificate parsing tools such as the ones provided by OpenSSL to parse the DER encoded certificate chain returned.</p>
<h1><a class="anchor" id="autotoc_md4"></a>
Safety</h1>
<p >The memory for the <code>out_cert_der</code> buffer is allocated and owned by s2n-tls. Since the size of the certificate can potentially be very large, a pointer to internal connection data is returned instead of copying the contents into a caller-provided buffer.</p>
<p >The pointer to the output buffer <code>out_cert_der</code> is valid only while the connection exists. The <code>s2n_connection_free</code> API frees the memory associated with the out_cert_der buffer and after the <code>s2n_connection_wipe</code> API is called the memory pointed by out_cert_der is invalid.</p>
<p >If a caller wishes to persist the <code>out_cert_der</code> beyond the lifetime of the connection, the contents would need to be copied prior to the connection termination.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>A pointer to the s2n_cert object being read. </td></tr>
    <tr><td class="paramname">out_cert_der</td><td>A pointer to the output buffer which will hold the s2n certificate <code>cert</code> in DER format. </td></tr>
    <tr><td class="paramname">cert_length</td><td>This return value represents the length of the certificate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7f746088134992ddc34bb6dbcb7f993" name="af7f746088134992ddc34bb6dbcb7f993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f746088134992ddc34bb6dbcb7f993">&#9670;&#160;</a></span>s2n_cert_get_utf8_string_from_extension_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_cert_get_utf8_string_from_extension_data </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>extension_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>extension_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>out_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the UTF8 String representation of the DER encoded ASN.1 X.509 certificate extension data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extension_data</td><td>A pointer to the DER encoded ASN.1 X.509 certificate extension value being read. </td></tr>
    <tr><td class="paramname">extension_len</td><td>represents the length of the input buffer <code>extension_data</code>. </td></tr>
    <tr><td class="paramname">out_data</td><td>A pointer to the output buffer which will hold the UTF8 String representation of the DER encoded ASN.1 X.509 certificate extension data returned. </td></tr>
    <tr><td class="paramname">out_len</td><td>This value is both an input and output parameter and represents the length of the output buffer <code>out_data</code>. When used as an input parameter, the caller must use this parameter to convey the maximum length of <code>out_data</code>. When used as an output parameter, <code>out_len</code> holds the actual length of UTF8 String returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83e50322739b7d5025d71684e400bcee" name="a83e50322739b7d5025d71684e400bcee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e50322739b7d5025d71684e400bcee">&#9670;&#160;</a></span>s2n_cert_get_utf8_string_from_extension_data_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_cert_get_utf8_string_from_extension_data_length </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>extension_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>extension_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>utf8_str_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the UTF8 String length of the ASN.1 X.509 certificate extension data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extension_data</td><td>A pointer to the DER encoded ASN.1 X.509 certificate extension value being read. </td></tr>
    <tr><td class="paramname">extension_len</td><td>represents the length of the input buffer <code>extension_data</code>. </td></tr>
    <tr><td class="paramname">utf8_str_len</td><td>This return value contains the UTF8 String length of the ASN.1 X.509 certificate extension data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7a76b1f91bd6cb0132a768ab00680f3" name="ab7a76b1f91bd6cb0132a768ab00680f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a76b1f91bd6cb0132a768ab00680f3">&#9670;&#160;</a></span>s2n_cert_get_x509_extension_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_cert_get_x509_extension_value </td>
          <td>(</td>
          <td class="paramtype">struct s2n_cert *&#160;</td>
          <td class="paramname"><em>cert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>oid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>ext_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ext_value_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>critical</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the DER encoding of an ASN.1 X.509 certificate extension value, it's length and a boolean critical.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>A pointer to the s2n_cert object being read. </td></tr>
    <tr><td class="paramname">oid</td><td>A null-terminated cstring that contains the OID of the X.509 certificate extension to be read. </td></tr>
    <tr><td class="paramname">ext_value</td><td>A pointer to the output buffer which will hold the DER encoding of an ASN.1 X.509 certificate extension value returned. </td></tr>
    <tr><td class="paramname">ext_value_len</td><td>This value is both an input and output parameter and represents the length of the output buffer <code>ext_value</code>. When used as an input parameter, the caller must use this parameter to convey the maximum length of <code>ext_value</code>. When used as an output parameter, <code>ext_value_len</code> holds the actual length of the DER encoding of the ASN.1 X.509 certificate extension value returned. </td></tr>
    <tr><td class="paramname">critical</td><td>This return value contains the boolean value for <code>critical</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac894d4595895577e79f0e6b4d0be4477" name="ac894d4595895577e79f0e6b4d0be4477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac894d4595895577e79f0e6b4d0be4477">&#9670;&#160;</a></span>s2n_cert_get_x509_extension_value_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_cert_get_x509_extension_value_length </td>
          <td>(</td>
          <td class="paramtype">struct s2n_cert *&#160;</td>
          <td class="paramname"><em>cert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>oid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ext_value_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the length of the DER encoded extension value of the ASN.1 X.509 certificate extension.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>A pointer to the s2n_cert object being read. </td></tr>
    <tr><td class="paramname">oid</td><td>A null-terminated cstring that contains the OID of the X.509 certificate extension to be read. </td></tr>
    <tr><td class="paramname">ext_value_len</td><td>This return value contains the length of DER encoded extension value of the ASN.1 X.509 certificate extension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bec40a852f3766f4e419684036e7550" name="a6bec40a852f3766f4e419684036e7550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bec40a852f3766f4e419684036e7550">&#9670;&#160;</a></span>s2n_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_cleanup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Cleans up thread-local resources used by s2n-tls. Does not perform a full library cleanup. To fully clean up the library use s2n_cleanup_final().</p>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="af6345dc29f734d06419e7788024b557a" name="af6345dc29f734d06419e7788024b557a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6345dc29f734d06419e7788024b557a">&#9670;&#160;</a></span>s2n_client_hello_cb_done()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_client_hello_cb_done </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Marks the non-blocking callback as complete. Can be invoked from within the callback when operating in non-blocking mode to continue the handshake.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The connection object being updated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="ad664daed9d1c437460c563c6f02157d9" name="ad664daed9d1c437460c563c6f02157d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad664daed9d1c437460c563c6f02157d9">&#9670;&#160;</a></span>s2n_client_hello_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_client_hello_free </td>
          <td>(</td>
          <td class="paramtype">struct s2n_client_hello **&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Frees an s2n_client_hello structure.</p>
<p >This method should be called to free s2n_client_hellos returned by s2n_client_hello_parse_message. It will error if passed an s2n_client_hello returned by s2n_connection_get_client_hello and owned by the connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The structure to be freed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success, S2N_FAILURE on failure. </dd></dl>

</div>
</div>
<a id="ab83eff4e25edddcd4688854e0c4d8e62" name="ab83eff4e25edddcd4688854e0c4d8e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83eff4e25edddcd4688854e0c4d8e62">&#9670;&#160;</a></span>s2n_client_hello_get_cipher_suites()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> ssize_t s2n_client_hello_get_cipher_suites </td>
          <td>(</td>
          <td class="paramtype">struct s2n_client_hello *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Copies into the <code>out</code> buffer <code>max_length</code> bytes of the cipher_suites on the ClientHello.</p>
<p >Note: SSLv2 ClientHello cipher suites follow a different structure than modern ClientHello messages. See <a href="https://tools.ietf.org/html/rfc5246#appendix-E.2">RFC5246</a>. To determine whether a ClientHello is an SSLv2 ClientHello, you will need to use <a class="el" href="s2n_8h.html#ad2a608603c7dbe9203a7c8f8b63ee1b8">s2n_connection_get_client_hello_version()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The Client Hello handle </td></tr>
    <tr><td class="paramname">out</td><td>The destination buffer for the raw Client Hello cipher suites </td></tr>
    <tr><td class="paramname">max_length</td><td>The size of out in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of copied bytes </dd></dl>

</div>
</div>
<a id="a836ac7d852fbb18b790c8084878e1b5d" name="a836ac7d852fbb18b790c8084878e1b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836ac7d852fbb18b790c8084878e1b5d">&#9670;&#160;</a></span>s2n_client_hello_get_cipher_suites_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> ssize_t s2n_client_hello_get_cipher_suites_length </td>
          <td>(</td>
          <td class="paramtype">struct s2n_client_hello *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Function to determine the size of the Client Hello cipher suites. This can be used to allocate the <code>out</code> buffer for <a class="el" href="s2n_8h.html#ab83eff4e25edddcd4688854e0c4d8e62">s2n_client_hello_get_cipher_suites()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The Client Hello handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes the cipher_suites takes on the ClientHello message received by the server </dd></dl>

</div>
</div>
<a id="adbab79e2b5c583efaf918283fb0222bf" name="adbab79e2b5c583efaf918283fb0222bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbab79e2b5c583efaf918283fb0222bf">&#9670;&#160;</a></span>s2n_client_hello_get_compression_methods()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_client_hello_get_compression_methods </td>
          <td>(</td>
          <td class="paramtype">struct s2n_client_hello *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>list_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>out_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Retrieves the list of compression methods sent in the Client Hello.</p>
<p >Use <code><a class="el" href="s2n_8h.html#a76a3487dda504244c2b81978de6d79bb">s2n_client_hello_get_compression_methods_length()</a></code> to retrieve how much memory should be allocated for the buffer in advance.</p>
<dl class="section note"><dt>Note</dt><dd>Compression methods were removed in TLS1.3 and therefore the only valid value in this list is the "null" compression method when TLS1.3 is negotiated.</dd>
<dd>
s2n-tls has never supported compression methods in any TLS version and therefore a compression method will never be negotiated or used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>A pointer to the Client Hello </td></tr>
    <tr><td class="paramname">list</td><td>A pointer to some memory that s2n will write the compression methods to. This memory MUST be the size of <code>list_length</code> </td></tr>
    <tr><td class="paramname">list_length</td><td>The size of <code>list</code>. </td></tr>
    <tr><td class="paramname">out_length</td><td>An out pointer. s2n will set its value to the size of the compression methods list in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a76a3487dda504244c2b81978de6d79bb" name="a76a3487dda504244c2b81978de6d79bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a3487dda504244c2b81978de6d79bb">&#9670;&#160;</a></span>s2n_client_hello_get_compression_methods_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_client_hello_get_compression_methods_length </td>
          <td>(</td>
          <td class="paramtype">struct s2n_client_hello *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>out_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the length of the compression methods list sent in the Client Hello.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>A pointer to the Client Hello </td></tr>
    <tr><td class="paramname">out_length</td><td>An out pointer. Will be set to the length of the compression methods list in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a5ad69c8c71521b13b69bcd77fea92b74" name="a5ad69c8c71521b13b69bcd77fea92b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad69c8c71521b13b69bcd77fea92b74">&#9670;&#160;</a></span>s2n_client_hello_get_extension_by_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> ssize_t s2n_client_hello_get_extension_by_id </td>
          <td>(</td>
          <td class="paramtype">struct s2n_client_hello *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#ab2b46f61765da5529f931afb8dd8a1f8">s2n_tls_extension_type</a>&#160;</td>
          <td class="paramname"><em>extension_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Copies into the <code>out</code> buffer <code>max_length</code> bytes of a given extension type on the ClientHello</p>
<p ><code>ch</code> is a pointer to the <code>s2n_client_hello</code> of the <code>s2n_connection</code> which can be obtained using <a class="el" href="s2n_8h.html#ac0c64d96b5b9a4cb600a22157d6743e3">s2n_connection_get_client_hello()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>A pointer to the Client Hello </td></tr>
    <tr><td class="paramname">extension_type</td><td>Indicates the desired extension </td></tr>
    <tr><td class="paramname">out</td><td>A pointer to the buffer that s2n will write the client session id to. This buffer MUST be the size of <code>max_length</code> </td></tr>
    <tr><td class="paramname">max_length</td><td>The size of <code>out</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of copied bytes </dd></dl>

</div>
</div>
<a id="aba6709ea1bac503daf846990821d8f36" name="aba6709ea1bac503daf846990821d8f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba6709ea1bac503daf846990821d8f36">&#9670;&#160;</a></span>s2n_client_hello_get_extension_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> ssize_t s2n_client_hello_get_extension_length </td>
          <td>(</td>
          <td class="paramtype">struct s2n_client_hello *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#ab2b46f61765da5529f931afb8dd8a1f8">s2n_tls_extension_type</a>&#160;</td>
          <td class="paramname"><em>extension_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Query the ClientHello message received by the server. Use this function to allocate the <code>out</code> buffer for other client hello extension functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>A pointer to the Client Hello </td></tr>
    <tr><td class="paramname">extension_type</td><td>Indicates the desired extension </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes the given extension type takes </dd></dl>

</div>
</div>
<a id="ae872d221c8d47cab5178cfd3ca00bca4" name="ae872d221c8d47cab5178cfd3ca00bca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae872d221c8d47cab5178cfd3ca00bca4">&#9670;&#160;</a></span>s2n_client_hello_get_extensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> ssize_t s2n_client_hello_get_extensions </td>
          <td>(</td>
          <td class="paramtype">struct s2n_client_hello *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Copies into the <code>out</code> buffer <code>max_length</code> bytes of the extensions in the ClientHello.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The Client Hello handle </td></tr>
    <tr><td class="paramname">out</td><td>The destination buffer for the raw Client Hello extensions </td></tr>
    <tr><td class="paramname">max_length</td><td>The size of out in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of copied bytes </dd></dl>

</div>
</div>
<a id="a9c10c0917fcda2f6a546310f7b80b8fa" name="a9c10c0917fcda2f6a546310f7b80b8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c10c0917fcda2f6a546310f7b80b8fa">&#9670;&#160;</a></span>s2n_client_hello_get_extensions_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> ssize_t s2n_client_hello_get_extensions_length </td>
          <td>(</td>
          <td class="paramtype">struct s2n_client_hello *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Function to determine the size of the Client Hello extensions. This can be used to allocate the <code>out</code> buffer for <a class="el" href="s2n_8h.html#ae872d221c8d47cab5178cfd3ca00bca4">s2n_client_hello_get_extensions()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The Client Hello handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes the extensions take in the ClientHello message received by the server </dd></dl>

</div>
</div>
<a id="aeff080b07553418e574fa5907c6d2ca0" name="aeff080b07553418e574fa5907c6d2ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff080b07553418e574fa5907c6d2ca0">&#9670;&#160;</a></span>s2n_client_hello_get_legacy_protocol_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_client_hello_get_legacy_protocol_version </td>
          <td>(</td>
          <td class="paramtype">struct s2n_client_hello *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Access the Client Hello protocol version</p>
<dl class="section note"><dt>Note</dt><dd>This field is a legacy field in TLS1.3 and is no longer used to negotiate the protocol version of the connection. It will be set to TLS1.2 even if TLS1.3 is negotiated. Therefore this method should only be used for logging or fingerprinting.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>A pointer to the client hello struct </td></tr>
    <tr><td class="paramname">out</td><td>The protocol version in the client hello. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2c9fa3dea9e458f259c142c01537e4f" name="ad2c9fa3dea9e458f259c142c01537e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c9fa3dea9e458f259c142c01537e4f">&#9670;&#160;</a></span>s2n_client_hello_get_legacy_record_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_client_hello_get_legacy_record_version </td>
          <td>(</td>
          <td class="paramtype">struct s2n_client_hello *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Access the protocol version from the header of the first record that contained the ClientHello message.</p>
<dl class="section note"><dt>Note</dt><dd>This field has been deprecated and should not be confused with the client hello version. It is often set very low, usually to TLS1.0 for compatibility reasons, and should never be set higher than TLS1.2. Therefore this method should only be used for logging or fingerprinting.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the client hello struct </td></tr>
    <tr><td class="paramname">out</td><td>The protocol version in the record header containing the Client Hello. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1fc624f4ffe9378ad77eea895bb52d6" name="ac1fc624f4ffe9378ad77eea895bb52d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1fc624f4ffe9378ad77eea895bb52d6">&#9670;&#160;</a></span>s2n_client_hello_get_raw_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> ssize_t s2n_client_hello_get_raw_message </td>
          <td>(</td>
          <td class="paramtype">struct s2n_client_hello *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Copies <code>max_length</code> bytes of the ClientHello message into the <code>out</code> buffer. The ClientHello instrumented using this function will have the Random bytes zero-ed out.</p>
<p >Note: SSLv2 ClientHello messages follow a different structure than more modern ClientHello messages. See <a href="https://tools.ietf.org/html/rfc5246#appendix-E.2">RFC5246</a>. In addition, due to how s2n-tls parses SSLv2 ClientHellos, the raw message is missing the first three bytes (the msg_type and version) and instead begins with the cipher_specs. To determine whether a ClientHello is an SSLv2 ClientHello, you will need to use <a class="el" href="s2n_8h.html#ad2a608603c7dbe9203a7c8f8b63ee1b8">s2n_connection_get_client_hello_version()</a>. To get the protocol version advertised in the SSLv2 ClientHello (which may be higher than SSLv2), you will need to use <a class="el" href="s2n_8h.html#aafa9d12438841f2a47907b244eccd7cc">s2n_connection_get_client_protocol_version()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The Client Hello handle </td></tr>
    <tr><td class="paramname">out</td><td>The destination buffer for the raw Client Hello </td></tr>
    <tr><td class="paramname">max_length</td><td>The size of out in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of copied bytes </dd></dl>

</div>
</div>
<a id="a4c2c0de61921c9ddc8e8c4e56084cc6c" name="a4c2c0de61921c9ddc8e8c4e56084cc6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2c0de61921c9ddc8e8c4e56084cc6c">&#9670;&#160;</a></span>s2n_client_hello_get_raw_message_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> ssize_t s2n_client_hello_get_raw_message_length </td>
          <td>(</td>
          <td class="paramtype">struct s2n_client_hello *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Function to determine the size of the raw Client Hello buffer.</p>
<p >Can be used to determine the necessary size of the <code>out</code> buffer for <a class="el" href="s2n_8h.html#ac1fc624f4ffe9378ad77eea895bb52d6">s2n_client_hello_get_raw_message()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The Client Hello handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the ClientHello message received by the server </dd></dl>

</div>
</div>
<a id="a13b362b99e61c3da07b6be2f9c4cff3f" name="a13b362b99e61c3da07b6be2f9c4cff3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b362b99e61c3da07b6be2f9c4cff3f">&#9670;&#160;</a></span>s2n_client_hello_get_server_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_client_hello_get_server_name </td>
          <td>(</td>
          <td class="paramtype">struct s2n_client_hello *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>server_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>out_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the first server name in a Client Hello.</p>
<p >Use <code><a class="el" href="s2n_8h.html#a4345089b56dee57f4c6f97c04588289e">s2n_client_hello_get_server_name_length()</a></code> to get the amount of memory needed for the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>A pointer to the ClientHello </td></tr>
    <tr><td class="paramname">server_name</td><td>A pointer to the memory which will be populated with the server name </td></tr>
    <tr><td class="paramname">length</td><td>The maximum amount of data that can be written to <code>server_name</code> </td></tr>
    <tr><td class="paramname">out_length</td><td>A pointer which will be populated with the size of the server name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4345089b56dee57f4c6f97c04588289e" name="a4345089b56dee57f4c6f97c04588289e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4345089b56dee57f4c6f97c04588289e">&#9670;&#160;</a></span>s2n_client_hello_get_server_name_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_client_hello_get_server_name_length </td>
          <td>(</td>
          <td class="paramtype">struct s2n_client_hello *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the length of the first server name in a Client Hello.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>A pointer to the ClientHello </td></tr>
    <tr><td class="paramname">length</td><td>A pointer which will be populated with the length of the server name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae86458717edccfb2f58b86f3991af1a9" name="ae86458717edccfb2f58b86f3991af1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae86458717edccfb2f58b86f3991af1a9">&#9670;&#160;</a></span>s2n_client_hello_get_session_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_client_hello_get_session_id </td>
          <td>(</td>
          <td class="paramtype">struct s2n_client_hello *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>out_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Copies up to <code>max_length</code> bytes of the ClientHello session_id into the <code>out</code> buffer and stores the number of copied bytes in <code>out_length</code>.</p>
<p >Retrieve the session id as sent by the client in the ClientHello message. The session id on the <code>s2n_connection</code> may change later when the server sends the ServerHello; see <code>s2n_connection_get_session_id</code> for how to get the final session id used for future session resumption.</p>
<p >Use <a class="el" href="s2n_8h.html#a803cebda25d3d8beadfd2981bfc0faa2">s2n_client_hello_get_session_id_length()</a> to get the the ClientHello session id length in bytes. <code>ch</code> is a pointer to the <code>s2n_client_hello</code> of the <code>s2n_connection</code> which can be obtained using <a class="el" href="s2n_8h.html#ac0c64d96b5b9a4cb600a22157d6743e3">s2n_connection_get_client_hello()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>A pointer to the Client Hello </td></tr>
    <tr><td class="paramname">out</td><td>A pointer to the buffer that s2n will write the client session id to. This buffer MUST be the size of <code>max_length</code> </td></tr>
    <tr><td class="paramname">out_length</td><td>An out pointer. s2n will set it's value to the size of the session_id in bytes. </td></tr>
    <tr><td class="paramname">max_length</td><td>The size of <code>out</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a803cebda25d3d8beadfd2981bfc0faa2" name="a803cebda25d3d8beadfd2981bfc0faa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803cebda25d3d8beadfd2981bfc0faa2">&#9670;&#160;</a></span>s2n_client_hello_get_session_id_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_client_hello_get_session_id_length </td>
          <td>(</td>
          <td class="paramtype">struct s2n_client_hello *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>out_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the the ClientHello session id length in bytes</p>
<p ><code>ch</code> is a pointer to the <code>s2n_client_hello</code> of the <code>s2n_connection</code> which can be obtained using <a class="el" href="s2n_8h.html#ac0c64d96b5b9a4cb600a22157d6743e3">s2n_connection_get_client_hello()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>A pointer to the Client Hello </td></tr>
    <tr><td class="paramname">out_length</td><td>An out pointer. s2n will set it's value to the size of the session_id in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a68a751eb59517406db2439a88e94d8d1" name="a68a751eb59517406db2439a88e94d8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a751eb59517406db2439a88e94d8d1">&#9670;&#160;</a></span>s2n_client_hello_get_supported_groups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_client_hello_get_supported_groups </td>
          <td>(</td>
          <td class="paramtype">struct s2n_client_hello *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>groups_count_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>groups_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Retrieves the supported groups received from the client in the supported groups extension.</p>
<p >IANA values for each of the received supported groups are written to the provided <code>groups</code> array, and <code>groups_count</code> is set to the number of received supported groups.</p>
<p ><code>groups_count_max</code> should be set to the maximum capacity of the <code>groups</code> array. If <code>groups_count_max</code> is less than the number of received supported groups, this function will error. To determine how large <code>groups</code> should be in advance, use <code><a class="el" href="s2n_8h.html#aba6709ea1bac503daf846990821d8f36">s2n_client_hello_get_extension_length()</a></code> with the S2N_EXTENSION_SUPPORTED_GROUPS extension type, and divide the value by 2.</p>
<p >If no supported groups extension was received from the peer, or the received supported groups extension is malformed, this function will error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>A pointer to the ClientHello. Can be retrieved from a connection via <code><a class="el" href="s2n_8h.html#ac0c64d96b5b9a4cb600a22157d6743e3">s2n_connection_get_client_hello()</a></code>. </td></tr>
    <tr><td class="paramname">groups</td><td>The array to populate with the received supported groups. </td></tr>
    <tr><td class="paramname">groups_count_max</td><td>The maximum number of supported groups that can fit in the <code>groups</code> array. </td></tr>
    <tr><td class="paramname">groups_count</td><td>Returns the number of received supported groups. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure. </dd></dl>

</div>
</div>
<a id="a1be05b74838db77a70ce8aba82b284fa" name="a1be05b74838db77a70ce8aba82b284fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be05b74838db77a70ce8aba82b284fa">&#9670;&#160;</a></span>s2n_client_hello_has_extension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_client_hello_has_extension </td>
          <td>(</td>
          <td class="paramtype">struct s2n_client_hello *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>extension_iana</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>exists</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Used to check if a particular extension exists in the client hello.</p>
<p ><code>ch</code> is a pointer to the <code>s2n_client_hello</code> of the <code>s2n_connection</code> which can be obtained using <a class="el" href="s2n_8h.html#ac0c64d96b5b9a4cb600a22157d6743e3">s2n_connection_get_client_hello()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>A pointer to the client hello object </td></tr>
    <tr><td class="paramname">extension_iana</td><td>The iana value of the extension </td></tr>
    <tr><td class="paramname">exists</td><td>A pointer that will be set to whether or not the extension exists </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacf329c844fa13ec9ccef34da945d7f2" name="aacf329c844fa13ec9ccef34da945d7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf329c844fa13ec9ccef34da945d7f2">&#9670;&#160;</a></span>s2n_client_hello_parse_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> struct s2n_client_hello * s2n_client_hello_parse_message </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates an s2n_client_hello from bytes representing a ClientHello message.</p>
<p >The input bytes should include the message header (message type and length), but not the record header.</p>
<p >Unlike s2n_connection_get_client_hello, the s2n_client_hello returned by this method is owned by the application and must be freed with s2n_client_hello_free.</p>
<p >This method does not support SSLv2 ClientHellos.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>The raw bytes representing the ClientHello. </td></tr>
    <tr><td class="paramname">size</td><td>The size of raw_message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new s2n_client_hello on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="a1d36a77c4bbcd04ea33b84ffd074fb8f" name="a1d36a77c4bbcd04ea33b84ffd074fb8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d36a77c4bbcd04ea33b84ffd074fb8f">&#9670;&#160;</a></span>s2n_config_accept_max_fragment_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_accept_max_fragment_length </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Allows the server to opt-in to accept client's TLS maximum fragment length extension requests. If this API is not called, and client requests the extension, server will ignore the request and continue TLS handshake with default maximum fragment length of 8k bytes</p>
<dl class="section note"><dt>Note</dt><dd>Some TLS implementations do not respect their peer's max fragment length extension.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a5f2c5705a56cdb5f9ca4932a24f838e1" name="a5f2c5705a56cdb5f9ca4932a24f838e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f2c5705a56cdb5f9ca4932a24f838e1">&#9670;&#160;</a></span>s2n_config_add_cert_chain_and_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_add_cert_chain_and_key </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cert_chain_pem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>private_key_pem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Associates a certificate chain and private key with an <code>s2n_config</code> object. Using this API, only one cert chain of each type (like ECDSA or RSA) may be associated with a config. <code>cert_chain_pem</code> should be a PEM encoded certificate chain, with the first certificate in the chain being your server's certificate. <code>private_key_pem</code> should be a PEM encoded private key corresponding to the server certificate.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Use s2n_config_add_cert_chain_and_key_to_store instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">cert_chain_pem</td><td>A byte array of a PEM encoded certificate chain. </td></tr>
    <tr><td class="paramname">private_key_pem</td><td>A byte array of a PEM encoded key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure. </dd></dl>

</div>
</div>
<a id="abfb875eff7e81b22378e4ae5b313169f" name="abfb875eff7e81b22378e4ae5b313169f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb875eff7e81b22378e4ae5b313169f">&#9670;&#160;</a></span>s2n_config_add_cert_chain_and_key_to_store()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_add_cert_chain_and_key_to_store </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct s2n_cert_chain_and_key *&#160;</td>
          <td class="paramname"><em>cert_key_pair</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The preferred method of associating a certificate chain and private key pair with an <code>s2n_config</code> object. This method may be called multiple times to support multiple key types (RSA, RSA-PSS, ECDSA) and multiple domains. On the server side, the certificate selected will be based on the incoming SNI value and the client's capabilities (supported ciphers).</p>
<p >In the case of no certificate matching the client's SNI extension or if no SNI extension was sent by the client, the certificate from the <code>first</code> call to <code><a class="el" href="s2n_8h.html#abfb875eff7e81b22378e4ae5b313169f">s2n_config_add_cert_chain_and_key_to_store()</a></code> will be selected. Use <code><a class="el" href="s2n_8h.html#a30d021a10ad7183c995d6d2a65926272">s2n_config_set_cert_chain_and_key_defaults()</a></code> to set different defaults.</p>
<dl class="section warning"><dt>Warning</dt><dd>It is not recommended to free or modify the <code>cert_key_pair</code> as any subsequent changes will be reflected in the config.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">cert_key_pair</td><td>The certificate chain and private key handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a8e9f9e33817a4984217de79b55b7c607" name="a8e9f9e33817a4984217de79b55b7c607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9f9e33817a4984217de79b55b7c607">&#9670;&#160;</a></span>s2n_config_add_dhparams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_add_dhparams </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dhparams_pem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Associates a set of Diffie-Hellman parameters with an <code>s2n_config</code> object. </p><dl class="section note"><dt>Note</dt><dd><code>dhparams_pem</code> should be PEM encoded DH parameters.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">dhparams_pem</td><td>A string containing the PEM encoded DH parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a1de5c0b7a1029ee248947835d4e170bc" name="a1de5c0b7a1029ee248947835d4e170bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de5c0b7a1029ee248947835d4e170bc">&#9670;&#160;</a></span>s2n_config_add_pem_to_trust_store()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_add_pem_to_trust_store </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds a PEM to the trust store. This will allocate memory, and load <code>pem</code> into the trust store.</p>
<p >When configs are created with <code><a class="el" href="s2n_8h.html#aae4a525b68ba7bd181a27de9ea2fcd1a">s2n_config_new()</a></code>, the trust store is initialized with default system certificates. To completely override these certificates, call <code><a class="el" href="s2n_8h.html#af7e2759066521827269d56d4da063f7b">s2n_config_wipe_trust_store()</a></code> before calling this function.</p>
<dl class="section note"><dt>Note</dt><dd>This API uses the s2n-tls PEM parsing implementation, which is more strict than typical libcrypto implementations such as OpenSSL. An error is returned if any unexpected data is encountered while parsing <code>pem</code>. This allows applications to be made aware of any malformed certificates rather than attempt to negotiate with a partial trust store. However, some PEMs may need to be loaded that are not under control of the application, such as system trust stores. In this case, <code><a class="el" href="s2n_8h.html#a85545629ce095ed44de580592eecf50e">s2n_config_set_verification_ca_location()</a></code> may be used, which performs more widely compatible and permissive parsing from the linked libcrypto.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">pem</td><td>The string value of the PEM certificate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="ae6d6a59a875a39fdd9f81ae02595173d" name="ae6d6a59a875a39fdd9f81ae02595173d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d6a59a875a39fdd9f81ae02595173d">&#9670;&#160;</a></span>s2n_config_add_ticket_crypto_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_add_ticket_crypto_key </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>name_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>key_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>intro_time_in_seconds_from_epoch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds session ticket key on the server side. It would be ideal to add new keys after every (encrypt_decrypt_key_lifetime_in_nanos/2) nanos because this will allow for gradual and linear transition of a key from encrypt-decrypt state to decrypt-only state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">name</td><td>Name of the session ticket key that should be randomly generated to avoid collisions </td></tr>
    <tr><td class="paramname">name_len</td><td>Length of session ticket key name </td></tr>
    <tr><td class="paramname">key</td><td>Key used to perform encryption/decryption of session ticket </td></tr>
    <tr><td class="paramname">key_len</td><td>Length of the session ticket key </td></tr>
    <tr><td class="paramname">intro_time_in_seconds_from_epoch</td><td>Time at which the session ticket key is introduced. If this is 0, then intro_time_in_seconds_from_epoch is set to now. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a2d822c2cf75cdb9d28f0b3cdf8edab02" name="a2d822c2cf75cdb9d28f0b3cdf8edab02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d822c2cf75cdb9d28f0b3cdf8edab02">&#9670;&#160;</a></span>s2n_config_append_protocol_preference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_append_protocol_preference </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>protocol_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Appends the provided application protocol to the preference list</p>
<p >The data provided in <code>protocol</code> parameter will be copied into an internal buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">protocol</td><td>A pointer to a byte array value </td></tr>
    <tr><td class="paramname">protocol_len</td><td>The length of bytes that should be read from <code>protocol</code>. Note: this value cannot be 0, otherwise an error will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abbdc139b4a68057aa0ce812b5f07138d" name="abbdc139b4a68057aa0ce812b5f07138d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbdc139b4a68057aa0ce812b5f07138d">&#9670;&#160;</a></span>s2n_config_disable_x509_time_verification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_disable_x509_time_verification </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Disables timestamp validation for received certificates.</p>
<p >By default, s2n-tls checks the notBefore and notAfter fields on the certificates it receives during the handshake. If the current date is not within the range of these fields for any certificate in the chain of trust, <code><a class="el" href="s2n_8h.html#ad3222e7aacf35a56be842678171be440">s2n_negotiate()</a></code> will error. This validation is in accordance with RFC 5280, section 6.1.3 a.2: <a href="https://datatracker.ietf.org/doc/html/rfc5280#section-6.1.3">https://datatracker.ietf.org/doc/html/rfc5280#section-6.1.3</a>.</p>
<p >This API will disable this timestamp validation, permitting negotiation with peers that send expired certificates, or certificates that are not yet considered valid.</p>
<dl class="section warning"><dt>Warning</dt><dd>Applications calling this API should seriously consider the security implications of disabling this validation. The validity period of a certificate corresponds to the range of time in which the CA is guaranteed to maintain information regarding the certificate's revocation status. As such, it may not be possible to obtain accurate revocation information for certificates with invalid timestamps. Applications disabling this validation MUST implement some external method for limiting certificate lifetime.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The associated connection config. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success, S2N_FAILURE on failure. </dd></dl>

</div>
</div>
<a id="aa9d89fb59987254fe2546881d172be18" name="aa9d89fb59987254fe2546881d172be18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d89fb59987254fe2546881d172be18">&#9670;&#160;</a></span>s2n_config_disable_x509_verification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_disable_x509_verification </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Turns off all X.509 validation during the negotiation phase of the connection. This should only be used for testing or debugging purposes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a20fa5cce10719fe7f5730c5419f63910" name="a20fa5cce10719fe7f5730c5419f63910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20fa5cce10719fe7f5730c5419f63910">&#9670;&#160;</a></span>s2n_config_enable_cert_req_dss_legacy_compat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_enable_cert_req_dss_legacy_compat </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >s2n_config_enable_cert_req_dss_legacy_compat adds a dss cert type in the server certificate request when being called. It only sends the dss cert type in the cert request but does not succeed the handshake if a dss cert is received. Please DO NOT call this api unless you know you actually need legacy DSS certificate type compatibility </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Config to enable legacy DSS certificates for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a414a19458d8ce45e039dbd01e7dd67f4" name="a414a19458d8ce45e039dbd01e7dd67f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a414a19458d8ce45e039dbd01e7dd67f4">&#9670;&#160;</a></span>s2n_config_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_free </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Frees the memory associated with an <code>s2n_config</code> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being freed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a867af1779dd5a21b944239eb932c0744" name="a867af1779dd5a21b944239eb932c0744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a867af1779dd5a21b944239eb932c0744">&#9670;&#160;</a></span>s2n_config_free_cert_chain_and_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_free_cert_chain_and_key </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Frees the certificate chain and key associated with an <code>s2n_config</code> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object with DH params being freed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a5a04d9eaa39a0145f16dd819fe60fc0b" name="a5a04d9eaa39a0145f16dd819fe60fc0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a04d9eaa39a0145f16dd819fe60fc0b">&#9670;&#160;</a></span>s2n_config_free_dhparams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_free_dhparams </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Frees the DH params associated with an <code>s2n_config</code> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object with DH params being freed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a2229eaee45a85050eae6b12924e6fea3" name="a2229eaee45a85050eae6b12924e6fea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2229eaee45a85050eae6b12924e6fea3">&#9670;&#160;</a></span>s2n_config_get_client_auth_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_get_client_auth_type </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a8757c094681bb8151329c8dc067106b8">s2n_cert_auth_type</a> *&#160;</td>
          <td class="paramname"><em>client_auth_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets Client Certificate authentication method the s2n_config object is using.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>A pointer to a s2n_config object </td></tr>
    <tr><td class="paramname">client_auth_type</td><td>A pointer to a client auth policy. This will be updated to the s2n_config value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="ab325136d7c254e6f72d2a134ad59f759" name="ab325136d7c254e6f72d2a134ad59f759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab325136d7c254e6f72d2a134ad59f759">&#9670;&#160;</a></span>s2n_config_get_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_get_ctx </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the user defined context from the <code>s2n_config</code> object. The context is set by calling <a class="el" href="s2n_8h.html#a99493d7c1f33f5f5390dd0fdd95ab431">s2n_config_set_ctx()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being accessed </td></tr>
    <tr><td class="paramname">ctx</td><td>A pointer to the user defined ctx. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="ad1465c4cb90a8956a26a32aa8e53808c" name="ad1465c4cb90a8956a26a32aa8e53808c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1465c4cb90a8956a26a32aa8e53808c">&#9670;&#160;</a></span>s2n_config_get_supported_groups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_get_supported_groups </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>groups_count_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>groups_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Retrieves the list of supported groups configured by the security policy associated with <code>config</code>.</p>
<p >The retrieved list of groups will contain all of the supported groups for a security policy that are compatible with the build of s2n-tls. For instance, PQ kem groups that are not supported by the linked libcrypto will not be written. Otherwise, all of the supported groups configured for the security policy will be written. This API can be used with the <a class="el" href="s2n_8h.html#a68a751eb59517406db2439a88e94d8d1">s2n_client_hello_get_supported_groups()</a> API as a means of comparing compatibility between a client and server.</p>
<p >IANA values for each of the supported groups are written to the provided <code>groups</code> array, and <code>groups_count</code> is set to the number of written supported groups.</p>
<p ><code>groups_count_max</code> should be set to the maximum capacity of the <code>groups</code> array. If <code>groups_count_max</code> is less than the number of supported groups configured by the security policy, this function will error.</p>
<p >Note that this API retrieves only the groups from a security policy that are available to negotiate via the supported groups extension, and does not return TLS 1.2 PQ kem groups that are negotiated in the supported PQ kem parameters extension.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>A pointer to the s2n_config object from which the supported groups will be retrieved. </td></tr>
    <tr><td class="paramname">groups</td><td>The array to populate with the supported groups. </td></tr>
    <tr><td class="paramname">groups_count_max</td><td>The maximum number of supported groups that can fit in the <code>groups</code> array. </td></tr>
    <tr><td class="paramname">groups_count</td><td>Set to the number of supported groups written to <code>groups</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure. </dd></dl>

</div>
</div>
<a id="a3f99ca29318603bee3d3e1fb713e4577" name="a3f99ca29318603bee3d3e1fb713e4577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f99ca29318603bee3d3e1fb713e4577">&#9670;&#160;</a></span>s2n_config_load_system_certs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_load_system_certs </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Loads default system certificates into the trust store.</p>
<p ><code><a class="el" href="s2n_8h.html#ab4ea3e214391965d7edb0efa6bf1e4cd">s2n_config_new_minimal()</a></code> doesn't load default system certificates into the config's trust store by default. If <code>config</code> was created with <code>s2n_config_new_minimal</code>, this function can be used to load system certificates into the trust store.</p>
<dl class="section note"><dt>Note</dt><dd>This API will error if called on a config that has already loaded system certificates into its trust store, which includes all configs created with <code><a class="el" href="s2n_8h.html#aae4a525b68ba7bd181a27de9ea2fcd1a">s2n_config_new()</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="aae4a525b68ba7bd181a27de9ea2fcd1a" name="aae4a525b68ba7bd181a27de9ea2fcd1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4a525b68ba7bd181a27de9ea2fcd1a">&#9670;&#160;</a></span>s2n_config_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> struct s2n_config * s2n_config_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new s2n_config object. This object can (and should) be associated with many connection objects.</p>
<p >The returned config will be initialized with default system certificates in its trust store.</p>
<p >The returned config should be freed with <code><a class="el" href="s2n_8h.html#a414a19458d8ce45e039dbd01e7dd67f4">s2n_config_free()</a></code> after it's no longer in use by any connection.</p>
<dl class="section return"><dt>Returns</dt><dd>A new configuration object suitable for configuring connections and associating certs and keys. </dd></dl>

</div>
</div>
<a id="ab4ea3e214391965d7edb0efa6bf1e4cd" name="ab4ea3e214391965d7edb0efa6bf1e4cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ea3e214391965d7edb0efa6bf1e4cd">&#9670;&#160;</a></span>s2n_config_new_minimal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> struct s2n_config * s2n_config_new_minimal </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new s2n_config object with minimal default options.</p>
<p >This function has better performance than <code><a class="el" href="s2n_8h.html#aae4a525b68ba7bd181a27de9ea2fcd1a">s2n_config_new()</a></code> because it does not load default system certificates into the trust store by default. To add system certificates to this config, call <code><a class="el" href="s2n_8h.html#a3f99ca29318603bee3d3e1fb713e4577">s2n_config_load_system_certs()</a></code>.</p>
<p >The returned config should be freed with <code><a class="el" href="s2n_8h.html#a414a19458d8ce45e039dbd01e7dd67f4">s2n_config_free()</a></code> after it's no longer in use by any connection.</p>
<dl class="section return"><dt>Returns</dt><dd>A new configuration object suitable for configuring connections and associating certs and keys. </dd></dl>

</div>
</div>
<a id="a83b61c7518ebbb88cf0c481dd3412b48" name="a83b61c7518ebbb88cf0c481dd3412b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b61c7518ebbb88cf0c481dd3412b48">&#9670;&#160;</a></span>s2n_config_require_ticket_forward_secrecy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_require_ticket_forward_secrecy </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Requires that session tickets are only used when forward secrecy is possible.</p>
<p >Restricts session resumption to TLS1.3, as the tickets used in TLS1.2 resumption are not forward secret. Clients should not expect to receive new session tickets and servers will not send new session tickets when TLS1.2 is negotiated and ticket forward secrecy is required.</p>
<dl class="section note"><dt>Note</dt><dd>The default behavior is that forward secrecy is not required.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The config object being updated </td></tr>
    <tr><td class="paramname">enabled</td><td>Indicates if forward secrecy is required or not on tickets </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a0f2ab042e1f9dea7ff02b3746dc16188" name="a0f2ab042e1f9dea7ff02b3746dc16188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f2ab042e1f9dea7ff02b3746dc16188">&#9670;&#160;</a></span>s2n_config_send_max_fragment_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_send_max_fragment_length </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a1976b2365808c341247e03131c2423ac">s2n_max_frag_len</a>&#160;</td>
          <td class="paramname"><em>mfl_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Allows the caller to set a TLS Maximum Fragment Length extension that will be used to fragment outgoing messages. s2n-tls currently does not reject fragments larger than the configured maximum when in server mode. The TLS negotiated maximum fragment length overrides the preference set by the <code>s2n_connection_prefer_throughput</code> and <code>s2n_connection_prefer_low_latency</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Some TLS implementations do not respect their peer's max fragment length extension.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">mfl_code</td><td>The selected MFL size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a59b3ba39cc1b929310270d4fe5ac1b02" name="a59b3ba39cc1b929310270d4fe5ac1b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b3ba39cc1b929310270d4fe5ac1b02">&#9670;&#160;</a></span>s2n_config_set_alert_behavior()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_alert_behavior </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#ab8d3f62254ec4211d47cc841dea76abd">s2n_alert_behavior</a>&#160;</td>
          <td class="paramname"><em>alert_behavior</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the config's alert behavior based on the <code>s2n_alert_behavior</code> enum.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">alert_behavior</td><td>The desired alert behavior. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a28fc426b41fe7e3349f562bb7883448e" name="a28fc426b41fe7e3349f562bb7883448e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28fc426b41fe7e3349f562bb7883448e">&#9670;&#160;</a></span>s2n_config_set_async_pkey_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_async_pkey_callback </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a2ecb6a187e25469c3fd108a873da1cce">s2n_async_pkey_fn</a>&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets up the callback to invoke when private key operations occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Config to set the callback </td></tr>
    <tr><td class="paramname">fn</td><td>The function that should be called for each private key operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7bfdfd2bd7b564f720709482ac4736dc" name="a7bfdfd2bd7b564f720709482ac4736dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bfdfd2bd7b564f720709482ac4736dc">&#9670;&#160;</a></span>s2n_config_set_async_pkey_validation_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_async_pkey_validation_mode </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a3b0e141e39d6fd9782af697513933995">s2n_async_pkey_validation_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Configures whether or not s2n-tls will perform potentially expensive validation of the results of a private key operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Config to set the validation mode for </td></tr>
    <tr><td class="paramname">mode</td><td>What level of validation to perform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83593aa49ca8a9cff7c2678acf943f4f" name="a83593aa49ca8a9cff7c2678acf943f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83593aa49ca8a9cff7c2678acf943f4f">&#9670;&#160;</a></span>s2n_config_set_cache_delete_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_cache_delete_callback </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#acbf7cc68d71dd8d960ff078b3a21792f">s2n_cache_delete_callback</a>&#160;</td>
          <td class="paramname"><em>cache_delete_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Allows the caller to set a callback function that will be used to delete SSL session data from a cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">cache_delete_callback</td><td>The cache delete callback function. </td></tr>
    <tr><td class="paramname">data</td><td>An opaque context pointer that the callback will be invoked with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a0ab40fa6123aedb83f5fab8ef1922fa9" name="a0ab40fa6123aedb83f5fab8ef1922fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ab40fa6123aedb83f5fab8ef1922fa9">&#9670;&#160;</a></span>s2n_config_set_cache_retrieve_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_cache_retrieve_callback </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a57b0785656f577b764e1c3c3844368d4">s2n_cache_retrieve_callback</a>&#160;</td>
          <td class="paramname"><em>cache_retrieve_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Allows the caller to set a callback function that will be used to retrieve SSL session data from a cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">cache_retrieve_callback</td><td>The cache retrieve callback function. </td></tr>
    <tr><td class="paramname">data</td><td>An opaque context pointer that the callback will be invoked with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a8c1c9c7110d9e3c18d48fbf8ee655318" name="a8c1c9c7110d9e3c18d48fbf8ee655318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1c9c7110d9e3c18d48fbf8ee655318">&#9670;&#160;</a></span>s2n_config_set_cache_store_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_cache_store_callback </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#ad9764b7cab647999aad58c339a42e90e">s2n_cache_store_callback</a>&#160;</td>
          <td class="paramname"><em>cache_store_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Allows the caller to set a callback function that will be used to store SSL session data in a cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">cache_store_callback</td><td>The cache store callback function. </td></tr>
    <tr><td class="paramname">data</td><td>An opaque context pointer that the callback will be invoked with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a30d021a10ad7183c995d6d2a65926272" name="a30d021a10ad7183c995d6d2a65926272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d021a10ad7183c995d6d2a65926272">&#9670;&#160;</a></span>s2n_config_set_cert_chain_and_key_defaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_cert_chain_and_key_defaults </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct s2n_cert_chain_and_key **&#160;</td>
          <td class="paramname"><em>cert_key_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_cert_key_pairs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Explicitly sets certificate chain and private key pairs to be used as defaults for each auth method (key type). A "default" certificate is used when there is not an SNI match with any other configured certificate.</p>
<p >Only one certificate can be set as the default per auth method (one RSA default, one ECDSA default, etc.). All previous default certificates will be cleared and re-set when this API is called.</p>
<p >This API is called for a specific <code>s2n_config</code> object. s2n-tls will attempt to automatically choose default certificates for each auth method (key type) based on the order that <code>s2n_cert_chain_and_key</code> are added to the <code>s2n_config</code> using one of the APIs listed above. <code>s2n_config_set_cert_chain_and_key_defaults</code> can be called at any time; s2n-tls will clear defaults and no longer attempt to automatically choose any default certificates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">cert_key_pairs</td><td>An array of certificate chain and private key handles </td></tr>
    <tr><td class="paramname">num_cert_key_pairs</td><td>The amount of handles in cert_key_pairs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a08f2dab761bbb4b3eec095763a28f7af" name="a08f2dab761bbb4b3eec095763a28f7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f2dab761bbb4b3eec095763a28f7af">&#9670;&#160;</a></span>s2n_config_set_cert_tiebreak_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_cert_tiebreak_callback </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a0363fdf570a5451facfa12eb0a679586">s2n_cert_tiebreak_callback</a>&#160;</td>
          <td class="paramname"><em>cert_tiebreak_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the <code>s2n_cert_tiebreak_callback</code> for resolving domain name conflicts. If no callback is set, the first certificate added for a domain name will always be preferred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">cert_tiebreak_cb</td><td>The pointer to the certificate tiebreak function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="affff244d7ed6f3b8d1f885df1b307f4e" name="affff244d7ed6f3b8d1f885df1b307f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affff244d7ed6f3b8d1f885df1b307f4e">&#9670;&#160;</a></span>s2n_config_set_check_stapled_ocsp_response()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_check_stapled_ocsp_response </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>check_ocsp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Toggles whether or not to validate stapled OCSP responses.</p>
<p >1 means OCSP responses will be validated when they are encountered, while 0 means this step will be skipped.</p>
<p >The default value is 1 if the underlying libCrypto implementation supports OCSP.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">check_ocsp</td><td>The desired OCSP response check configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a3afea5198d804621399d8fd9875cfdb0" name="a3afea5198d804621399d8fd9875cfdb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3afea5198d804621399d8fd9875cfdb0">&#9670;&#160;</a></span>s2n_config_set_cipher_preferences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_cipher_preferences </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the security policy that includes the cipher/kem/signature/ecc preferences and protocol version.</p>
<p >See the <a href="https://github.com/aws/s2n-tls/blob/main/docs/usage-guide">USAGE-GUIDE.md</a> for how to use security policies. </p>

</div>
</div>
<a id="a923be772e04a448409f93d4cf234ca33" name="a923be772e04a448409f93d4cf234ca33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923be772e04a448409f93d4cf234ca33">&#9670;&#160;</a></span>s2n_config_set_client_auth_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_client_auth_type </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a8757c094681bb8151329c8dc067106b8">s2n_cert_auth_type</a>&#160;</td>
          <td class="paramname"><em>client_auth_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets whether or not a Client Certificate should be required to complete the TLS Connection.</p>
<p >If this is set to <code>S2N_CERT_AUTH_OPTIONAL</code> the server will request a client certificate but allow the client to not provide one. Rejecting a client certificate when using <code>S2N_CERT_AUTH_OPTIONAL</code> will terminate the handshake.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>A pointer to a s2n_config object </td></tr>
    <tr><td class="paramname">client_auth_type</td><td>The client auth policy for the connection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="aaae98777bf82821ce4d1989d224a50c0" name="aaae98777bf82821ce4d1989d224a50c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae98777bf82821ce4d1989d224a50c0">&#9670;&#160;</a></span>s2n_config_set_client_hello_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_client_hello_cb </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a0451dcbf88fdf09f36a82cab4d25d44e">s2n_client_hello_fn</a>&#160;</td>
          <td class="paramname"><em>client_hello_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Allows the caller to set a callback function that will be called after ClientHello was parsed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">client_hello_callback</td><td>The client hello callback function </td></tr>
    <tr><td class="paramname">ctx</td><td>A pointer to a user defined context that the Client Hello callback will be invoked with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a0e005fa4cdf98cbf99dac6f592f7b39b" name="a0e005fa4cdf98cbf99dac6f592f7b39b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e005fa4cdf98cbf99dac6f592f7b39b">&#9670;&#160;</a></span>s2n_config_set_client_hello_cb_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_client_hello_cb_mode </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a7aa9070e5b2de634b4a6fcb2bde98e68">s2n_client_hello_cb_mode</a>&#160;</td>
          <td class="paramname"><em>cb_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the callback execution mode.</p>
<p >See s2n_client_hello_cb_mode for each mode's behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">cb_mode</td><td>The desired callback mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a604de45a27044a3eeb7c58575604bcee" name="a604de45a27044a3eeb7c58575604bcee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a604de45a27044a3eeb7c58575604bcee">&#9670;&#160;</a></span>s2n_config_set_ct_support_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_ct_support_level </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#ae8f37b612310a3594b019b88ebd8fa1a">s2n_ct_support_level</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the Certificate Transparency Support level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">level</td><td>The desired Certificate Transparency Support configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a99493d7c1f33f5f5390dd0fdd95ab431" name="a99493d7c1f33f5f5390dd0fdd95ab431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99493d7c1f33f5f5390dd0fdd95ab431">&#9670;&#160;</a></span>s2n_config_set_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_ctx </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets user defined context on the <code>s2n_config</code> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">ctx</td><td>A pointer to the user defined ctx. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="ac39414e78d4a383df083b8a6924ee495" name="ac39414e78d4a383df083b8a6924ee495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39414e78d4a383df083b8a6924ee495">&#9670;&#160;</a></span>s2n_config_set_early_data_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_early_data_cb </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#adebd93e979b53293c106cc2a44f79607">s2n_early_data_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set a callback to accept or reject early data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>A pointer to the connection config </td></tr>
    <tr><td class="paramname">cb</td><td>A pointer to the implementation of the callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A POSIX error signal. If successful, the callback was set. </dd></dl>

</div>
</div>
<a id="a2250c2b461d0814c4e5dd969d0f372f1" name="a2250c2b461d0814c4e5dd969d0f372f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2250c2b461d0814c4e5dd969d0f372f1">&#9670;&#160;</a></span>s2n_config_set_extension_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_extension_data </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#ab2b46f61765da5529f931afb8dd8a1f8">s2n_tls_extension_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the extension data in the <code>s2n_config</code> object for the specified extension. This method will clear any existing data that is set. If the data and length parameters are set to NULL, no new data is set in the <code>s2n_config</code> object, effectively clearing existing data.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Use s2n_cert_chain_and_key_set_ocsp_data and s2n_cert_chain_and_key_set_sct_list instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">type</td><td>The extension type </td></tr>
    <tr><td class="paramname">data</td><td>Data for the extension </td></tr>
    <tr><td class="paramname">length</td><td>Length of the <code>data</code> buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4fbabcd7bc5673315db4c4570d451d02" name="a4fbabcd7bc5673315db4c4570d451d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fbabcd7bc5673315db4c4570d451d02">&#9670;&#160;</a></span>s2n_config_set_initial_ticket_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_initial_ticket_count </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the initial number of session tickets to send after a &gt;=TLS1.3 handshake. The default value is one ticket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>A pointer to the config object. </td></tr>
    <tr><td class="paramname">num</td><td>The number of session tickets that will be sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a0d8f3979557fc3d58b8618230bc5c332" name="a0d8f3979557fc3d58b8618230bc5c332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d8f3979557fc3d58b8618230bc5c332">&#9670;&#160;</a></span>s2n_config_set_key_log_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_key_log_cb </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a4ad3e5f171648fb7fb55109d623cb13e">s2n_key_log_fn</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets a key logging callback on the provided config</p>
<p >THIS SHOULD BE USED FOR DEBUGGING PURPOSES ONLY!</p>
<p >Setting this function enables configurations to emit secrets in the <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format">NSS Key Log Format</a></p>
<h1><a class="anchor" id="autotoc_md18"></a>
Safety</h1>
<ul>
<li><code>callback</code> MUST cast <code>ctx</code> into the same type of pointer that was originally created</li>
<li><code>ctx</code> MUST live for at least as long as it is set on the config</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Config to set the callback </td></tr>
    <tr><td class="paramname">callback</td><td>The function that should be called for each secret log entry </td></tr>
    <tr><td class="paramname">ctx</td><td>The context to be passed when the callback is called </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6202daaf67fa8e47cb8d79071ff5066" name="aa6202daaf67fa8e47cb8d79071ff5066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6202daaf67fa8e47cb8d79071ff5066">&#9670;&#160;</a></span>s2n_config_set_max_blinding_delay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_max_blinding_delay </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>seconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Configures the maximum blinding delay enforced after errors.</p>
<p >Blinding protects your application from timing side channel attacks like Lucky13. While s2n-tls implements other, more specific mitigations for known timing side channels, blinding is important as a defense against currently unknown or unreported timing attacks.</p>
<p >Setting a maximum delay lower than the recommended default (30s) will make timing attacks against your application easier. The lower you set the delay, the fewer requests and less total time an attacker will require to execute an attack. If you must lower the delay for reasons such as client timeouts, then you should choose the highest value practically possible to limit your risk.</p>
<p >If you lower the blinding delay, you should also consider implementing monitoring and filtering to detect and reject suspicious traffic that could be gathering timing information from a potential side channel. Timing attacks usually involve repeatedly triggering TLS errors.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do NOT set a lower blinding delay unless you understand the risks and have other mitigations for timing side channels in place.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This delay needs to be set lower than any timeouts, such as your TCP socket timeout.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The config object being updated. </td></tr>
    <tr><td class="paramname">seconds</td><td>The maximum number of seconds that s2n-tls will delay for in the event of a sensitive error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure. </dd></dl>

</div>
</div>
<a id="adbe1f248fa4510df373890a70f6f39b9" name="adbe1f248fa4510df373890a70f6f39b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe1f248fa4510df373890a70f6f39b9">&#9670;&#160;</a></span>s2n_config_set_max_cert_chain_depth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_max_cert_chain_depth </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the maximum allowed depth of a cert chain used for X509 validation. The default value is</p><ol type="1">
<li>If this limit is exceeded, validation will fail if <a class="el" href="s2n_8h.html#aa9d89fb59987254fe2546881d172be18">s2n_config_disable_x509_verification()</a> has not been called. 0 is an illegal value and will return an error. 1 means only a root certificate will be used.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">max_depth</td><td>The number of allowed certificates in the certificate chain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a7b11c2ca37417cf74606870711a08741" name="a7b11c2ca37417cf74606870711a08741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b11c2ca37417cf74606870711a08741">&#9670;&#160;</a></span>s2n_config_set_monotonic_clock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_monotonic_clock </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a0cfed8d65c0e2c33cf666ee90eb06a7e">s2n_clock_time_nanoseconds</a>&#160;</td>
          <td class="paramname"><em>clock_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Allows the caller to set a callback function that will be used to get monotonic time. The monotonic time is the time since an arbitrary, unspecified point. Unlike wall clock time, it MUST never move backwards.</p>
<p >s2n-tls uses this clock for timers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">clock_fn</td><td>The monotonic time callback function </td></tr>
    <tr><td class="paramname">ctx</td><td>An opaque pointer that the callback will be invoked with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a983bbc96f19466c51529501c63004910" name="a983bbc96f19466c51529501c63004910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983bbc96f19466c51529501c63004910">&#9670;&#160;</a></span>s2n_config_set_protocol_preferences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_protocol_preferences </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>protocols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>protocol_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the application protocol preferences on an <code>s2n_config</code> object. <code>protocols</code> is a list in order of preference, with most preferred protocol first, and of length <code>protocol_count</code>.</p>
<p >When acting as an <code>S2N_CLIENT</code> the protocol list is included in the Client Hello message as the ALPN extension.</p>
<p >As an <code>S2N_SERVER</code>, the list is used to negotiate a mutual application protocol with the client. After the negotiation for the connection has completed, the agreed upon protocol can be retrieved with <a class="el" href="s2n_8h.html#ae53faa26669e258afff875d45140f14e">s2n_get_application_protocol()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">protocols</td><td>The list of preferred protocols, in order of preference </td></tr>
    <tr><td class="paramname">protocol_count</td><td>The size of the protocols list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a201761e445dcdb7d65e0e1ebf893c7d9" name="a201761e445dcdb7d65e0e1ebf893c7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a201761e445dcdb7d65e0e1ebf893c7d9">&#9670;&#160;</a></span>s2n_config_set_psk_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_psk_mode </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a3c5d0a0d8a1092a60dd0f50cdf969524">s2n_psk_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the PSK mode on the s2n config object. The supported PSK modes are listed in the enum <code>s2n_psk_mode</code> above.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>A pointer to the s2n_config object being updated. </td></tr>
    <tr><td class="paramname">mode</td><td>The PSK mode to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb61d1a41a53e3de04988b5ea0109953" name="aeb61d1a41a53e3de04988b5ea0109953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb61d1a41a53e3de04988b5ea0109953">&#9670;&#160;</a></span>s2n_config_set_psk_selection_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_psk_selection_callback </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a37dd435b749a207739d64b22837a9ba1">s2n_psk_selection_callback</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the callback to select the matching PSK. If this callback is not set s2n-tls uses a default PSK selection logic that selects the first matching server PSK.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>A pointer to the s2n_config object. </td></tr>
    <tr><td class="paramname">cb</td><td>The function that should be called when the callback is triggered. </td></tr>
    <tr><td class="paramname">context</td><td>A pointer to a context for the caller to pass state to the callback, if needed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a873c1969c18fdf8663a9b593e62b9460" name="a873c1969c18fdf8663a9b593e62b9460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873c1969c18fdf8663a9b593e62b9460">&#9670;&#160;</a></span>s2n_config_set_recv_multi_record()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_recv_multi_record </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Enable or disable receiving of multiple TLS records in a single s2n_recv call</p>
<p >By default, s2n-tls returns from <a class="el" href="s2n_8h.html#a3b67ff058796d4c6c6caddfd0f10274e">s2n_recv()</a> after reading a single TLS record. Enabling receiving of multiple records will instead cause <a class="el" href="s2n_8h.html#a3b67ff058796d4c6c6caddfd0f10274e">s2n_recv()</a> to attempt to read until the application-provided output buffer is full. This may be more efficient, especially if larger receive buffers are used.</p>
<dl class="section note"><dt>Note</dt><dd>If this option is enabled with blocking IO, the call to <a class="el" href="s2n_8h.html#a3b67ff058796d4c6c6caddfd0f10274e">s2n_recv()</a> will not return until either the application-provided output buffer is full or the peer closes the connection. This may lead to unintentionally long waits if the peer does not send enough data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">enabled</td><td>Set to <code>true</code> if multiple record receive is to be enabled; <code>false</code> to disable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a6de9d794c410474e9851880bd4914025" name="a6de9d794c410474e9851880bd4914025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de9d794c410474e9851880bd4914025">&#9670;&#160;</a></span>s2n_config_set_send_buffer_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_send_buffer_size </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set a custom send buffer size.</p>
<p >This buffer is used to stage records for sending. By default, enough memory is allocated to hold a single record of the maximum size configured for the connection. With the default fragment size, that is about 8K bytes.</p>
<p >Less memory can be allocated for the send buffer, but this will result in smaller, more fragmented records and increased overhead. While the absolute minimum size required is 1034 bytes, at least 2K bytes is recommended for reasonable record sizes.</p>
<p >More memory can be allocated for the send buffer. This will result in s2n-tls buffering multiple records before sending them, reducing system write calls. At least 17K bytes is recommended for this use case, or at least 35K bytes if larger fragment sizes are used via <code><a class="el" href="s2n_8h.html#a11c72914bfc09a9174b6a7b019e5aa5c">s2n_connection_prefer_throughput()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">size</td><td>The desired custom buffer size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a619375c69a21184f06fb22d7810c3831" name="a619375c69a21184f06fb22d7810c3831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619375c69a21184f06fb22d7810c3831">&#9670;&#160;</a></span>s2n_config_set_serialization_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_serialization_version </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s2n_serialization_version&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set what version to use when serializing connections</p>
<p >A version is required to serialize connections. Versioning ensures that all features negotiated during the handshake will be available wherever the connection is deserialized. Applications may need to update this version to pick up new features, since versioning may disable newer TLS features to ensure compatibility.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>A pointer to the config object. </td></tr>
    <tr><td class="paramname">version</td><td>The requested version. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success, S2N_FAILURE on error. </dd></dl>

</div>
</div>
<a id="abf75ca7a2f3ac18b228e8b3509c35895" name="abf75ca7a2f3ac18b228e8b3509c35895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf75ca7a2f3ac18b228e8b3509c35895">&#9670;&#160;</a></span>s2n_config_set_server_max_early_data_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_server_max_early_data_size </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_early_data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the maximum bytes of early data the server will accept.</p>
<p >The default maximum is 0. If the maximum is 0, the server rejects all early data requests. The config maximum can be overridden by the connection maximum or the maximum on an external pre-shared key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>A pointer to the config </td></tr>
    <tr><td class="paramname">max_early_data_size</td><td>The maximum early data that the server will accept </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A POSIX error signal. If successful, the maximum early data size was updated. </dd></dl>

</div>
</div>
<a id="a746edac026a2d26f4a09ff4183beb9e9" name="a746edac026a2d26f4a09ff4183beb9e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746edac026a2d26f4a09ff4183beb9e9">&#9670;&#160;</a></span>s2n_config_set_session_cache_onoff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_session_cache_onoff </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Enable or disable session caching.</p>
<dl class="section note"><dt>Note</dt><dd>Session caching will not be turned on unless all three session cache callbacks are set prior to calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">enabled</td><td>The configuration object being updated. Set to 1 to enable. Set to 0 to disable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a012950b0841dad53f4ce0b7bd9892757" name="a012950b0841dad53f4ce0b7bd9892757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012950b0841dad53f4ce0b7bd9892757">&#9670;&#160;</a></span>s2n_config_set_session_state_lifetime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_session_state_lifetime </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifetime_in_secs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the lifetime of the cached session state. The default value is 15 hours.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">lifetime_in_secs</td><td>The desired lifetime of the session state in seconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="aa823f209bd1e3b046887a5ed32b685a5" name="aa823f209bd1e3b046887a5ed32b685a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa823f209bd1e3b046887a5ed32b685a5">&#9670;&#160;</a></span>s2n_config_set_session_ticket_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_session_ticket_cb </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a87a1b430e8782d95dc60efbec7cd6118">s2n_session_ticket_fn</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets a session ticket callback to be called when a client receives a new session ticket.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Safety</h1>
<p ><code>callback</code> MUST cast <code>ctx</code> into the same type of pointer that was originally created. <code>ctx</code> MUST be valid for the lifetime of the config, or until a different context is set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>A pointer to the config object. </td></tr>
    <tr><td class="paramname">callback</td><td>The function that should be called when the callback is triggered. </td></tr>
    <tr><td class="paramname">ctx</td><td>The context to be passed when the callback is called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb17f02a0b6a6c74e3db143c7c3d62a6" name="afb17f02a0b6a6c74e3db143c7c3d62a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb17f02a0b6a6c74e3db143c7c3d62a6">&#9670;&#160;</a></span>s2n_config_set_session_tickets_onoff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_session_tickets_onoff </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Enable or disable session resumption using session ticket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">enabled</td><td>The configuration object being updated. Set to 1 to enable. Set to 0 to disable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a380252ebdd5077b7436a23c2cf7458c0" name="a380252ebdd5077b7436a23c2cf7458c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380252ebdd5077b7436a23c2cf7458c0">&#9670;&#160;</a></span>s2n_config_set_status_request_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_status_request_type </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a7d38e45340d223d0100a2d4bc0526635">s2n_status_request_type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets up a connection to request the certificate status of a peer during an SSL handshake. If set to S2N_STATUS_REQUEST_NONE, no status request is made.</p>
<dl class="section note"><dt>Note</dt><dd>SHA-1 is the only supported hash algorithm for the <code>certID</code> field. This is different from the hash algorithm used for the OCSP signature. See <a href="https://datatracker.ietf.org/doc/html/rfc6960#section-4.1.1">RFC 6960</a> for more information. While unlikely to be the case, if support for a different hash algorithm is required, the s2n-tls validation can be disabled with <code><a class="el" href="s2n_8h.html#affff244d7ed6f3b8d1f885df1b307f4e">s2n_config_set_check_stapled_ocsp_response()</a></code> and the response can be retrieved for manual validation with <code><a class="el" href="s2n_8h.html#a8ad8092d7c616efd40bb0145c4895f1f">s2n_connection_get_ocsp_response()</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">type</td><td>The desired request status type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a59be9ad4336811d9910f07bb74edb364" name="a59be9ad4336811d9910f07bb74edb364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59be9ad4336811d9910f07bb74edb364">&#9670;&#160;</a></span>s2n_config_set_ticket_decrypt_key_lifetime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_ticket_decrypt_key_lifetime </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifetime_in_secs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets how long a session ticket key will be in a state where it can used just for decryption of already assigned tickets on the server side. Once decrypted, the session will resume and the server will issue a new session ticket encrypted using a key in encrypt-decrypt state.</p>
<dl class="section note"><dt>Note</dt><dd>The default value is 13 hours. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">lifetime_in_secs</td><td>The desired lifetime of decrypting and encrypting tickets in seconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a54ac0a3900f9784804dff154ea404f83" name="a54ac0a3900f9784804dff154ea404f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ac0a3900f9784804dff154ea404f83">&#9670;&#160;</a></span>s2n_config_set_ticket_encrypt_decrypt_key_lifetime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_ticket_encrypt_decrypt_key_lifetime </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifetime_in_secs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets how long a session ticket key will be in a state where it can be used for both encryption and decryption of tickets on the server side.</p>
<dl class="section note"><dt>Note</dt><dd>The default value is 2 hours. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">lifetime_in_secs</td><td>The desired lifetime of decrypting and encrypting tickets in seconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a85545629ce095ed44de580592eecf50e" name="a85545629ce095ed44de580592eecf50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85545629ce095ed44de580592eecf50e">&#9670;&#160;</a></span>s2n_config_set_verification_ca_location()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_verification_ca_location </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ca_pem_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ca_dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds to the trust store from a CA file or directory containing trusted certificates.</p>
<p >When configs are created with <code><a class="el" href="s2n_8h.html#aae4a525b68ba7bd181a27de9ea2fcd1a">s2n_config_new()</a></code>, the trust store is initialized with default system certificates. To completely override these certificates, call <code><a class="el" href="s2n_8h.html#af7e2759066521827269d56d4da063f7b">s2n_config_wipe_trust_store()</a></code> before calling this function.</p>
<dl class="section note"><dt>Note</dt><dd>The trust store will be initialized with the common locations for the host operating system by default.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This API uses the PEM parsing implementation from the linked libcrypto. This implementation will typically make a best-effort attempt to parse all of the certificates in the provided file or directory. This permissive approach may silently ignore malformed certificates, leading to possible connection failures if a certificate was expected to exist in the trust store but was skipped while parsing. As such, this API should only be used on PEMs that are known to be well-formed and parsable with the linked libcrypto, such as the system trust store. For all other PEMs, <code><a class="el" href="s2n_8h.html#a1de5c0b7a1029ee248947835d4e170bc">s2n_config_add_pem_to_trust_store()</a></code> should be used instead, which parses more strictly.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">ca_pem_filename</td><td>A string for the file path of the CA PEM file. </td></tr>
    <tr><td class="paramname">ca_dir</td><td>A string for the directory of the CA PEM files. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="aa0729c67323dbe0604e6b55f82afb6f6" name="aa0729c67323dbe0604e6b55f82afb6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0729c67323dbe0604e6b55f82afb6f6">&#9670;&#160;</a></span>s2n_config_set_verify_after_sign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_verify_after_sign </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s2n_verify_after_sign&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Toggle whether generated signatures are verified before being sent.</p>
<p >Although signatures produced by the underlying libcrypto should always be valid, hardware faults, bugs in the signing implementation, or other uncommon factors can cause unexpected mistakes in the final signatures. Because these mistakes can leak information about the private key, applications with low trust in their hardware or libcrypto may want to verify signatures before sending them.</p>
<p >However, this feature will significantly impact handshake latency. Additionally, most libcrypto implementations already check for common errors in signatures. </p>

</div>
</div>
<a id="a079022d5c18f4ffd64c1c6dedb3bbc66" name="a079022d5c18f4ffd64c1c6dedb3bbc66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a079022d5c18f4ffd64c1c6dedb3bbc66">&#9670;&#160;</a></span>s2n_config_set_verify_host_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_verify_host_callback </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a8aa56850695a02753f726ea9860ec383">s2n_verify_host_fn</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the callback to use for verifying that a hostname from an X.509 certificate is trusted.</p>
<p >The default behavior is to require that the hostname match the server name set with <a class="el" href="s2n_8h.html#af5c2488271997ea0b0b21d3937e612f6">s2n_set_server_name()</a>. This will likely lead to all client certificates being rejected, so the callback will need to be overriden when using client authentication.</p>
<p >This change will be inherited by s2n_connections using this config. If a separate callback for different connections using the same config is desired, see <a class="el" href="s2n_8h.html#ad39f5c65f5c201d7af140baff29a02eb">s2n_connection_set_verify_host_callback()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">data</td><td>A user supplied opaque context to pass back to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a43c8ab4e5c773d3e0464ed41cc51bd5d" name="a43c8ab4e5c773d3e0464ed41cc51bd5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c8ab4e5c773d3e0464ed41cc51bd5d">&#9670;&#160;</a></span>s2n_config_set_wall_clock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_set_wall_clock </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a0cfed8d65c0e2c33cf666ee90eb06a7e">s2n_clock_time_nanoseconds</a>&#160;</td>
          <td class="paramname"><em>clock_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Allows the caller to set a callback function that will be used to get the system time. The time returned should be the number of nanoseconds since the Unix epoch (Midnight, January 1st, 1970).</p>
<p >s2n-tls uses this clock for timestamps.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
    <tr><td class="paramname">clock_fn</td><td>The wall clock time callback function </td></tr>
    <tr><td class="paramname">ctx</td><td>An opaque pointer that the callback will be invoked with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="af7e2759066521827269d56d4da063f7b" name="af7e2759066521827269d56d4da063f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e2759066521827269d56d4da063f7b">&#9670;&#160;</a></span>s2n_config_wipe_trust_store()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_config_wipe_trust_store </td>
          <td>(</td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Clears the trust store of all certificates.</p>
<p >When configs are created with <code><a class="el" href="s2n_8h.html#aae4a525b68ba7bd181a27de9ea2fcd1a">s2n_config_new()</a></code>, the trust store is initialized with default system certificates. To completely override these certificates, call this function before functions like <code><a class="el" href="s2n_8h.html#a85545629ce095ed44de580592eecf50e">s2n_config_set_verification_ca_location()</a></code> or <code><a class="el" href="s2n_8h.html#a1de5c0b7a1029ee248947835d4e170bc">s2n_config_add_pem_to_trust_store()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration object being updated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a0c9e5abc313209df9dea126fb44f750a" name="a0c9e5abc313209df9dea126fb44f750a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c9e5abc313209df9dea126fb44f750a">&#9670;&#160;</a></span>s2n_connection_add_new_tickets_to_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_add_new_tickets_to_send </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Increases the number of session tickets to send after a &gt;=TLS1.3 handshake.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the connection object. </td></tr>
    <tr><td class="paramname">num</td><td>The number of additional session tickets to send. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a1cbf7aa3eb0834357994ea902d6c4847" name="a1cbf7aa3eb0834357994ea902d6c4847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cbf7aa3eb0834357994ea902d6c4847">&#9670;&#160;</a></span>s2n_connection_append_protocol_preference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_append_protocol_preference </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>protocol_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Appends the provided application protocol to the preference list</p>
<p >The data provided in <code>protocol</code> parameter will be copied into an internal buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The connection object being updated </td></tr>
    <tr><td class="paramname">protocol</td><td>A pointer to a slice of bytes </td></tr>
    <tr><td class="paramname">protocol_len</td><td>The length of bytes that should be read from <code>protocol</code>. Note: this value cannot be 0, otherwise an error will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a01514c68f7b4d7926f6435e4beec8de0" name="a01514c68f7b4d7926f6435e4beec8de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01514c68f7b4d7926f6435e4beec8de0">&#9670;&#160;</a></span>s2n_connection_append_psk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_append_psk </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct s2n_psk *&#160;</td>
          <td class="paramname"><em>psk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Appends a PSK object to the list of PSKs supported by the s2n connection. If a PSK with a duplicate identity is found, an error is returned and the PSK is not added to the list. Note that a copy of <code>psk</code> is stored on the connection. The user is still responsible for freeing the memory associated with <code>psk</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object that contains the list of PSKs supported. </td></tr>
    <tr><td class="paramname">psk</td><td>A pointer to the <code>s2n_psk</code> object to be appended to the list of PSKs on the s2n connection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a249408b5a39897276524176bb951dba5" name="a249408b5a39897276524176bb951dba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a249408b5a39897276524176bb951dba5">&#9670;&#160;</a></span>s2n_connection_client_cert_used()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_client_cert_used </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Check if Client Auth was used for a connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the connection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the handshake completed and Client Auth was negotiated during then handshake. </dd></dl>

</div>
</div>
<a id="a79859a910905832157c08251d1a76888" name="a79859a910905832157c08251d1a76888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79859a910905832157c08251d1a76888">&#9670;&#160;</a></span>s2n_connection_deserialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_deserialize </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>buffer_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Deserializes the provided buffer into the <code>s2n_connection</code> parameter.</p>
<dl class="section warning"><dt>Warning</dt><dd>s2n-tls DOES NOT check the integrity of the provided buffer. s2n-tls may successfully deserialize a corrupted buffer which WILL cause a connection failure when attempting to resume sending/receiving encrypted data. To avoid this, it is recommended to MAC and encrypt the serialized connection before sending it off-box and deserializing it.</dd>
<dd>
Only a minimal amount of information about the original TLS connection is serialized. Therefore, after deserialization, the connection will behave like a new <code>s2n_connection</code> from the <code><a class="el" href="s2n_8h.html#a58005ebdc3e4caf6b6f40321bbc5b1e5">s2n_connection_new()</a></code> call, except that it can read/write encrypted data from a peer. Any desired config-level or connection-level configuration will need to be re-applied to the deserialized connection. For this same reason none of the connection getters will return useful information about the original connection after deserialization. Any information about the original connection needs to be retrieved before serialization.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the connection object. Should be a new s2n_connection object. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer where the serialized connection will be read from. </td></tr>
    <tr><td class="paramname">buffer_length</td><td>Maximum amount of data that can be read from the buffer parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success, S2N_FAILURE on error. </dd></dl>

</div>
</div>
<a id="a9c7664ec2fe4c694148ad303f4229f94" name="a9c7664ec2fe4c694148ad303f4229f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7664ec2fe4c694148ad303f4229f94">&#9670;&#160;</a></span>s2n_connection_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_free </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Frees the memory associated with an s2n_connection handle. The handle is considered invalid after <code>s2n_connection_free</code> is used. <a class="el" href="s2n_8h.html#ae42c3c7b37df666c2b3e6a53c1ea5f76">s2n_connection_wipe()</a> does not need to be called prior to this function. <code>s2n_connection_free</code> performs its own wipe of sensitive data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. -1 on failure </dd></dl>

</div>
</div>
<a id="a0dcc520aac12e66149d83859e8e62d92" name="a0dcc520aac12e66149d83859e8e62d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dcc520aac12e66149d83859e8e62d92">&#9670;&#160;</a></span>s2n_connection_free_handshake()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_free_handshake </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Wipes and releases buffers and memory allocated during the TLS handshake.</p>
<dl class="section note"><dt>Note</dt><dd>This function should be called after the handshake is successfully negotiated and logging or recording of handshake data is complete.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a67f52395125df9876ebf18964f582883" name="a67f52395125df9876ebf18964f582883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f52395125df9876ebf18964f582883">&#9670;&#160;</a></span>s2n_connection_get_actual_protocol_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_actual_protocol_version </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Access the protocol version selected for the connection.</p>
<dl class="section note"><dt>Note</dt><dd>The return value corresponds to the macros defined as S2N_SSLv2, S2N_SSLv3, S2N_TLS10, S2N_TLS11, S2N_TLS12, and S2N_TLS13.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the connection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The protocol version actually negotiated by the handshake </dd></dl>

</div>
</div>
<a id="a5612a3161a2dcb4dd7fcb04aaf8845a8" name="a5612a3161a2dcb4dd7fcb04aaf8845a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5612a3161a2dcb4dd7fcb04aaf8845a8">&#9670;&#160;</a></span>s2n_connection_get_alert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_alert </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Function to get the alert that caused a connection to close. s2n-tls considers all TLS alerts fatal and shuts down a connection whenever one is received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n connection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The TLS alert code that caused a connection to be shut down </dd></dl>

</div>
</div>
<a id="a762ffd38a013dba0c9266dd90b91183b" name="a762ffd38a013dba0c9266dd90b91183b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762ffd38a013dba0c9266dd90b91183b">&#9670;&#160;</a></span>s2n_connection_get_certificate_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_certificate_match </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a388f87d7049392968cf4fba3bdefa197">s2n_cert_sni_match</a> *&#160;</td>
          <td class="paramname"><em>match_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A function that provides insight into whether or not the server was able to send a certificate that partially or completely matched the client's SNI extension.</p>
<dl class="section note"><dt>Note</dt><dd>This function can be used as a metric in a failed connection as long as the failure occurs after certificate selection.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the connection </td></tr>
    <tr><td class="paramname">cert_match</td><td>An enum indicating whether or not the server found a certificate that matched the client's SNI extension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure. </dd></dl>

</div>
</div>
<a id="aed6c509e7ec18b2a9ddb47e3e595b565" name="aed6c509e7ec18b2a9ddb47e3e595b565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6c509e7ec18b2a9ddb47e3e595b565">&#9670;&#160;</a></span>s2n_connection_get_cipher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> const char * s2n_connection_get_cipher </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A function that provides a human readable string of the cipher suite that was chosen for a connection.</p>
<dl class="section warning"><dt>Warning</dt><dd>The string "TLS_NULL_WITH_NULL_NULL" is returned before the TLS handshake has been performed. This does not mean that the ciphersuite "TLS_NULL_WITH_NULL_NULL" will be used by the connection, it is merely being used as a placeholder.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is only accurate after the TLS handshake.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the connection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string indicating the cipher suite negotiated by s2n in OpenSSL format. </dd></dl>

</div>
</div>
<a id="abc11d4e901bae3b322a5a3bc5dc9a5d1" name="abc11d4e901bae3b322a5a3bc5dc9a5d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc11d4e901bae3b322a5a3bc5dc9a5d1">&#9670;&#160;</a></span>s2n_connection_get_cipher_iana_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_cipher_iana_value </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the IANA value for the connection's negotiated cipher suite.</p>
<p >The value is returned in the form of <code>first,second</code>, in order to closely match the values defined in the <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#table-tls-parameters-4">IANA Registry</a>. For example if the connection's negotiated cipher suite is <code>TLS_AES_128_GCM_SHA256</code>, which is registered as <code>0x13,0x01</code>, then <code>first = 0x13</code> and <code>second = 0x01</code>.</p>
<p >This method will only succeed after the cipher suite has been negotiated with the peer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the connection being read </td></tr>
    <tr><td class="paramname">first</td><td>A pointer to a single byte, which will be updated with the first byte in the registered IANA value. </td></tr>
    <tr><td class="paramname">second</td><td>A pointer to a single byte, which will be updated with the second byte in the registered IANA value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A POSIX error signal. If an error was returned, the values contained in <code>first</code> and <code>second</code> should be considered invalid. </dd></dl>

</div>
</div>
<a id="aa6dbfb5892b7cc52a759422ab478a77c" name="aa6dbfb5892b7cc52a759422ab478a77c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6dbfb5892b7cc52a759422ab478a77c">&#9670;&#160;</a></span>s2n_connection_get_client_auth_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_client_auth_type </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a8757c094681bb8151329c8dc067106b8">s2n_cert_auth_type</a> *&#160;</td>
          <td class="paramname"><em>client_auth_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets Client Certificate authentication method the s2n_connection object is using.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object </td></tr>
    <tr><td class="paramname">client_auth_type</td><td>A pointer to a client auth policy. This will be updated to the s2n_connection value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a5f2758d2962e1ad05b369452d5a6a674" name="a5f2758d2962e1ad05b369452d5a6a674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f2758d2962e1ad05b369452d5a6a674">&#9670;&#160;</a></span>s2n_connection_get_client_cert_chain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_client_cert_chain </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t **&#160;</td>
          <td class="paramname"><em>der_cert_chain_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>cert_chain_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the raw certificate chain received from the client.</p>
<p >The retrieved certificate chain has the format described by the TLS 1.2 RFC: <a href="https://datatracker.ietf.org/doc/html/rfc5246#section-7.4.2">https://datatracker.ietf.org/doc/html/rfc5246#section-7.4.2</a>. Each certificate is a DER-encoded ASN.1 X.509, prepended by a 3 byte network-endian length value. Note that this format is used regardless of the connection's protocol version.</p>
<dl class="section warning"><dt>Warning</dt><dd>The buffer pointed to by <code>cert_chain_out</code> shares its lifetime with the s2n_connection object.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object </td></tr>
    <tr><td class="paramname">cert_chain_out</td><td>A pointer that's set to the client certificate chain. </td></tr>
    <tr><td class="paramname">cert_chain_len</td><td>A pointer that's set to the size of the <code>cert_chain_out</code> buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="ac0c64d96b5b9a4cb600a22157d6743e3" name="ac0c64d96b5b9a4cb600a22157d6743e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c64d96b5b9a4cb600a22157d6743e3">&#9670;&#160;</a></span>s2n_connection_get_client_hello()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> struct s2n_client_hello * s2n_connection_get_client_hello </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the Client Hello from a s2n_connection.</p>
<p >Earliest point during the handshake when this structure is available for use is in the client_hello_callback (see <a class="el" href="s2n_8h.html#aaae98777bf82821ce4d1989d224a50c0">s2n_config_set_client_hello_cb()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The connection object containing the client hello </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the s2n_client_hello structure holding the client hello message sent by the client during the handshake. NULL is returned if a Client Hello has not yet been received and parsed. </dd></dl>

</div>
</div>
<a id="ad2a608603c7dbe9203a7c8f8b63ee1b8" name="ad2a608603c7dbe9203a7c8f8b63ee1b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a608603c7dbe9203a7c8f8b63ee1b8">&#9670;&#160;</a></span>s2n_connection_get_client_hello_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_client_hello_version </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Access the client hello protocol version for the connection.</p>
<dl class="section note"><dt>Note</dt><dd>The return value corresponds to the macros defined as S2N_SSLv2, S2N_SSLv3, S2N_TLS10, S2N_TLS11, S2N_TLS12, and S2N_TLS13.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the connection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The protocol version used to send the initial client hello message. </dd></dl>

</div>
</div>
<a id="aafa9d12438841f2a47907b244eccd7cc" name="aafa9d12438841f2a47907b244eccd7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa9d12438841f2a47907b244eccd7cc">&#9670;&#160;</a></span>s2n_connection_get_client_protocol_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_client_protocol_version </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Access the protocol version supported by the client.</p>
<dl class="section note"><dt>Note</dt><dd>The return value corresponds to the macros defined as S2N_SSLv2, S2N_SSLv3, S2N_TLS10, S2N_TLS11, S2N_TLS12, and S2N_TLS13.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the connection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the highest protocol version supported by the client </dd></dl>

</div>
</div>
<a id="ad2a3ba62c0029c622de99c7edbddfb9c" name="ad2a3ba62c0029c622de99c7edbddfb9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a3ba62c0029c622de99c7edbddfb9c">&#9670;&#160;</a></span>s2n_connection_get_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> void * s2n_connection_get_ctx </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets user defined context from a <code>s2n_connection</code> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The connection object that contains the desired context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af64cc57ff39c25444877136f6e3558c1" name="af64cc57ff39c25444877136f6e3558c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64cc57ff39c25444877136f6e3558c1">&#9670;&#160;</a></span>s2n_connection_get_curve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> const char * s2n_connection_get_curve </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Function to get the human readable elliptic curve name for the connection.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Use <code>s2n_connection_get_key_exchange_group</code> instead</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n connection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string indicating the elliptic curve used during ECDHE key exchange. The string "NONE" is returned if no curve was used. </dd></dl>

</div>
</div>
<a id="ab8a2a372d2d13cef62357473b7fea568" name="ab8a2a372d2d13cef62357473b7fea568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a2a372d2d13cef62357473b7fea568">&#9670;&#160;</a></span>s2n_connection_get_delay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> uint64_t s2n_connection_get_delay </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Query the connection object for the configured blinding delay. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The connection object being updated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of nanoseconds an application using self-service blinding should pause before calling close() or shutdown(). </dd></dl>

</div>
</div>
<a id="abeb0431ad129a9c41ae80205f4020974" name="abeb0431ad129a9c41ae80205f4020974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb0431ad129a9c41ae80205f4020974">&#9670;&#160;</a></span>s2n_connection_get_early_data_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_early_data_status </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#ab11b47e128bd2074bf486e1e47864033">s2n_early_data_status_t</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reports the current state of early data for a connection.</p>
<p >See <code>s2n_early_data_status_t</code> for all possible states.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the connection </td></tr>
    <tr><td class="paramname">status</td><td>A pointer which will be set to the current early data status </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A POSIX error signal. </dd></dl>

</div>
</div>
<a id="a8649c4ff89e91c0a2278c139bc033449" name="a8649c4ff89e91c0a2278c139bc033449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8649c4ff89e91c0a2278c139bc033449">&#9670;&#160;</a></span>s2n_connection_get_handshake_type_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> const char * s2n_connection_get_handshake_type_name </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Function to return the last TLS handshake type that was processed. The returned format is a human readable string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n connection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A human-readable handshake type name, e.g. "NEGOTIATED|FULL_HANDSHAKE|PERFECT_FORWARD_SECRECY" </dd></dl>

</div>
</div>
<a id="a1c116afc860c9273c32126617881f4b5" name="a1c116afc860c9273c32126617881f4b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c116afc860c9273c32126617881f4b5">&#9670;&#160;</a></span>s2n_connection_get_kem_group_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> const char * s2n_connection_get_kem_group_name </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Function to get the human readable KEM group name for the connection.</p>
<dl class="section note"><dt>Note</dt><dd>PQ key exchange will not occur if the connection is &lt; TLS1.3 or the configured security policy has no KEM groups on it. It also will not occur if the peer does not support PQ key exchange. In these instances this function will return "NONE".</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n connection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A human readable string for the KEM group. Returns "NONE" if no PQ key exchange occurred. </dd></dl>

</div>
</div>
<a id="a5c26b7b10e7ed39a6cd3aeaab0f4066a" name="a5c26b7b10e7ed39a6cd3aeaab0f4066a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c26b7b10e7ed39a6cd3aeaab0f4066a">&#9670;&#160;</a></span>s2n_connection_get_kem_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> const char * s2n_connection_get_kem_name </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Function to get the human readable KEM name for the connection.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>This function was previously used to retrieve the negotiated PQ group in TLS 1.2. PQ key exchange in TLS1.2 was experimental and is now deprecated. Use <a class="el" href="s2n_8h.html#a1c116afc860c9273c32126617881f4b5">s2n_connection_get_kem_group_name()</a> to retrieve the PQ TLS 1.3 Group name.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n connection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A human readable string for the KEM group. If there is no KEM configured returns "NONE" </dd></dl>

</div>
</div>
<a id="ad782d2e72055ddfc4ce8768c163f4c6b" name="ad782d2e72055ddfc4ce8768c163f4c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad782d2e72055ddfc4ce8768c163f4c6b">&#9670;&#160;</a></span>s2n_connection_get_key_exchange_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_key_exchange_group </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>group_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Function to get the human readable key exchange group name for the connection, for example: <code>secp521r1</code> or <code>SecP256r1MLKEM768</code>. If an EC curve or KEM was not negotiated, S2N_FAILURE will be returned.</p>
<dl class="section note"><dt>Note</dt><dd>This function replaces <code>s2n_connection_get_curve</code> and <code>s2n_connection_get_kem_group_name</code>, returning the named group regardless if a hybrid PQ group was negotiated or not.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n connection </td></tr>
    <tr><td class="paramname">group_name</td><td>A pointer that will be set to point to a const char* containing the group name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success, S2N_FAILURE otherwise. <code>group_name</code> will be set on success. </dd></dl>

</div>
</div>
<a id="af3c50354985713f6dff1d4ae87fbc442" name="af3c50354985713f6dff1d4ae87fbc442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c50354985713f6dff1d4ae87fbc442">&#9670;&#160;</a></span>s2n_connection_get_last_message_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> const char * s2n_connection_get_last_message_name </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Function to return the last TLS message that was processed. The returned format is a human readable string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n connection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last message name in the TLS state machine, e.g. "SERVER_HELLO", "APPLICATION_DATA". </dd></dl>

</div>
</div>
<a id="ad34a96dd1e2cae7dd2da4812576a65fc" name="ad34a96dd1e2cae7dd2da4812576a65fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad34a96dd1e2cae7dd2da4812576a65fc">&#9670;&#160;</a></span>s2n_connection_get_master_secret()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_master_secret </td>
          <td>(</td>
          <td class="paramtype">const struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>secret_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Provides access to the TLS master secret.</p>
<p >This is a dangerous method and should not be used unless absolutely necessary. Mishandling the master secret can compromise both the current connection and any past or future connections that use the same master secret due to session resumption.</p>
<p >This method is only supported for older TLS versions, and will report an S2N_ERR_INVALID_STATE usage error if called for a TLS1.3 connection. TLS1.3 includes a new key schedule that derives independent secrets from the master secret for specific purposes, such as separate traffic, session ticket, and exporter secrets. Using the master secret directly circumvents that security feature, reducing the security of the protocol.</p>
<p >If you need cryptographic material tied to the current TLS session, consider <code>s2n_connection_tls_exporter</code> instead. Although s2n_connection_tls_exporter currently only supports TLS1.3, there is also an RFC that describes exporters for older TLS versions: <a href="https://datatracker.ietf.org/doc/html/rfc5705">https://datatracker.ietf.org/doc/html/rfc5705</a> Using the master secret as-is or defining your own exporter is dangerous.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the connection. </td></tr>
    <tr><td class="paramname">secret_bytes</td><td>Memory to copy the master secret into. The secret is always 48 bytes long. </td></tr>
    <tr><td class="paramname">max_size</td><td>The size of the memory available at <code>secret_bytes</code>. Must be at least 48 bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success, S2N_FAILURE otherwise. <code>secret_bytes</code> will be set on success. </dd></dl>

</div>
</div>
<a id="a8e112c9be28b49af8d257b1c3a6a2764" name="a8e112c9be28b49af8d257b1c3a6a2764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e112c9be28b49af8d257b1c3a6a2764">&#9670;&#160;</a></span>s2n_connection_get_max_early_data_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_max_early_data_size </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>max_early_data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reports the maximum size of the early data allowed by a connection.</p>
<p >This is the maximum amount of early data that can ever be sent and received for a connection. It is not affected by the actual status of the early data, so can be non-zero even if early data is rejected or not requested.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the connection </td></tr>
    <tr><td class="paramname">max_early_data_size</td><td>A pointer which will be set to the maximum early data allowed by <code>conn</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A POSIX error signal. </dd></dl>

</div>
</div>
<a id="a0abfdc17f22aa1a1b7bbca9fde0d5319" name="a0abfdc17f22aa1a1b7bbca9fde0d5319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0abfdc17f22aa1a1b7bbca9fde0d5319">&#9670;&#160;</a></span>s2n_connection_get_negotiated_psk_identity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_negotiated_psk_identity </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_identity_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the negotiated PSK identity from the s2n connection object. If the negotiated PSK does not exist, the PSK identity will not be obtained and no error will be returned. Prior to this API call, use <code>s2n_connection_get_negotiated_psk_identity_length</code> to determine if a negotiated PSK exists or not.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Safety</h1>
<p >The negotiated PSK identity will be copied into the identity buffer on success. Therefore, the identity buffer must have enough memory to fit the identity length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object. </td></tr>
    <tr><td class="paramname">identity</td><td>The negotiated PSK identity obtained from the s2n_connection object. </td></tr>
    <tr><td class="paramname">max_identity_length</td><td>The maximum length for the PSK identity. If the negotiated psk_identity length is greater than this <code>max_identity_length</code> value an error will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a414d9640d38a2f55cc2025d8fb6f9061" name="a414d9640d38a2f55cc2025d8fb6f9061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a414d9640d38a2f55cc2025d8fb6f9061">&#9670;&#160;</a></span>s2n_connection_get_negotiated_psk_identity_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_negotiated_psk_identity_length </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>identity_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the negotiated PSK identity length from the s2n connection object. The negotiated PSK refers to the chosen PSK by the server to be used for the connection.</p>
<p >This API can be used to determine if the negotiated PSK exists. If negotiated PSK exists a call to this API returns a value greater than zero. If the negotiated PSK does not exist, the value <code>0</code> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object that successfully negotiated a PSK connection. </td></tr>
    <tr><td class="paramname">identity_length</td><td>The length of the negotiated PSK identity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ad8092d7c616efd40bb0145c4895f1f" name="a8ad8092d7c616efd40bb0145c4895f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad8092d7c616efd40bb0145c4895f1f">&#9670;&#160;</a></span>s2n_connection_get_ocsp_response()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> const uint8_t * s2n_connection_get_ocsp_response </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Query the connection for a buffer containing the OCSP response.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The connection object being queried </td></tr>
    <tr><td class="paramname">length</td><td>A pointer that is set to the certificate transparency response buffer's size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the OCSP response sent by a server during the handshake. If no status response is received, NULL is returned. </dd></dl>

</div>
</div>
<a id="aea94d670ca52905adad56cb3e2ef187b" name="aea94d670ca52905adad56cb3e2ef187b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea94d670ca52905adad56cb3e2ef187b">&#9670;&#160;</a></span>s2n_connection_get_peer_cert_chain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_peer_cert_chain </td>
          <td>(</td>
          <td class="paramtype">const struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct s2n_cert_chain_and_key *&#160;</td>
          <td class="paramname"><em>cert_chain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the validated peer certificate chain as a <code>s2n_cert_chain_and_key</code> opaque object.</p>
<p >The <code>s2n_cert_chain_and_key</code> parameter must be allocated by the caller using the <code>s2n_cert_chain_and_key_new</code> API prior to this function call and must be empty. To free the memory associated with the <code>s2n_cert_chain_and_key</code> object use the <code>s2n_cert_chain_and_key_free</code> API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object being read. </td></tr>
    <tr><td class="paramname">cert_chain</td><td>The returned validated peer certificate chain <code>cert_chain</code> retrieved from the s2n connection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17cb0e4df7046226139408cfe7b3688d" name="a17cb0e4df7046226139408cfe7b3688d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17cb0e4df7046226139408cfe7b3688d">&#9670;&#160;</a></span>s2n_connection_get_read_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_read_fd </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>readfd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the assigned file descriptor for the read channel of an s2n connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n connection </td></tr>
    <tr><td class="paramname">readfd</td><td>pointer to place the used file descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a7efe33feb364f2215a2df1bc88fcaac1" name="a7efe33feb364f2215a2df1bc88fcaac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7efe33feb364f2215a2df1bc88fcaac1">&#9670;&#160;</a></span>s2n_connection_get_remaining_early_data_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_remaining_early_data_size </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>allowed_early_data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reports the remaining size of the early data allowed by a connection.</p>
<p >If early data was rejected or not requested, the remaining early data size is 0. Otherwise, the remaining early data size is the maximum early data allowed by the connection, minus the early data sent or received so far.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the connection </td></tr>
    <tr><td class="paramname">allowed_early_data_size</td><td>A pointer which will be set to the remaining early data currently allowed by <code>conn</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A POSIX error signal. </dd></dl>

</div>
</div>
<a id="a5dd40473bc173fc0cfedc43fe469732d" name="a5dd40473bc173fc0cfedc43fe469732d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd40473bc173fc0cfedc43fe469732d">&#9670;&#160;</a></span>s2n_connection_get_sct_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> const uint8_t * s2n_connection_get_sct_list </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Query the connection for a buffer containing the Certificate Transparency response.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The connection object being queried </td></tr>
    <tr><td class="paramname">length</td><td>A pointer that is set to the certificate transparency response buffer's size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the certificate transparency response buffer. </dd></dl>

</div>
</div>
<a id="aa2ec12d27f27f757ddfaf2bcadc9956a" name="aa2ec12d27f27f757ddfaf2bcadc9956a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ec12d27f27f757ddfaf2bcadc9956a">&#9670;&#160;</a></span>s2n_connection_get_selected_cert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> struct s2n_cert_chain_and_key * s2n_connection_get_selected_cert </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the certificate used during the TLS handshake</p>
<ul>
<li>If <code>conn</code> is a server connection, the certificate selected will depend on the ServerName sent by the client and supported ciphers.</li>
<li>If <code>conn</code> is a client connection, the certificate sent in response to a CertificateRequest message is returned. Currently s2n-tls supports loading only one certificate in client mode. Note that not all TLS endpoints will request a certificate.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if the certificate selection phase of the handshake has not completed or if a certificate was not requested by the peer </dd></dl>

</div>
</div>
<a id="a3201f28508d383632996dcc861a521d4" name="a3201f28508d383632996dcc861a521d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3201f28508d383632996dcc861a521d4">&#9670;&#160;</a></span>s2n_connection_get_selected_client_cert_digest_algorithm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_selected_client_cert_digest_algorithm </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a08eccb21b18130aef8c19a288801f379">s2n_tls_hash_algorithm</a> *&#160;</td>
          <td class="paramname"><em>chosen_alg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the client certificate's digest algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object </td></tr>
    <tr><td class="paramname">chosen_alg</td><td>A pointer to a s2n_tls_hash_algorithm object. This is an output parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE if bad parameters are received. </dd></dl>

</div>
</div>
<a id="a4311542818a2f029b2f157803949faa4" name="a4311542818a2f029b2f157803949faa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4311542818a2f029b2f157803949faa4">&#9670;&#160;</a></span>s2n_connection_get_selected_client_cert_signature_algorithm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_selected_client_cert_signature_algorithm </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a9812997751f63ac2d5ab70852792a689">s2n_tls_signature_algorithm</a> *&#160;</td>
          <td class="paramname"><em>chosen_alg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the client certificate's signature algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object </td></tr>
    <tr><td class="paramname">chosen_alg</td><td>A pointer to a s2n_tls_signature_algorithm object. This is an output parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE if bad parameters are received. </dd></dl>

</div>
</div>
<a id="a13c882c74b21dd1e36d40e5b2a5beea5" name="a13c882c74b21dd1e36d40e5b2a5beea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c882c74b21dd1e36d40e5b2a5beea5">&#9670;&#160;</a></span>s2n_connection_get_selected_digest_algorithm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_selected_digest_algorithm </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a08eccb21b18130aef8c19a288801f379">s2n_tls_hash_algorithm</a> *&#160;</td>
          <td class="paramname"><em>chosen_alg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the connection's selected digest algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object </td></tr>
    <tr><td class="paramname">chosen_alg</td><td>A pointer to a s2n_tls_hash_algorithm object. This is an output parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE if bad parameters are received. </dd></dl>

</div>
</div>
<a id="a37352212fe3ebb17b9bf8ca9cc9ea7fd" name="a37352212fe3ebb17b9bf8ca9cc9ea7fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37352212fe3ebb17b9bf8ca9cc9ea7fd">&#9670;&#160;</a></span>s2n_connection_get_selected_signature_algorithm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_selected_signature_algorithm </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a9812997751f63ac2d5ab70852792a689">s2n_tls_signature_algorithm</a> *&#160;</td>
          <td class="paramname"><em>chosen_alg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the connection's selected signature algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object </td></tr>
    <tr><td class="paramname">chosen_alg</td><td>A pointer to a s2n_tls_signature_algorithm object. This is an output parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE if bad parameters are received. </dd></dl>

</div>
</div>
<a id="a7db32818718bceb6f927a07cd068eb45" name="a7db32818718bceb6f927a07cd068eb45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db32818718bceb6f927a07cd068eb45">&#9670;&#160;</a></span>s2n_connection_get_server_protocol_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_server_protocol_version </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Access the protocol version supported by the server.</p>
<dl class="section note"><dt>Note</dt><dd>The return value corresponds to the macros defined as S2N_SSLv2, S2N_SSLv3, S2N_TLS10, S2N_TLS11, S2N_TLS12, and S2N_TLS13.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the connection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the highest protocol version supported by the server </dd></dl>

</div>
</div>
<a id="ae1ed55a367727eea8e041630406bb144" name="ae1ed55a367727eea8e041630406bb144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ed55a367727eea8e041630406bb144">&#9670;&#160;</a></span>s2n_connection_get_session()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_session </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Serializes the session state from connection and copies into the <code>session</code> buffer and returns the number of copied bytes</p>
<dl class="section note"><dt>Note</dt><dd>This function is not recommended for &gt; TLS 1.2 because in TLS1.3 servers can send multiple session tickets and this function will only return the most recently received ticket.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object </td></tr>
    <tr><td class="paramname">session</td><td>A pointer to a buffer of size <code>max_length</code> </td></tr>
    <tr><td class="paramname">max_length</td><td>The size of the <code>session</code> buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of copied bytes </dd></dl>

</div>
</div>
<a id="a242a28fb68a8903416dc0de77ff4b1bc" name="a242a28fb68a8903416dc0de77ff4b1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242a28fb68a8903416dc0de77ff4b1bc">&#9670;&#160;</a></span>s2n_connection_get_session_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_session_id </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>session_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the latest session id from the connection, copies it into the <code>session_id</code> buffer, and returns the number of copied bytes.</p>
<p >The session id may change between s2n receiving the ClientHello and sending the ServerHello, but this function will always describe the latest session id.</p>
<p >See <a class="el" href="s2n_8h.html#ae86458717edccfb2f58b86f3991af1a9">s2n_client_hello_get_session_id()</a> to get the session id as it was sent by the client in the ClientHello message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object </td></tr>
    <tr><td class="paramname">session_id</td><td>A pointer to a buffer of size <code>max_length</code> </td></tr>
    <tr><td class="paramname">max_length</td><td>The size of the <code>session_id</code> buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of copied bytes. </dd></dl>

</div>
</div>
<a id="acc34cfe4ca708912cf9309cc98000c08" name="acc34cfe4ca708912cf9309cc98000c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc34cfe4ca708912cf9309cc98000c08">&#9670;&#160;</a></span>s2n_connection_get_session_id_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_session_id_length </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the latest session id's length from the connection.</p>
<p >Use this to query the session id size before copying it into a buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The latest session id length from the connection. Session id length will be 0 for TLS versions &gt;= TLS1.3 as stateful session resumption has not yet been implemented in TLS1.3. </dd></dl>

</div>
</div>
<a id="ab0b2840c308f1e6d9a5a47631e9991c2" name="ab0b2840c308f1e6d9a5a47631e9991c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b2840c308f1e6d9a5a47631e9991c2">&#9670;&#160;</a></span>s2n_connection_get_session_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_session_length </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Use this to query the serialized session state size before copying it into a buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes needed to store serialized session state </dd></dl>

</div>
</div>
<a id="a8a8f58e34e1fc8eb35f7ac8fe55123a5" name="a8a8f58e34e1fc8eb35f7ac8fe55123a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a8f58e34e1fc8eb35f7ac8fe55123a5">&#9670;&#160;</a></span>s2n_connection_get_session_ticket_lifetime_hint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_session_ticket_lifetime_hint </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Retrieves a hint from the server indicating how long this ticket's lifetime is.</p>
<dl class="section note"><dt>Note</dt><dd>This function is not recommended for &gt; TLS 1.2 because in TLS1.3 servers can send multiple session tickets and this function will only return the most recently received ticket lifetime hint.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The session ticket lifetime hint in seconds from the server or -1 when session ticket was not used for resumption. </dd></dl>

</div>
</div>
<a id="af42c827e46b894c9cbf5ed309852526f" name="af42c827e46b894c9cbf5ed309852526f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42c827e46b894c9cbf5ed309852526f">&#9670;&#160;</a></span>s2n_connection_get_signature_scheme()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_signature_scheme </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>scheme_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the human readable signature scheme for the connection.</p>
<p >This method will return:</p><ol type="1">
<li>The IANA "description" for the negotiated signature scheme. For example, rsa_pss_rsae_sha384 or ecdsa_secp256r1_sha256.</li>
<li>An unofficial description, if the server signature did not use an official IANA signature scheme. This description will take the form "legacy_&lt;signature_algorithm&gt;_&lt;hash_algorithm&gt;". For example, legacy_rsa_sha224 or legacy_ecdsa_sha256.</li>
<li>"none", if the handshake did not include a server signature. This may happen if session resumption or RSA key exchange are used.</li>
</ol>
<p >If the connection has not yet performed a handshake, this method will error.</p>
<p >A note on unofficial descriptions: If TLS1.2 or earlier is negotiated, an official IANA signature scheme may not be chosen. Before TLS1.3, a combination of "signature algorithm" and "hash algorithm" were used instead of signature schemes. Not all combinations were later assigned to official signature schemes.</p>
<p >A note on ECDSA signature schemes: TLS1.3 and TLS1.2 ECDSA "signature schemes" share the same IANA value. However, this method assigns them different descriptions because the TLS1.3 versions (like ecdsa_secp256r1_sha256) imply specific curves, while the TLS1.2 versions (like legacy_ecdsa_sha256) do not.</p>
<p >IANA signature schemes: <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-signaturescheme">https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-signaturescheme</a> IANA signature algorithms: <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-16">https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-16</a> IANA hash algorithms: <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-18">https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-18</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n connection </td></tr>
    <tr><td class="paramname">group_name</td><td>A pointer that will be set to the signature scheme name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success, S2N_FAILURE otherwise. </dd></dl>

</div>
</div>
<a id="a56a28dbd00b5ac7941f6620241bad9ba" name="a56a28dbd00b5ac7941f6620241bad9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56a28dbd00b5ac7941f6620241bad9ba">&#9670;&#160;</a></span>s2n_connection_get_tickets_sent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_tickets_sent </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the number of session tickets issued by the server.</p>
<p >In TLS1.3, this number can be up to the limit configured by s2n_config_set_initial_ticket_count and s2n_connection_add_new_tickets_to_send. In earlier versions of TLS, this number will be either 0 or 1.</p>
<p >This method only works for server connections.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the connection object. </td></tr>
    <tr><td class="paramname">num</td><td>The number of additional session tickets sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a3815d469b844d5eb192a04998bd12944" name="a3815d469b844d5eb192a04998bd12944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3815d469b844d5eb192a04998bd12944">&#9670;&#160;</a></span>s2n_connection_get_wire_bytes_in()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> uint64_t s2n_connection_get_wire_bytes_in </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the number of bytes the connection has received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the connection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return the number of bytes received by s2n-tls "on the wire" </dd></dl>

</div>
</div>
<a id="a134ca7e01d14f709750ef420440b238b" name="a134ca7e01d14f709750ef420440b238b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134ca7e01d14f709750ef420440b238b">&#9670;&#160;</a></span>s2n_connection_get_wire_bytes_out()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> uint64_t s2n_connection_get_wire_bytes_out </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the number of bytes the connection has transmitted out.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the connection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return the number of bytes transmitted out by s2n-tls "on the wire" </dd></dl>

</div>
</div>
<a id="a91b65b19decd099dfe580306c04cb210" name="a91b65b19decd099dfe580306c04cb210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b65b19decd099dfe580306c04cb210">&#9670;&#160;</a></span>s2n_connection_get_write_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_get_write_fd </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>writefd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the assigned file descriptor for the write channel of an s2n connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n connection </td></tr>
    <tr><td class="paramname">writefd</td><td>pointer to place the used file descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="addfbc4fdc9d191bb4d6d9040762b208b" name="addfbc4fdc9d191bb4d6d9040762b208b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfbc4fdc9d191bb4d6d9040762b208b">&#9670;&#160;</a></span>s2n_connection_is_ocsp_stapled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_is_ocsp_stapled </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Check if the connection is OCSP stapled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if OCSP response was sent (if connection is in S2N_SERVER mode) or received (if connection is in S2N_CLIENT mode) during handshake, otherwise it returns 0. </dd></dl>

</div>
</div>
<a id="ae3657d081eb0957f87d93391653eb20c" name="ae3657d081eb0957f87d93391653eb20c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3657d081eb0957f87d93391653eb20c">&#9670;&#160;</a></span>s2n_connection_is_session_resumed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_is_session_resumed </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Check if the connection was resumed from an earlier handshake.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns 1 if the handshake was abbreviated, otherwise returns 0 </dd></dl>

</div>
</div>
<a id="ac396d45fe79efa2142be8cf491dfdbeb" name="ac396d45fe79efa2142be8cf491dfdbeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac396d45fe79efa2142be8cf491dfdbeb">&#9670;&#160;</a></span>s2n_connection_is_valid_for_cipher_preferences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_is_valid_for_cipher_preferences </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Function to check if the cipher used by current connection is supported by the current cipher preferences. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n connection </td></tr>
    <tr><td class="paramname">version</td><td>A string representing the security policy to check against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the connection satisfies the cipher suite. 0 if the connection does not satisfy the cipher suite. -1 if there is an error. </dd></dl>

</div>
</div>
<a id="a58005ebdc3e4caf6b6f40321bbc5b1e5" name="a58005ebdc3e4caf6b6f40321bbc5b1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58005ebdc3e4caf6b6f40321bbc5b1e5">&#9670;&#160;</a></span>s2n_connection_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> struct s2n_connection * s2n_connection_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a77a64e3b657f90d221c5faf99c643cdb">s2n_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new connection object. Each s2n-tls SSL/TLS connection uses one of these objects. These connection objects can be operated on by up to two threads at a time, one sender and one receiver, but neither sending nor receiving are atomic, so if these objects are being called by multiple sender or receiver threads, you must perform your own locking to ensure that only one sender or receiver is active at a time.</p>
<p >The <code>mode</code> parameters specifies if the caller is a server, or is a client. Connections objects are re-usable across many connections, and should be re-used (to avoid deallocating and allocating memory). You should wipe connections immediately after use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The desired connection type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A s2n_connection handle </dd></dl>

</div>
</div>
<a id="a9b4fafb7e9b8277f408af0ad17ab6e19" name="a9b4fafb7e9b8277f408af0ad17ab6e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b4fafb7e9b8277f408af0ad17ab6e19">&#9670;&#160;</a></span>s2n_connection_prefer_low_latency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_prefer_low_latency </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Change the behavior of s2n-tls when sending data to prefer low latency.</p>
<p >Connections preferring low latency will be encrypted using small record sizes that can be decrypted sooner by the recipient.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The connection object being updated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a11c72914bfc09a9174b6a7b019e5aa5c" name="a11c72914bfc09a9174b6a7b019e5aa5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c72914bfc09a9174b6a7b019e5aa5c">&#9670;&#160;</a></span>s2n_connection_prefer_throughput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_prefer_throughput </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Change the behavior of s2n-tls when sending data to prefer high throughput.</p>
<p >Connections preferring throughput will use large record sizes that minimize overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The connection object being updated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="af86a8545d176c7097fa036649968a896" name="af86a8545d176c7097fa036649968a896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af86a8545d176c7097fa036649968a896">&#9670;&#160;</a></span>s2n_connection_release_buffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_release_buffers </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Wipes and free the <code>in</code> and <code>out</code> buffers associated with a connection.</p>
<dl class="section note"><dt>Note</dt><dd>This function may be called when a connection is in keep-alive or idle state to reduce memory overhead of long lived connections.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a824fed871df4202b6bd5428ee791f660" name="a824fed871df4202b6bd5428ee791f660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824fed871df4202b6bd5428ee791f660">&#9670;&#160;</a></span>s2n_connection_request_key_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_request_key_update </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#aa8ab6cd4a526f781116a39bd16bab9ba">s2n_peer_key_update</a>&#160;</td>
          <td class="paramname"><em>peer_request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Signals the connection to do a key_update at the next possible opportunity. Note that the resulting key update message will not be sent until <code>s2n_send</code> is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The connection object to trigger the key update on. </td></tr>
    <tr><td class="paramname">peer_request</td><td>Indicates if a key update should also be requested of the peer. When set to <code>S2N_KEY_UPDATE_NOT_REQUESTED</code>, then only the sending key of <code>conn</code> will be updated. If set to <code>S2N_KEY_UPDATE_REQUESTED</code>, then the sending key of conn will be updated AND the peer will be requested to update their sending key. Note that s2n-tls currently only supports <code>peer_request</code> being set to <code>S2N_KEY_UPDATE_NOT_REQUESTED</code> and will return S2N_FAILURE if any other value is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a978a1d8977b97f7f4faae7111a0404d3" name="a978a1d8977b97f7f4faae7111a0404d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978a1d8977b97f7f4faae7111a0404d3">&#9670;&#160;</a></span>s2n_connection_serialization_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_serialization_length </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Retrieves the length of the serialized connection from <code><a class="el" href="s2n_8h.html#a5d020f94e2f7324b8a5eee91287c18b3">s2n_connection_serialize()</a></code>. Should be used to allocate enough memory for the serialized connection buffer.</p>
<dl class="section note"><dt>Note</dt><dd>The size of the serialized connection changes based on parameters negotiated in the TLS handshake. Do not expect the size to always remain the same.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the connection object. </td></tr>
    <tr><td class="paramname">length</td><td>Output parameter where the length will be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success, S2N_FAILURE on error. </dd></dl>

</div>
</div>
<a id="a5d020f94e2f7324b8a5eee91287c18b3" name="a5d020f94e2f7324b8a5eee91287c18b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d020f94e2f7324b8a5eee91287c18b3">&#9670;&#160;</a></span>s2n_connection_serialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_serialize </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>buffer_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Serializes the s2n_connection into the provided buffer.</p>
<p >This API takes an established s2n-tls connection object and "serializes" it into a transferable object to be sent off-box or to another process. This transferable object can then be "deserialized" using the <code>s2n_connection_deserialize</code> method to instantiate an s2n-tls connection object that can talk to the original peer with the same encryption keys.</p>
<dl class="section warning"><dt>Warning</dt><dd>This feature is dangerous because it provides cryptographic material from a TLS session in plaintext. Users MUST both encrypt and MAC the contents of the outputted material to provide secrecy and integrity if this material is transported off-box. DO NOT store or send this material off-box without encryption.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>You MUST have used <code><a class="el" href="s2n_8h.html#a619375c69a21184f06fb22d7810c3831">s2n_config_set_serialization_version()</a></code> to set a version on the s2n_config object associated with this connection before this connection began its TLS handshake. </dd>
<dd>
Call <code>s2n_connection_serialization_length</code> to retrieve the amount of memory needed for the buffer parameter. </dd>
<dd>
This API will error if the handshake is not yet complete.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the connection object. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer where the serialized connection will be written. </td></tr>
    <tr><td class="paramname">buffer_length</td><td>Maximum amount of data that can be written to the buffer param. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success, S2N_FAILURE on error. </dd></dl>

</div>
</div>
<a id="a71cfccf774ddf237a30eb9c2fc9b0831" name="a71cfccf774ddf237a30eb9c2fc9b0831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71cfccf774ddf237a30eb9c2fc9b0831">&#9670;&#160;</a></span>s2n_connection_server_name_extension_used()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_server_name_extension_used </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Must be invoked if any of the connection properties were changed on the basis of the server_name extension. This must be invoked before marking the Client Hello callback done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The connection object being updated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a684b2e5c86c85f089392bd1a49d38e17" name="a684b2e5c86c85f089392bd1a49d38e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684b2e5c86c85f089392bd1a49d38e17">&#9670;&#160;</a></span>s2n_connection_set_blinding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_set_blinding </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a364ad496c9dd42fd3117a2f9d3289e62">s2n_blinding</a>&#160;</td>
          <td class="paramname"><em>blinding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Used to configure s2n-tls to either use built-in blinding (set blinding to S2N_BUILT_IN_BLINDING) or self-service blinding (set blinding to S2N_SELF_SERVICE_BLINDING).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The connection object being updated </td></tr>
    <tr><td class="paramname">blinding</td><td>The desired blinding mode for the connection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="ab4544d664e827a426b484b3eaa62063d" name="ab4544d664e827a426b484b3eaa62063d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4544d664e827a426b484b3eaa62063d">&#9670;&#160;</a></span>s2n_connection_set_cipher_preferences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_set_cipher_preferences </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the cipher preference override for the s2n_connection. Calling this function is not necessary unless you want to set the cipher preferences on the connection to something different than what is in the s2n_config.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The connection object being updated </td></tr>
    <tr><td class="paramname">version</td><td>The human readable string representation of the security policy version. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="ad2985adfcaa565bf3cf35edb4ae4f854" name="ad2985adfcaa565bf3cf35edb4ae4f854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2985adfcaa565bf3cf35edb4ae4f854">&#9670;&#160;</a></span>s2n_connection_set_client_auth_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_set_client_auth_type </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a8757c094681bb8151329c8dc067106b8">s2n_cert_auth_type</a>&#160;</td>
          <td class="paramname"><em>client_auth_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets whether or not a Client Certificate should be required to complete the TLS Connection.</p>
<p >If this is set to <code>S2N_CERT_AUTH_OPTIONAL</code> the server will request a client certificate but allow the client to not provide one. Rejecting a client certificate when using <code>S2N_CERT_AUTH_OPTIONAL</code> will terminate the handshake.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object </td></tr>
    <tr><td class="paramname">client_auth_type</td><td>The client auth policy for the connection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="abe4b60e86b018ff4b354421e526c6bd1" name="abe4b60e86b018ff4b354421e526c6bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4b60e86b018ff4b354421e526c6bd1">&#9670;&#160;</a></span>s2n_connection_set_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_set_config </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct s2n_config *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Associates a configuration object with a connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The connection object being associated </td></tr>
    <tr><td class="paramname">config</td><td>The configuration object being associated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="abe22b04670c9345ed5c25b261ee4de72" name="abe22b04670c9345ed5c25b261ee4de72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe22b04670c9345ed5c25b261ee4de72">&#9670;&#160;</a></span>s2n_connection_set_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_set_ctx </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets user defined context in <code>s2n_connection</code> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The connection object being updated </td></tr>
    <tr><td class="paramname">ctx</td><td>A pointer to the user defined context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a5399ba44a921d36ed34661038a509d1a" name="a5399ba44a921d36ed34661038a509d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5399ba44a921d36ed34661038a509d1a">&#9670;&#160;</a></span>s2n_connection_set_dynamic_buffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_set_dynamic_buffers </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Configure the connection to free IO buffers when they are not currently in use.</p>
<p >This configuration can be used to minimize connection memory footprint size, at the cost of more calls to alloc and free. Some of these costs can be mitigated by configuring s2n-tls to use an allocator that includes thread-local caches or lock-free allocation patterns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The connection object being update </td></tr>
    <tr><td class="paramname">enabled</td><td>Set to <code>true</code> if dynamic buffers are enabled; <code>false</code> if disabled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="add5f14855b2810a9857b1a41f2cc92f9" name="add5f14855b2810a9857b1a41f2cc92f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5f14855b2810a9857b1a41f2cc92f9">&#9670;&#160;</a></span>s2n_connection_set_dynamic_record_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_set_dynamic_record_threshold </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>resize_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>timeout_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Changes the behavior of s2n-tls when sending data to initially prefer records small enough to fit in single ethernet frames.</p>
<p >When dynamic record sizing is active, the connection sends records small enough to fit in a single standard 1500 byte ethernet frame. Otherwise, the connection chooses record sizes according to the configured maximum fragment length.</p>
<p >Dynamic record sizing is active for the first resize_threshold bytes of a connection, and is reactivated whenever timeout_threshold seconds pass without sending data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The connection object being updated </td></tr>
    <tr><td class="paramname">resize_threshold</td><td>The number of bytes to send before changing the record size. Maximum 8MiB. </td></tr>
    <tr><td class="paramname">timeout_threshold</td><td>Reset record size back to a single segment after threshold seconds of inactivity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a67962bf835ce5145d215a9ee8f4985d3" name="a67962bf835ce5145d215a9ee8f4985d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67962bf835ce5145d215a9ee8f4985d3">&#9670;&#160;</a></span>s2n_connection_set_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_set_fd </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the file descriptor for a s2n connection.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the read end of the pipe is closed unexpectedly, writing to the pipe will raise a SIGPIPE signal. <b>s2n-tls does NOT handle SIGPIPE.</b> A SIGPIPE signal will cause the process to terminate unless it is handled or ignored by the application. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This file-descriptor should be active and connected </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n connection </td></tr>
    <tr><td class="paramname">fd</td><td>The new file descriptor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a1e7fc1efa730562ff9a804fe578235b4" name="a1e7fc1efa730562ff9a804fe578235b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7fc1efa730562ff9a804fe578235b4">&#9670;&#160;</a></span>s2n_connection_set_protocol_preferences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_set_protocol_preferences </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>protocols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>protocol_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the protocol preference override for the s2n_connection. Calling this function is not necessary unless you want to set the protocol preferences on the connection to something different than what is in the s2n_config.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The connection object being updated </td></tr>
    <tr><td class="paramname">protocols</td><td>A pointer to an array of protocol strings </td></tr>
    <tr><td class="paramname">protocol_count</td><td>The number of protocols contained in protocols </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="abb1777a3ba66fe8ee81f0512c961797d" name="abb1777a3ba66fe8ee81f0512c961797d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb1777a3ba66fe8ee81f0512c961797d">&#9670;&#160;</a></span>s2n_connection_set_psk_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_set_psk_mode </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a3c5d0a0d8a1092a60dd0f50cdf969524">s2n_psk_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the PSK mode on the s2n connection object. The supported PSK modes are listed in the enum <code>s2n_psk_mode</code> above. This API overrides the PSK mode set on config for this connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object being updated. </td></tr>
    <tr><td class="paramname">mode</td><td>The PSK mode to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa75014bd12d682e91ab2812c2e92c16d" name="aa75014bd12d682e91ab2812c2e92c16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75014bd12d682e91ab2812c2e92c16d">&#9670;&#160;</a></span>s2n_connection_set_read_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_set_read_fd </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>readfd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the file descriptor for the read channel of an s2n connection.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the read end of the pipe is closed unexpectedly, writing to the pipe will raise a SIGPIPE signal. <b>s2n-tls does NOT handle SIGPIPE.</b> A SIGPIPE signal will cause the process to terminate unless it is handled or ignored by the application. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This file-descriptor should be active and connected </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n connection </td></tr>
    <tr><td class="paramname">readfd</td><td>The new read file descriptor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="ae30791c458875956ef9f4cdbd8c8c19f" name="ae30791c458875956ef9f4cdbd8c8c19f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30791c458875956ef9f4cdbd8c8c19f">&#9670;&#160;</a></span>s2n_connection_set_recv_buffering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_set_recv_buffering </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Configure the connection to reduce potentially expensive calls to recv.</p>
<p >If this setting is disabled, s2n-tls will call read twice for every TLS record, which can be expensive but ensures that s2n-tls will always attempt to read the exact number of bytes it requires. If this setting is enabled, s2n-tls will instead reduce the number of calls to read by attempting to read as much data as possible in each read call, storing the extra in the existing IO buffers. This may cause it to request more data than will ever actually be available.</p>
<p >There is no additional memory cost of enabling this setting. It reuses the existing IO buffers.</p>
<p >This setting is disabled by default. Depending on how your application detects data available for reading, buffering reads may break your event loop. In particular, note that:</p>
<ol type="1">
<li>File descriptor reads or calls to your custom s2n_recv_cb may request more data than is available. Reads must return partial data when available rather than blocking until all requested data is available.</li>
<li>s2n_negotiate may read and buffer application data records. You must call s2n_recv at least once after negotiation to ensure that you handle any buffered data.</li>
<li>s2n_recv may read and buffer more records than it parses and decrypts. You must call s2n_recv until it reports S2N_ERR_T_BLOCKED, rather than just until it reports S2N_SUCCESS.</li>
<li>s2n_peek reports available decrypted data. It does not report any data buffered by this feature. However, s2n_peek_buffered does report data buffered by this feature.</li>
<li>s2n_connection_release_buffers will not release the input buffer if it contains buffered data.</li>
</ol>
<p >For example: if your event loop uses <code>poll</code>, you will receive a POLLIN event for your read file descriptor when new data is available. When you call s2n_recv to read that data, s2n-tls reads one or more TLS records from the file descriptor. If you stop calling s2n_recv before it reports S2N_ERR_T_BLOCKED, some of those records may remain in s2n-tls's read buffer. If you read part of a record, s2n_peek will report the remainder of that record as available. But if you don't read any of a record, it remains encrypted and is not reported by s2n_peek, but is still reported by s2n_peek_buffered. And because the data is buffered in s2n-tls instead of in the file descriptor, another call to <code>poll</code> will NOT report any more data available. Your application may hang waiting for more data.</p>
<dl class="section warning"><dt>Warning</dt><dd>This feature cannot be enabled for a connection that will enable kTLS for receiving.</dd>
<dd>
This feature may work with blocking IO, if used carefully. Your blocking IO must support partial reads (so MSG_WAITALL cannot be used). You will either need to know exactly how much data your peer is sending, or will need to use <code>s2n_peek</code> and <code>s2n_peek_buffered</code> rather than relying on S2N_ERR_T_BLOCKED as noted in #3 above.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The connection object being updated </td></tr>
    <tr><td class="paramname">enabled</td><td>Set to <code>true</code> to enable, <code>false</code> to disable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a699fd9e05a8e8163811db6cab01af973" name="a699fd9e05a8e8163811db6cab01af973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699fd9e05a8e8163811db6cab01af973">&#9670;&#160;</a></span>s2n_connection_set_recv_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_set_recv_cb </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a0b5d6b77e35bf16aee077fe1c5860cc9">s2n_recv_fn</a>&#160;</td>
          <td class="paramname"><em>recv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Configure a connection to use a recv callback to receive data.</p>
<dl class="section note"><dt>Note</dt><dd>This callback may be blocking or nonblocking. </dd>
<dd>
The callback may receive less than the requested length. The function should return the number of bytes received, or set errno and return an error code &lt; 0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The connection object being updated </td></tr>
    <tr><td class="paramname">recv</td><td>A recv callback function pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a67e1ad17b8453e9ef8ca1df35b7f0ae7" name="a67e1ad17b8453e9ef8ca1df35b7f0ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67e1ad17b8453e9ef8ca1df35b7f0ae7">&#9670;&#160;</a></span>s2n_connection_set_recv_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_set_recv_ctx </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set a context containing anything needed in the recv callback function (for example, a file descriptor), the buffer holding data to be sent or received, and the length of the buffer.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>io_context</code> passed to the callbacks may be set separately using <code>s2n_connection_set_recv_ctx</code> and <code>s2n_connection_set_send_ctx</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The connection object being updated </td></tr>
    <tr><td class="paramname">ctx</td><td>A user provided context that the callback will be invoked with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a4b73b9a8fa03500d5bc609d09035cd45" name="a4b73b9a8fa03500d5bc609d09035cd45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b73b9a8fa03500d5bc609d09035cd45">&#9670;&#160;</a></span>s2n_connection_set_send_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_set_send_cb </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#ad8ae4eeefcfc81bc4daf429512612687">s2n_send_fn</a>&#160;</td>
          <td class="paramname"><em>send</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Configure a connection to use a send callback to send data.</p>
<dl class="section note"><dt>Note</dt><dd>This callback may be blocking or nonblocking. </dd>
<dd>
The callback may send less than the requested length. The function should return the number of bytes sent or set errno and return an error code &lt; 0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The connection object being updated </td></tr>
    <tr><td class="paramname">send</td><td>A send callback function pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a4857138d82f79f939546693b587a61d4" name="a4857138d82f79f939546693b587a61d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4857138d82f79f939546693b587a61d4">&#9670;&#160;</a></span>s2n_connection_set_send_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_set_send_ctx </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set a context containing anything needed in the send callback function (for example, a file descriptor), the buffer holding data to be sent or received, and the length of the buffer.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>io_context</code> passed to the callbacks may be set separately using <code>s2n_connection_set_recv_ctx</code> and <code>s2n_connection_set_send_ctx</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The connection object being updated </td></tr>
    <tr><td class="paramname">ctx</td><td>A user provided context that the callback will be invoked with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a7781fbe1e216918737f9d53c4a49764f" name="a7781fbe1e216918737f9d53c4a49764f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7781fbe1e216918737f9d53c4a49764f">&#9670;&#160;</a></span>s2n_connection_set_server_early_data_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_set_server_early_data_context </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>context_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the user context associated with early data on a server.</p>
<p >This context is passed to the <code>s2n_early_data_cb</code> callback to help decide whether to accept or reject early data.</p>
<p >Unlike most contexts, the early data context is a byte buffer instead of a void pointer. This is because we need to serialize the context into session tickets.</p>
<p >This API is intended for use with session resumption, and will not affect pre-shared keys.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the connection </td></tr>
    <tr><td class="paramname">context</td><td>A pointer to the user context data. This data will be copied. </td></tr>
    <tr><td class="paramname">context_size</td><td>The size of the data to read from the <code>context</code> pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A POSIX error signal. If successful, the context was updated. </dd></dl>

</div>
</div>
<a id="a37cb3fbcfef883aa637322152fe75819" name="a37cb3fbcfef883aa637322152fe75819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37cb3fbcfef883aa637322152fe75819">&#9670;&#160;</a></span>s2n_connection_set_server_keying_material_lifetime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_set_server_keying_material_lifetime </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lifetime_in_secs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the keying material lifetime for &gt;=TLS1.3 session tickets so that one session doesn't get re-used ad infinitum. The default value is one week.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the connection object. </td></tr>
    <tr><td class="paramname">lifetime_in_secs</td><td>Lifetime of keying material in seconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a6257425f035920a67185f96a78a1c97d" name="a6257425f035920a67185f96a78a1c97d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6257425f035920a67185f96a78a1c97d">&#9670;&#160;</a></span>s2n_connection_set_server_max_early_data_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_set_server_max_early_data_size </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_early_data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the maximum bytes of early data the server will accept.</p>
<p >The default maximum is 0. If the maximum is 0, the server rejects all early data requests. The connection maximum can be overridden by the maximum on an external pre-shared key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the connection </td></tr>
    <tr><td class="paramname">max_early_data_size</td><td>The maximum early data the server will accept </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A POSIX error signal. If successful, the maximum early data size was updated. </dd></dl>

</div>
</div>
<a id="aaf779e2e30ec1881f5f63bfae5dc3303" name="aaf779e2e30ec1881f5f63bfae5dc3303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf779e2e30ec1881f5f63bfae5dc3303">&#9670;&#160;</a></span>s2n_connection_set_session()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_set_session </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >De-serializes the session state and updates the connection accordingly.</p>
<p >If this method fails, the connection should not be affected: calling s2n_negotiate with the connection should simply result in a full handshake.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object </td></tr>
    <tr><td class="paramname">session</td><td>A pointer to a buffer of size <code>length</code> </td></tr>
    <tr><td class="paramname">length</td><td>The size of the <code>session</code> buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of copied bytes </dd></dl>

</div>
</div>
<a id="ad39f5c65f5c201d7af140baff29a02eb" name="ad39f5c65f5c201d7af140baff29a02eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39f5c65f5c201d7af140baff29a02eb">&#9670;&#160;</a></span>s2n_connection_set_verify_host_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_set_verify_host_callback </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a8aa56850695a02753f726ea9860ec383">s2n_verify_host_fn</a>&#160;</td>
          <td class="paramname"><em>host_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the callback to use for verifying that a hostname from an X.509 certificate is trusted.</p>
<p >The default behavior is to require that the hostname match the server name set with <a class="el" href="s2n_8h.html#af5c2488271997ea0b0b21d3937e612f6">s2n_set_server_name()</a>. This will likely lead to all client certificates being rejected, so the callback will need to be overriden when using client authentication.</p>
<p >If a single callback for different connections using the same config is desired, see <a class="el" href="s2n_8h.html#a079022d5c18f4ffd64c1c6dedb3bbc66">s2n_config_set_verify_host_callback()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to a s2n_connection object </td></tr>
    <tr><td class="paramname">host_fn</td><td>A pointer to a callback function that s2n will invoke in order to verify the hostname of an X.509 certificate </td></tr>
    <tr><td class="paramname">data</td><td>Opaque pointer to data that the verify host function will be invoked with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a8153e24a1b79e7b68ac7a1f7f7d8d0ea" name="a8153e24a1b79e7b68ac7a1f7f7d8d0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8153e24a1b79e7b68ac7a1f7f7d8d0ea">&#9670;&#160;</a></span>s2n_connection_set_write_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_set_write_fd </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>writefd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the assigned file descriptor for the write channel of an s2n connection.</p>
<dl class="section note"><dt>Note</dt><dd>This file-descriptor should be active and connected </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n connection </td></tr>
    <tr><td class="paramname">writefd</td><td>The new write file descriptor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="ae8c865863e6dcfa38d4de30cd11f7c40" name="ae8c865863e6dcfa38d4de30cd11f7c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c865863e6dcfa38d4de30cd11f7c40">&#9670;&#160;</a></span>s2n_connection_tls_exporter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_tls_exporter </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>label_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>context_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>output_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Provides access to the TLS-Exporter functionality.</p>
<p >See <a href="https://datatracker.ietf.org/doc/html/rfc5705">https://datatracker.ietf.org/doc/html/rfc5705</a> and <a href="https://www.rfc-editor.org/rfc/rfc8446">https://www.rfc-editor.org/rfc/rfc8446</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This is currently only available with TLS 1.3 connections which have finished a handshake.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the connection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A POSIX error signal. If an error was returned, the value contained in <code>output</code> should be considered invalid. </dd></dl>

</div>
</div>
<a id="a91d835f1152a699dfd00ff781c86774e" name="a91d835f1152a699dfd00ff781c86774e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d835f1152a699dfd00ff781c86774e">&#9670;&#160;</a></span>s2n_connection_use_corked_io()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_use_corked_io </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Indicates to s2n that the connection is using corked IO.</p>
<dl class="section warning"><dt>Warning</dt><dd>This API should only be used when using managed send IO.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The connection object being updated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="ae42c3c7b37df666c2b3e6a53c1ea5f76" name="ae42c3c7b37df666c2b3e6a53c1ea5f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae42c3c7b37df666c2b3e6a53c1ea5f76">&#9670;&#160;</a></span>s2n_connection_wipe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_connection_wipe </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Wipes an existing connection and allows it to be reused. Erases all data associated with a connection including pending reads.</p>
<dl class="section note"><dt>Note</dt><dd>This function should be called after all I/O is completed and s2n_shutdown has been called. </dd>
<dd>
Reusing the same connection handle(s) is more performant than repeatedly calling <a class="el" href="s2n_8h.html#a58005ebdc3e4caf6b6f40321bbc5b1e5">s2n_connection_new()</a> and <a class="el" href="s2n_8h.html#a9c7664ec2fe4c694148ad303f4229f94">s2n_connection_free()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="ac4b12103d1358a4c15f3630401d1e932" name="ac4b12103d1358a4c15f3630401d1e932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b12103d1358a4c15f3630401d1e932">&#9670;&#160;</a></span>s2n_crypto_disable_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_crypto_disable_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Prevents S2N from calling <code>OPENSSL_init_crypto</code>/<code>OPENSSL_cleanup</code>/<code>EVP_cleanup</code> on OpenSSL versions prior to 1.1.x. This allows applications or languages that also init OpenSSL to interoperate with S2N.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function must be called BEFORE <a class="el" href="s2n_8h.html#a41b65ad20272f232f12c8ae36578d372">s2n_init()</a> to have any effect. It will return an error if s2n is already initialized.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you disable this and are using a version of OpenSSL/libcrypto &lt; 1.1.x, you will be responsible for library init and cleanup (specifically <code>OPENSSL_add_all_algorithms()</code> or <code>OPENSSL_init_crypto()</code>, and EVP_* APIs will not be usable unless the library is initialized.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="aeb0e6f150b48022f73ab5282e50de6a6" name="aeb0e6f150b48022f73ab5282e50de6a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0e6f150b48022f73ab5282e50de6a6">&#9670;&#160;</a></span>s2n_disable_atexit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_disable_atexit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Prevents S2N from installing an atexit handler, which allows safe shutdown of S2N from within a re-entrant shared library</p>
<dl class="section warning"><dt>Warning</dt><dd>This function must be called BEFORE <a class="el" href="s2n_8h.html#a41b65ad20272f232f12c8ae36578d372">s2n_init()</a> to have any effect. It will return an error if s2n is already initialized.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This will cause <code>s2n_cleanup</code> to do complete cleanup of s2n-tls when called from the main thread (the thread <code>s2n_init</code> was called from).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="afc791e3052429bdeb4428ef3acab7f27" name="afc791e3052429bdeb4428ef3acab7f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc791e3052429bdeb4428ef3acab7f27">&#9670;&#160;</a></span>s2n_errno_location()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int * s2n_errno_location </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function can be used instead of trying to resolve <code>s2n_errno</code> directly in runtimes where thread-local variables may not be easily accessible.</p>
<dl class="section return"><dt>Returns</dt><dd>The address of the thread-local <code>s2n_errno</code> variable </dd></dl>

</div>
</div>
<a id="aebff13e0704f879abbb6a3a7cbbe62c2" name="aebff13e0704f879abbb6a3a7cbbe62c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebff13e0704f879abbb6a3a7cbbe62c2">&#9670;&#160;</a></span>s2n_error_get_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_error_get_type </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the category of error from an error.</p>
<p >s2n-tls organizes errors into different "types" to allow applications to do logic on error values without catching all possibilities. Applications using non-blocking I/O should check error type to determine if the I/O operation failed because it would block or for some other error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>The error from s2n. Usually this is <code>s2n_errno</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An s2n_error_type </dd></dl>

</div>
</div>
<a id="ab2213d536228ff00449ecef87ca6006c" name="ab2213d536228ff00449ecef87ca6006c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2213d536228ff00449ecef87ca6006c">&#9670;&#160;</a></span>s2n_external_psk_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> struct s2n_psk * s2n_external_psk_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new s2n external pre-shared key (PSK) object with <code>S2N_PSK_HMAC_SHA256</code> as the default PSK hash algorithm. An external PSK is a key established outside of TLS using a secure mutually agreed upon mechanism.</p>
<p >Use <code>s2n_psk_free</code> to free the memory allocated to the s2n external PSK object created by this API.</p>
<dl class="section return"><dt>Returns</dt><dd>struct s2n_psk* Returns a pointer to the newly created external PSK object. </dd></dl>

</div>
</div>
<a id="a7794e4ff39ad4a15b310136fcd4ac079" name="a7794e4ff39ad4a15b310136fcd4ac079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7794e4ff39ad4a15b310136fcd4ac079">&#9670;&#160;</a></span>s2n_free_stacktrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_free_stacktrace </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Clean up the memory used to contain the stack trace.</p>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="ae53faa26669e258afff875d45140f14e" name="ae53faa26669e258afff875d45140f14e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53faa26669e258afff875d45140f14e">&#9670;&#160;</a></span>s2n_get_application_protocol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> const char * s2n_get_application_protocol </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Query the connection for the selected application protocol.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The connection object being queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The negotiated application protocol for a <code>s2n_connection</code>. In the event of no protocol being negotiated, NULL is returned. </dd></dl>

</div>
</div>
<a id="ae2f5f01eb4a3c924ffb8674bd3256601" name="ae2f5f01eb4a3c924ffb8674bd3256601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f5f01eb4a3c924ffb8674bd3256601">&#9670;&#160;</a></span>s2n_get_fips_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_get_fips_mode </td>
          <td>(</td>
          <td class="paramtype">s2n_fips_mode *&#160;</td>
          <td class="paramname"><em>fips_mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Determines whether s2n-tls is operating in FIPS mode.</p>
<p >s2n-tls enters FIPS mode on initialization when built with a version of AWS-LC that supports FIPS (<a href="https://github.com/aws/aws-lc/blob/main/crypto/fipsmodule/FIPS.md">https://github.com/aws/aws-lc/blob/main/crypto/fipsmodule/FIPS.md</a>). FIPS mode controls some internal configuration related to FIPS support, like which random number generator is used.</p>
<p >FIPS mode does not enforce the use of FIPS-approved cryptography. Applications attempting to use only FIPS-approved cryptography should also ensure that s2n-tls is configured to use a security policy that only supports FIPS-approved cryptography.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fips_mode</td><td>Set to the FIPS mode of s2n-tls. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure. </dd></dl>

</div>
</div>
<a id="af149f0a7173ca87281b568fa87e46db7" name="af149f0a7173ca87281b568fa87e46db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af149f0a7173ca87281b568fa87e46db7">&#9670;&#160;</a></span>s2n_get_openssl_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> unsigned long s2n_get_openssl_version </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Fetches the OpenSSL version s2n-tls was compiled with. This can be used by applications to validate at runtime that the versions of s2n-tls and Openssl that they have loaded are correct.</p>
<dl class="section return"><dt>Returns</dt><dd>the version number of OpenSSL that s2n-tls was compiled with </dd></dl>

</div>
</div>
<a id="a22dc30ff2bf6f66673b8a175fdfe0c29" name="a22dc30ff2bf6f66673b8a175fdfe0c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22dc30ff2bf6f66673b8a175fdfe0c29">&#9670;&#160;</a></span>s2n_get_server_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> const char * s2n_get_server_name </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Query the connection for the selected server name.</p>
<p >This can be used by a server to determine which server name the client is using. This function returns the first ServerName entry in the ServerNameList sent by the client. Subsequent entries are not returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The connection object being queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The server name associated with a connection, or NULL if none is found. </dd></dl>

</div>
</div>
<a id="a7bb6aca0767b83c072629041a30f263b" name="a7bb6aca0767b83c072629041a30f263b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb6aca0767b83c072629041a30f263b">&#9670;&#160;</a></span>s2n_get_stacktrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_get_stacktrace </td>
          <td>(</td>
          <td class="paramtype">struct s2n_stacktrace *&#160;</td>
          <td class="paramname"><em>trace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Export the s2n_stacktrace.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trace</td><td>A pointer to the s2n_stacktrace to fill. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a41b65ad20272f232f12c8ae36578d372" name="a41b65ad20272f232f12c8ae36578d372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b65ad20272f232f12c8ae36578d372">&#9670;&#160;</a></span>s2n_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Initializes the s2n-tls library and should be called once in your application, before any other s2n-tls functions are called. Failure to call <a class="el" href="s2n_8h.html#a41b65ad20272f232f12c8ae36578d372">s2n_init()</a> will result in errors from other s2n-tls functions.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function is not thread safe and should only be called once.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a664b222a36088c06c4580653971f03a5" name="a664b222a36088c06c4580653971f03a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a664b222a36088c06c4580653971f03a5">&#9670;&#160;</a></span>s2n_mem_set_callbacks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_mem_set_callbacks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a71033bff0e129f910b87d5fb41798519">s2n_mem_init_callback</a>&#160;</td>
          <td class="paramname"><em>mem_init_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#ae5f75394a380a2764b189ca6662133ba">s2n_mem_cleanup_callback</a>&#160;</td>
          <td class="paramname"><em>mem_cleanup_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a8ea7d341ee2969dd1d083fafe13a5d43">s2n_mem_malloc_callback</a>&#160;</td>
          <td class="paramname"><em>mem_malloc_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a6e4014627f6981bc4e533781d29903d5">s2n_mem_free_callback</a>&#160;</td>
          <td class="paramname"><em>mem_free_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Allows the caller to override s2n-tls's internal memory handling functions.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function must be called before <a class="el" href="s2n_8h.html#a41b65ad20272f232f12c8ae36578d372">s2n_init()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem_init_callback</td><td>The s2n_mem_init_callback </td></tr>
    <tr><td class="paramname">mem_cleanup_callback</td><td>The s2n_mem_cleanup_callback </td></tr>
    <tr><td class="paramname">mem_malloc_callback</td><td>The s2n_mem_malloc_callback </td></tr>
    <tr><td class="paramname">mem_free_callback</td><td>The s2n_mem_free_callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="ad3222e7aacf35a56be842678171be440" name="ad3222e7aacf35a56be842678171be440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3222e7aacf35a56be842678171be440">&#9670;&#160;</a></span>s2n_negotiate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_negotiate </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#af70ca0b089daa98cd79a424d3f6af15d">s2n_blocked_status</a> *&#160;</td>
          <td class="paramname"><em>blocked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Performs the initial "handshake" phase of a TLS connection and must be called before any <a class="el" href="s2n_8h.html#a3b67ff058796d4c6c6caddfd0f10274e">s2n_recv()</a> or <a class="el" href="s2n_8h.html#a9afeb514731fa9d74edf6b9e1348c067">s2n_send()</a> calls.</p>
<dl class="section note"><dt>Note</dt><dd>When using client authentication with TLS1.3, <a class="el" href="s2n_8h.html#ad3222e7aacf35a56be842678171be440">s2n_negotiate()</a> will report a successful handshake to clients before the server validates the client certificate. If the server then rejects the client certificate, the client may later receive an alert while calling s2n_recv, potentially after already having sent application data with s2n_send.</dd></dl>
<p>See the following example for guidance on calling <code><a class="el" href="s2n_8h.html#ad3222e7aacf35a56be842678171be440">s2n_negotiate()</a></code>: <a href="https://github.com/aws/s2n-tls/blob/main/docs/examples/s2n_negotiate.c">https://github.com/aws/s2n-tls/blob/main/docs/examples/s2n_negotiate.c</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object </td></tr>
    <tr><td class="paramname">blocked</td><td>A pointer which will be set to the blocked status if an <code>S2N_ERR_T_BLOCKED</code> error is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS if the handshake completed. S2N_FAILURE if the handshake encountered an error or is blocked. </dd></dl>

</div>
</div>
<a id="a675dc5ad09b3950ef36c62f4a43a7414" name="a675dc5ad09b3950ef36c62f4a43a7414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675dc5ad09b3950ef36c62f4a43a7414">&#9670;&#160;</a></span>s2n_offered_early_data_accept()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_offered_early_data_accept </td>
          <td>(</td>
          <td class="paramtype">struct s2n_offered_early_data *&#160;</td>
          <td class="paramname"><em>early_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Accept early data offered by the client.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">early_data</td><td>A pointer to the early data information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A POSIX error signal. If success, the client's early data will be accepted. </dd></dl>

</div>
</div>
<a id="a074ab5b724adcf90f98d4150c0b14342" name="a074ab5b724adcf90f98d4150c0b14342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074ab5b724adcf90f98d4150c0b14342">&#9670;&#160;</a></span>s2n_offered_early_data_get_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_offered_early_data_get_context </td>
          <td>(</td>
          <td class="paramtype">struct s2n_offered_early_data *&#160;</td>
          <td class="paramname"><em>early_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the early data context set by the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">early_data</td><td>A pointer to the early data information </td></tr>
    <tr><td class="paramname">context</td><td>A byte buffer to copy the user context into </td></tr>
    <tr><td class="paramname">max_len</td><td>The size of <code>context</code>. Must be &gt;= to the result of <code>s2n_offered_early_data_get_context_length</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A POSIX error signal. </dd></dl>

</div>
</div>
<a id="a8dff236f4bb72cd1acea4887d8044f82" name="a8dff236f4bb72cd1acea4887d8044f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dff236f4bb72cd1acea4887d8044f82">&#9670;&#160;</a></span>s2n_offered_early_data_get_context_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_offered_early_data_get_context_length </td>
          <td>(</td>
          <td class="paramtype">struct s2n_offered_early_data *&#160;</td>
          <td class="paramname"><em>early_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>context_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the length of the early data context set by the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">early_data</td><td>A pointer to the early data information </td></tr>
    <tr><td class="paramname">context_len</td><td>The length of the user context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A POSIX error signal. </dd></dl>

</div>
</div>
<a id="a23b80aded2ad1f434662ae5b76f176f2" name="a23b80aded2ad1f434662ae5b76f176f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b80aded2ad1f434662ae5b76f176f2">&#9670;&#160;</a></span>s2n_offered_early_data_reject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_offered_early_data_reject </td>
          <td>(</td>
          <td class="paramtype">struct s2n_offered_early_data *&#160;</td>
          <td class="paramname"><em>early_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reject early data offered by the client.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">early_data</td><td>A pointer to the early data information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A POSIX error signal. If success, the client's early data will be rejected. </dd></dl>

</div>
</div>
<a id="a8e4dcfe9736f75c1f8fa1c75e43cb16d" name="a8e4dcfe9736f75c1f8fa1c75e43cb16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e4dcfe9736f75c1f8fa1c75e43cb16d">&#9670;&#160;</a></span>s2n_offered_psk_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_offered_psk_free </td>
          <td>(</td>
          <td class="paramtype">struct s2n_offered_psk **&#160;</td>
          <td class="paramname"><em>psk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Frees the memory associated with the <code>s2n_offered_psk</code> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psk</td><td>A pointer to the <code>s2n_offered_psk</code> object to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fc2bee93a578a8ea3d1f90ada7139ad" name="a0fc2bee93a578a8ea3d1f90ada7139ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc2bee93a578a8ea3d1f90ada7139ad">&#9670;&#160;</a></span>s2n_offered_psk_get_identity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_offered_psk_get_identity </td>
          <td>(</td>
          <td class="paramtype">struct s2n_offered_psk *&#160;</td>
          <td class="paramname"><em>psk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t **&#160;</td>
          <td class="paramname"><em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the PSK identity and PSK identity length for a given offered PSK object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psk</td><td>A pointer to the offered PSK object being read. </td></tr>
    <tr><td class="paramname">identity</td><td>The PSK identity being obtained. </td></tr>
    <tr><td class="paramname">size</td><td>The length of the PSK identity being obtained. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b738ac812a3e48b71c0dbb5761c9c07" name="a5b738ac812a3e48b71c0dbb5761c9c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b738ac812a3e48b71c0dbb5761c9c07">&#9670;&#160;</a></span>s2n_offered_psk_list_choose_psk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_offered_psk_list_choose_psk </td>
          <td>(</td>
          <td class="paramtype">struct s2n_offered_psk_list *&#160;</td>
          <td class="paramname"><em>psk_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct s2n_offered_psk *&#160;</td>
          <td class="paramname"><em>psk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Chooses a PSK from the offered PSK list to be used for the connection. <br  />
 This API matches the PSK identity received from the client against the server's known PSK identities list, in order to choose the PSK to be used for the connection. If the PSK identity sent from the client is NULL, no PSK is chosen for the connection. If the client offered PSK identity has no matching PSK identity with the server, an error will be returned. Use this API along with the <code>s2n_psk_selection_callback</code> callback to select a PSK identity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psk_list</td><td>A pointer to the server's known PSK list used to compare for a matching PSK with the client. </td></tr>
    <tr><td class="paramname">psk</td><td>A pointer to the client's PSK object used to compare with the server's known PSK identities. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f2cd9df8a941688c493a7efbbcd5fe7" name="a1f2cd9df8a941688c493a7efbbcd5fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2cd9df8a941688c493a7efbbcd5fe7">&#9670;&#160;</a></span>s2n_offered_psk_list_has_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> bool s2n_offered_psk_list_has_next </td>
          <td>(</td>
          <td class="paramtype">struct s2n_offered_psk_list *&#160;</td>
          <td class="paramname"><em>psk_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Checks whether the offered PSK list has an offered psk object next in line in the list. An offered PSK list contains all the PSKs offered by the client for the server to select.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Safety</h1>
<p >This API returns a pointer to the s2n-tls internal memory with limited lifetime. After the completion of <code>s2n_psk_selection_callback</code> this pointer is invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psk_list</td><td>A pointer to the offered PSK list being read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool A boolean value representing whether an offered psk object is present next in line in the offered PSK list. </dd></dl>

</div>
</div>
<a id="a8b1c3e31302576eda99ba71b430fb6e8" name="a8b1c3e31302576eda99ba71b430fb6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1c3e31302576eda99ba71b430fb6e8">&#9670;&#160;</a></span>s2n_offered_psk_list_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_offered_psk_list_next </td>
          <td>(</td>
          <td class="paramtype">struct s2n_offered_psk_list *&#160;</td>
          <td class="paramname"><em>psk_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct s2n_offered_psk *&#160;</td>
          <td class="paramname"><em>psk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Obtains the next offered PSK object from the list of offered PSKs. Use <code>s2n_offered_psk_list_has_next</code> prior to this API call to ensure we have not reached the end of the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psk_list</td><td>A pointer to the offered PSK list being read. </td></tr>
    <tr><td class="paramname">psk</td><td>A pointer to the next offered PSK object being obtained. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac37d76852ede42bb5eabada732667147" name="ac37d76852ede42bb5eabada732667147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37d76852ede42bb5eabada732667147">&#9670;&#160;</a></span>s2n_offered_psk_list_reread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_offered_psk_list_reread </td>
          <td>(</td>
          <td class="paramtype">struct s2n_offered_psk_list *&#160;</td>
          <td class="paramname"><em>psk_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the offered PSK list to its original read state.</p>
<p >When <code>s2n_offered_psk_list_reread</code> is called, <code>s2n_offered_psk_list_next</code> will return the first PSK in the offered PSK list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psk_list</td><td>A pointer to the offered PSK list being reread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1add39d3f454da2ca54b5f13fe4d89fd" name="a1add39d3f454da2ca54b5f13fe4d89fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1add39d3f454da2ca54b5f13fe4d89fd">&#9670;&#160;</a></span>s2n_offered_psk_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> struct s2n_offered_psk * s2n_offered_psk_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new s2n offered PSK object. An offered PSK object represents a single PSK sent by the client.</p>
<h1><a class="anchor" id="autotoc_md8"></a>
Safety</h1>
<p >Use <code>s2n_offered_psk_free</code> to free the memory allocated to the s2n offered PSK object created by this API.</p>
<dl class="section return"><dt>Returns</dt><dd>struct s2n_offered_psk* Returns a pointer to the newly created offered PSK object. </dd></dl>

</div>
</div>
<a id="a1b49cd285e03ba447a8250f01864cca5" name="a1b49cd285e03ba447a8250f01864cca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b49cd285e03ba447a8250f01864cca5">&#9670;&#160;</a></span>s2n_peek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> uint32_t s2n_peek </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Allows users of s2n-tls to peek inside the data buffer of an s2n-tls connection to see if there more data to be read without actually reading it.</p>
<p >This is useful when using select() on the underlying s2n-tls file descriptor with a message based application layer protocol. As a single call to s2n_recv may read all data off the underlying file descriptor, select() will be unable to tell you there if there is more application data ready for processing already loaded into the s2n-tls buffer.</p>
<dl class="section note"><dt>Note</dt><dd>can then be used to determine if <a class="el" href="s2n_8h.html#a3b67ff058796d4c6c6caddfd0f10274e">s2n_recv()</a> needs to be called before more data comes in on the raw fd </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes that can be read from the connection </dd></dl>

</div>
</div>
<a id="a9e66cd9a37ddf82419039cdc60b28895" name="a9e66cd9a37ddf82419039cdc60b28895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e66cd9a37ddf82419039cdc60b28895">&#9670;&#160;</a></span>s2n_peek_buffered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> uint32_t s2n_peek_buffered </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reports how many bytes of unprocessed TLS records are buffered due to the optimization enabled by <code>s2n_connection_set_recv_buffering</code>.</p>
<p ><code>s2n_peek_buffered</code> is not a replacement for <code>s2n_peek</code>. While <code>s2n_peek</code> reports application data that is ready for the application to read with no additional processing, <code>s2n_peek_buffered</code> reports raw TLS records that still need to be parsed and likely decrypted. Those records may contain application data, but they may also only contain TLS control messages.</p>
<p >If an application needs to determine whether there is any data left to handle (for example, before calling <code>poll</code> to wait on the read file descriptor) then that application must check both <code>s2n_peek</code> and <code>s2n_peek_buffered</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of buffered encrypted bytes </dd></dl>

</div>
</div>
<a id="a3795be9933007194977318e19e7fb8ea" name="a3795be9933007194977318e19e7fb8ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3795be9933007194977318e19e7fb8ea">&#9670;&#160;</a></span>s2n_print_stacktrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_print_stacktrace </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Prints the s2n stack trace to a file. The file descriptor is expected to be open and ready for writing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fptr</td><td>A pointer to the file s2n-tls should write the stack trace to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a20c25dc1760ec458de592d477ebe941a" name="a20c25dc1760ec458de592d477ebe941a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c25dc1760ec458de592d477ebe941a">&#9670;&#160;</a></span>s2n_psk_configure_early_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_psk_configure_early_data </td>
          <td>(</td>
          <td class="paramtype">struct s2n_psk *&#160;</td>
          <td class="paramname"><em>psk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_early_data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cipher_suite_first_byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cipher_suite_second_byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Configures a particular pre-shared key to allow early data.</p>
<p ><code>max_early_data_size</code> must be set to the maximum early data accepted by the server.</p>
<p >In order to use early data, the cipher suite set on the pre-shared key must match the cipher suite ultimately negotiated by the TLS handshake. Additionally, the cipher suite must have the same hmac algorithm as the pre-shared key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psk</td><td>A pointer to the pre-shared key, created with <code>s2n_external_psk_new</code>. </td></tr>
    <tr><td class="paramname">max_early_data_size</td><td>The maximum early data that can be sent or received using this key. </td></tr>
    <tr><td class="paramname">cipher_suite_first_byte</td><td>The first byte in the registered IANA value of the associated cipher suite. </td></tr>
    <tr><td class="paramname">cipher_suite_second_byte</td><td>The second byte in the registered IANA value of the associated cipher suite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A POSIX error signal. If successful, <code>psk</code> was updated. </dd></dl>

</div>
</div>
<a id="a7d81a1590c967f58b2a5d5acbf1cb33f" name="a7d81a1590c967f58b2a5d5acbf1cb33f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d81a1590c967f58b2a5d5acbf1cb33f">&#9670;&#160;</a></span>s2n_psk_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_psk_free </td>
          <td>(</td>
          <td class="paramtype">struct s2n_psk **&#160;</td>
          <td class="paramname"><em>psk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Frees the memory associated with the external PSK object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psk</td><td>Pointer to the PSK object to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3999109378fb5b930b0aa201a20276f5" name="a3999109378fb5b930b0aa201a20276f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3999109378fb5b930b0aa201a20276f5">&#9670;&#160;</a></span>s2n_psk_set_application_protocol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_psk_set_application_protocol </td>
          <td>(</td>
          <td class="paramtype">struct s2n_psk *&#160;</td>
          <td class="paramname"><em>psk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>application_protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the optional <code>application_protocol</code> associated with the given pre-shared key.</p>
<p >In order to use early data, the <code>application_protocol</code> set on the pre-shared key must match the <code>application_protocol</code> ultimately negotiated by the TLS handshake.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psk</td><td>A pointer to the pre-shared key, created with <code>s2n_external_psk_new</code>. </td></tr>
    <tr><td class="paramname">application_protocol</td><td>A pointer to the associated application protocol data. This data will be copied. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data to read from the <code>application_protocol</code> pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A POSIX error signal. If successful, the application protocol was set. </dd></dl>

</div>
</div>
<a id="a04a2a31ffee337b539e6a9578680d18d" name="a04a2a31ffee337b539e6a9578680d18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04a2a31ffee337b539e6a9578680d18d">&#9670;&#160;</a></span>s2n_psk_set_early_data_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_psk_set_early_data_context </td>
          <td>(</td>
          <td class="paramtype">struct s2n_psk *&#160;</td>
          <td class="paramname"><em>psk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the optional user early data context associated with the given pre-shared key.</p>
<p >The early data context is passed to the <code>s2n_early_data_cb</code> callback to help decide whether to accept or reject early data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psk</td><td>A pointer to the pre-shared key, created with <code>s2n_external_psk_new</code>. </td></tr>
    <tr><td class="paramname">context</td><td>A pointer to the associated user context data. This data will be copied. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data to read from the <code>context</code> pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A POSIX error signal. If successful, the context was set. </dd></dl>

</div>
</div>
<a id="a49e08ceb8cc253bd4f9448ee10a11a7b" name="a49e08ceb8cc253bd4f9448ee10a11a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e08ceb8cc253bd4f9448ee10a11a7b">&#9670;&#160;</a></span>s2n_psk_set_hmac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_psk_set_hmac </td>
          <td>(</td>
          <td class="paramtype">struct s2n_psk *&#160;</td>
          <td class="paramname"><em>psk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a85b2409fe4420987dcb5d1ed905e81fc">s2n_psk_hmac</a>&#160;</td>
          <td class="paramname"><em>hmac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the hash algorithm for a given external PSK object. The supported PSK hash algorithms are as listed in the enum <code>s2n_psk_hmac</code> above.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psk</td><td>A pointer to the external PSK object to be updated with the PSK hash algorithm. </td></tr>
    <tr><td class="paramname">hmac</td><td>The PSK hash algorithm being set. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62e056dcc33bad30db288ca43026d87b" name="a62e056dcc33bad30db288ca43026d87b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e056dcc33bad30db288ca43026d87b">&#9670;&#160;</a></span>s2n_psk_set_identity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_psk_set_identity </td>
          <td>(</td>
          <td class="paramtype">struct s2n_psk *&#160;</td>
          <td class="paramname"><em>psk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>identity_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the identity for a given external PSK object. The identity is a unique identifier for the pre-shared secret. It is a non-secret value represented by raw bytes.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Safety</h1>
<p >The identity is transmitted over the network unencrypted and is a non-secret value. Do not include confidential information in the identity.</p>
<p >Note that the identity is copied into s2n-tls memory and the caller is responsible for freeing the memory associated with the identity input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psk</td><td>A pointer to a PSK object to be updated with the identity. </td></tr>
    <tr><td class="paramname">identity</td><td>The identity in raw bytes format to be copied. </td></tr>
    <tr><td class="paramname">identity_size</td><td>The length of the PSK identity being set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad95f6b44cd77ae6fd057185040697f22" name="ad95f6b44cd77ae6fd057185040697f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95f6b44cd77ae6fd057185040697f22">&#9670;&#160;</a></span>s2n_psk_set_secret()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_psk_set_secret </td>
          <td>(</td>
          <td class="paramtype">struct s2n_psk *&#160;</td>
          <td class="paramname"><em>psk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>secret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>secret_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the out-of-band/externally provisioned secret for a given external PSK object.</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Safety</h1>
<p >Note that the secret is copied into s2n-tls memory and the caller is responsible for freeing the memory associated with the <code>secret</code> input.</p>
<p >Deriving a shared secret from a password or other low-entropy source is not secure and is subject to dictionary attacks. See <a href="https://tools.ietf.org/rfc/rfc8446#section-2.2">https://tools.ietf.org/rfc/rfc8446#section-2.2</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psk</td><td>A pointer to a PSK object to be updated with the secret. </td></tr>
    <tr><td class="paramname">secret</td><td>The secret in raw bytes format to be copied. </td></tr>
    <tr><td class="paramname">secret_size</td><td>The length of the pre-shared secret being set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3f23014a1e26a8849f9b35208c7fdcc" name="af3f23014a1e26a8849f9b35208c7fdcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f23014a1e26a8849f9b35208c7fdcc">&#9670;&#160;</a></span>s2n_rand_set_callbacks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_rand_set_callbacks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#ada646d7bfa47772c96b4e4c9dca18dd1">s2n_rand_init_callback</a>&#160;</td>
          <td class="paramname"><em>rand_init_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a700f181dd144cbb4161765333a190d01">s2n_rand_cleanup_callback</a>&#160;</td>
          <td class="paramname"><em>rand_cleanup_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#ae7cf68edcc9173e3ac5383d1fb879d31">s2n_rand_seed_callback</a>&#160;</td>
          <td class="paramname"><em>rand_seed_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#a4b6891b58a1c9a957d299177497e7896">s2n_rand_mix_callback</a>&#160;</td>
          <td class="paramname"><em>rand_mix_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Allows the caller to override s2n-tls's entropy functions.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function must be called before <a class="el" href="s2n_8h.html#a41b65ad20272f232f12c8ae36578d372">s2n_init()</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The overriden random callbacks will not be used when s2n-tls is operating in FIPS mode.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rand_init_callback</td><td>The s2n_rand_init_callback </td></tr>
    <tr><td class="paramname">rand_cleanup_callback</td><td>The s2n_rand_cleanup_callback </td></tr>
    <tr><td class="paramname">rand_seed_callback</td><td>The s2n_rand_seed_callback </td></tr>
    <tr><td class="paramname">rand_mix_callback</td><td>The s2n_rand_mix_callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a3b67ff058796d4c6c6caddfd0f10274e" name="a3b67ff058796d4c6c6caddfd0f10274e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b67ff058796d4c6c6caddfd0f10274e">&#9670;&#160;</a></span>s2n_recv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> ssize_t s2n_recv </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#af70ca0b089daa98cd79a424d3f6af15d">s2n_blocked_status</a> *&#160;</td>
          <td class="paramname"><em>blocked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Decrypts and reads **size* to <code>buf</code> data from the associated connection.</p>
<dl class="section note"><dt>Note</dt><dd>Unlike OpenSSL, repeated calls to <code>s2n_recv</code> should not duplicate the original parameters, but should update <code>buf</code> and <code>size</code> per the indication of size read.</dd></dl>
<p>See the following example for guidance on calling <code><a class="el" href="s2n_8h.html#a3b67ff058796d4c6c6caddfd0f10274e">s2n_recv()</a></code>: <a href="https://github.com/aws/s2n-tls/blob/main/docs/examples/s2n_recv.c">https://github.com/aws/s2n-tls/blob/main/docs/examples/s2n_recv.c</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object </td></tr>
    <tr><td class="paramname">buf</td><td>A pointer to a buffer that s2n will place read data into. </td></tr>
    <tr><td class="paramname">size</td><td>Size of <code>buf</code> </td></tr>
    <tr><td class="paramname">blocked</td><td>A pointer which will be set to the blocked status if an <code>S2N_ERR_T_BLOCKED</code> error is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read on success. 0 if the connection was shutdown by the peer. S2N_FAILURE on failure. </dd></dl>

</div>
</div>
<a id="a11320d9103cdfea8b24c7e9961e1b90c" name="a11320d9103cdfea8b24c7e9961e1b90c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11320d9103cdfea8b24c7e9961e1b90c">&#9670;&#160;</a></span>s2n_recv_early_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_recv_early_data </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>max_data_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t *&#160;</td>
          <td class="paramname"><em>data_received</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#af70ca0b089daa98cd79a424d3f6af15d">s2n_blocked_status</a> *&#160;</td>
          <td class="paramname"><em>blocked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Called by the server to begin negotiation and accept any early data the client sends.</p>
<p >See <a href="https://github.com/aws/s2n-tls/blob/main/docs/usage-guide/topics/ch14-early-data.md">https://github.com/aws/s2n-tls/blob/main/docs/usage-guide/topics/ch14-early-data.md</a> for usage and examples. DO NOT USE unless you have considered the security issues and implemented mitigation for anti-replay attacks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the connection </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to a buffer to store the early data received </td></tr>
    <tr><td class="paramname">max_data_len</td><td>The size of the early data buffer </td></tr>
    <tr><td class="paramname">data_received</td><td>A pointer which will be set to the size of the early data received </td></tr>
    <tr><td class="paramname">blocked</td><td>A pointer which will be set to the blocked status, as in <code>s2n_negotiate</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A POSIX error signal. The error should be handled as in <code>s2n_negotiate</code>. </dd></dl>

</div>
</div>
<a id="a9afeb514731fa9d74edf6b9e1348c067" name="a9afeb514731fa9d74edf6b9e1348c067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9afeb514731fa9d74edf6b9e1348c067">&#9670;&#160;</a></span>s2n_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> ssize_t s2n_send </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#af70ca0b089daa98cd79a424d3f6af15d">s2n_blocked_status</a> *&#160;</td>
          <td class="paramname"><em>blocked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Writes and encrypts <code>size</code> of <code>buf</code> data to the associated connection. <a class="el" href="s2n_8h.html#a9afeb514731fa9d74edf6b9e1348c067">s2n_send()</a> will return the number of bytes written, and may indicate a partial write.</p>
<dl class="section note"><dt>Note</dt><dd>Partial writes are possible not just for non-blocking I/O, but also for connections aborted while active. </dd>
<dd>
Unlike OpenSSL, repeated calls to <a class="el" href="s2n_8h.html#a9afeb514731fa9d74edf6b9e1348c067">s2n_send()</a> should not duplicate the original parameters, but should update <code>buf</code> and <code>size</code> per the indication of size written.</dd></dl>
<p>See the following example for guidance on calling <code><a class="el" href="s2n_8h.html#a9afeb514731fa9d74edf6b9e1348c067">s2n_send()</a></code>: <a href="https://github.com/aws/s2n-tls/blob/main/docs/examples/s2n_send.c">https://github.com/aws/s2n-tls/blob/main/docs/examples/s2n_send.c</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object </td></tr>
    <tr><td class="paramname">buf</td><td>A pointer to a buffer that s2n will write data from </td></tr>
    <tr><td class="paramname">size</td><td>The size of buf </td></tr>
    <tr><td class="paramname">blocked</td><td>A pointer which will be set to the blocked status if an <code>S2N_ERR_T_BLOCKED</code> error is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written on success, which may indicate a partial write. S2N_FAILURE on failure. </dd></dl>

</div>
</div>
<a id="a1dd564dedb16a7aa99863137a36bb8e8" name="a1dd564dedb16a7aa99863137a36bb8e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd564dedb16a7aa99863137a36bb8e8">&#9670;&#160;</a></span>s2n_send_early_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_send_early_data </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>data_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t *&#160;</td>
          <td class="paramname"><em>data_sent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#af70ca0b089daa98cd79a424d3f6af15d">s2n_blocked_status</a> *&#160;</td>
          <td class="paramname"><em>blocked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Called by the client to begin negotiation and send early data.</p>
<p >See <a href="https://github.com/aws/s2n-tls/blob/main/docs/usage-guide/topics/ch14-early-data.md">https://github.com/aws/s2n-tls/blob/main/docs/usage-guide/topics/ch14-early-data.md</a> for usage and examples. DO NOT USE unless you have considered the security issues and implemented mitigation for anti-replay attacks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the connection </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the early data to be sent </td></tr>
    <tr><td class="paramname">data_len</td><td>The size of the early data to send </td></tr>
    <tr><td class="paramname">data_sent</td><td>A pointer which will be set to the size of the early data sent </td></tr>
    <tr><td class="paramname">blocked</td><td>A pointer which will be set to the blocked status, as in <code>s2n_negotiate</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A POSIX error signal. The error should be handled as in <code>s2n_negotiate</code>. </dd></dl>

</div>
</div>
<a id="a726589f5cc8871b5efe9740aca05ed97" name="a726589f5cc8871b5efe9740aca05ed97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726589f5cc8871b5efe9740aca05ed97">&#9670;&#160;</a></span>s2n_sendv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> ssize_t s2n_sendv </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct iovec *&#160;</td>
          <td class="paramname"><em>bufs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#af70ca0b089daa98cd79a424d3f6af15d">s2n_blocked_status</a> *&#160;</td>
          <td class="paramname"><em>blocked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Works in the same way as <a class="el" href="s2n_8h.html#a1b09f96a5f4fe3b78a08e76e7304853f">s2n_sendv_with_offset()</a> but with the <code>offs</code> parameter implicitly assumed to be 0. Therefore in the partial write case, the caller would have to make sure that the <code>bufs</code> and <code>count</code> fields are modified in a way that takes the partial writes into account.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object </td></tr>
    <tr><td class="paramname">bufs</td><td>A pointer to a vector of buffers that s2n will write data from. </td></tr>
    <tr><td class="paramname">count</td><td>The number of buffers in <code>bufs</code> </td></tr>
    <tr><td class="paramname">blocked</td><td>A pointer which will be set to the blocked status if an <code>S2N_ERR_T_BLOCKED</code> error is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written on success, which may indicate a partial write. S2N_FAILURE on failure. </dd></dl>

</div>
</div>
<a id="a1b09f96a5f4fe3b78a08e76e7304853f" name="a1b09f96a5f4fe3b78a08e76e7304853f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b09f96a5f4fe3b78a08e76e7304853f">&#9670;&#160;</a></span>s2n_sendv_with_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> ssize_t s2n_sendv_with_offset </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct iovec *&#160;</td>
          <td class="paramname"><em>bufs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>offs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#af70ca0b089daa98cd79a424d3f6af15d">s2n_blocked_status</a> *&#160;</td>
          <td class="paramname"><em>blocked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Works in the same way as <a class="el" href="s2n_8h.html#a9afeb514731fa9d74edf6b9e1348c067">s2n_send()</a> except that it accepts vectorized buffers. Will return the number of bytes written, and may indicate a partial write. Partial writes are possible not just for non-blocking I/O, but also for connections aborted while active.</p>
<dl class="section note"><dt>Note</dt><dd>Partial writes are possible not just for non-blocking I/O, but also for connections aborted while active.</dd>
<dd>
Unlike OpenSSL, repeated calls to <a class="el" href="s2n_8h.html#a1b09f96a5f4fe3b78a08e76e7304853f">s2n_sendv_with_offset()</a> should not duplicate the original parameters, but should update <code>bufs</code> and <code>count</code> per the indication of size written.</dd></dl>
<p>See the following example for guidance on calling <code><a class="el" href="s2n_8h.html#a1b09f96a5f4fe3b78a08e76e7304853f">s2n_sendv_with_offset()</a></code>: <a href="https://github.com/aws/s2n-tls/blob/main/docs/examples/s2n_send.c">https://github.com/aws/s2n-tls/blob/main/docs/examples/s2n_send.c</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object </td></tr>
    <tr><td class="paramname">bufs</td><td>A pointer to a vector of buffers that s2n will write data from. </td></tr>
    <tr><td class="paramname">count</td><td>The number of buffers in <code>bufs</code> </td></tr>
    <tr><td class="paramname">offs</td><td>The write cursor offset. This should be updated as data is written. See the example code. </td></tr>
    <tr><td class="paramname">blocked</td><td>A pointer which will be set to the blocked status if an <code>S2N_ERR_T_BLOCKED</code> error is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written on success, which may indicate a partial write. S2N_FAILURE on failure. </dd></dl>

</div>
</div>
<a id="afa104cedfc08cb14579a6ee93c468b3a" name="afa104cedfc08cb14579a6ee93c468b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa104cedfc08cb14579a6ee93c468b3a">&#9670;&#160;</a></span>s2n_session_ticket_get_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_session_ticket_get_data </td>
          <td>(</td>
          <td class="paramtype">struct s2n_session_ticket *&#160;</td>
          <td class="paramname"><em>ticket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_data_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the session ticket data from a session ticket object.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Safety</h1>
<p >The entire session ticket will be copied into <code>data</code> on success. Therefore, <code>data</code> MUST have enough memory to store the session ticket data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ticket</td><td>Pointer to the session ticket object. </td></tr>
    <tr><td class="paramname">max_data_len</td><td>Maximum length of data that can be written to the 'data' pointer. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to where the session ticket data will be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe49863d3ac879da25dab8536da65450" name="afe49863d3ac879da25dab8536da65450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe49863d3ac879da25dab8536da65450">&#9670;&#160;</a></span>s2n_session_ticket_get_data_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_session_ticket_get_data_len </td>
          <td>(</td>
          <td class="paramtype">struct s2n_session_ticket *&#160;</td>
          <td class="paramname"><em>ticket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>data_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the length of the session ticket from a session ticket object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ticket</td><td>Pointer to the session ticket object. </td></tr>
    <tr><td class="paramname">data_len</td><td>Pointer to be set to the length of the session ticket on success. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ac4aef516a29664d6a771dbef829330" name="a5ac4aef516a29664d6a771dbef829330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac4aef516a29664d6a771dbef829330">&#9670;&#160;</a></span>s2n_session_ticket_get_lifetime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_session_ticket_get_lifetime </td>
          <td>(</td>
          <td class="paramtype">struct s2n_session_ticket *&#160;</td>
          <td class="paramname"><em>ticket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>session_lifetime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the lifetime in seconds of the session ticket from a session ticket object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ticket</td><td>Pointer to the session ticket object. </td></tr>
    <tr><td class="paramname">session_lifetime</td><td>Pointer to a variable where the lifetime of the session ticket will be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5c2488271997ea0b0b21d3937e612f6" name="af5c2488271997ea0b0b21d3937e612f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c2488271997ea0b0b21d3937e612f6">&#9670;&#160;</a></span>s2n_set_server_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_set_server_name </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>server_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the server name for the connection.</p>
<p >The provided server name will be sent by the client to the server in the server_name ClientHello extension. It may be desirable for clients to provide this information to facilitate secure connections to servers that host multiple 'virtual' servers at a single underlying network address.</p>
<p >s2n-tls does not place any restrictions on the provided server name. However, other TLS implementations might. Specifically, the TLS specification for the server_name extension requires that it be an ASCII-encoded DNS name without a trailing dot, and explicitly forbids literal IPv4 or IPv6 addresses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The connection object being queried </td></tr>
    <tr><td class="paramname">server_name</td><td>A pointer to a string containing the desired server name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd><code>server_name</code> must be a NULL terminated string. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="aff6abacafd51a48a2870755d765f56e8" name="aff6abacafd51a48a2870755d765f56e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff6abacafd51a48a2870755d765f56e8">&#9670;&#160;</a></span>s2n_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_shutdown </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#af70ca0b089daa98cd79a424d3f6af15d">s2n_blocked_status</a> *&#160;</td>
          <td class="paramname"><em>blocked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attempts a closure at the TLS layer. Does not close the underlying transport. This call may block in either direction.</p>
<p >Unlike other TLS implementations, <code>s2n_shutdown</code> attempts a graceful shutdown by default. It will not return with success unless a close_notify alert is successfully sent and received. As a result, <code>s2n_shutdown</code> may fail when interacting with a non-conformant TLS implementation.</p>
<p >Once <code>s2n_shutdown</code> is complete:</p><ul>
<li>The s2n_connection handle cannot be used for reading for writing.</li>
<li>The underlying transport can be closed. Most likely via <code>shutdown()</code> or <code>close()</code>.</li>
<li>The s2n_connection handle can be freed via <a class="el" href="s2n_8h.html#a9c7664ec2fe4c694148ad303f4229f94">s2n_connection_free()</a> or reused via <a class="el" href="s2n_8h.html#ae42c3c7b37df666c2b3e6a53c1ea5f76">s2n_connection_wipe()</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object </td></tr>
    <tr><td class="paramname">blocked</td><td>A pointer which will be set to the blocked status if an <code>S2N_ERR_T_BLOCKED</code> error is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="aed14fae7ae16fffda06087b8aec78035" name="aed14fae7ae16fffda06087b8aec78035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed14fae7ae16fffda06087b8aec78035">&#9670;&#160;</a></span>s2n_shutdown_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_shutdown_send </td>
          <td>(</td>
          <td class="paramtype">struct s2n_connection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="s2n_8h.html#af70ca0b089daa98cd79a424d3f6af15d">s2n_blocked_status</a> *&#160;</td>
          <td class="paramname"><em>blocked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attempts to close the write side of the TLS connection.</p>
<p >TLS1.3 supports closing the write side of a TLS connection while leaving the read side unaffected. This feature is usually referred to as "half-close". We send a close_notify alert, but do not wait for the peer to respond.</p>
<p >Like <code><a class="el" href="s2n_8h.html#aff6abacafd51a48a2870755d765f56e8">s2n_shutdown()</a></code>, this method does not affect the underlying transport.</p>
<p ><code><a class="el" href="s2n_8h.html#aed14fae7ae16fffda06087b8aec78035">s2n_shutdown_send()</a></code> may still be called for earlier TLS versions, but most TLS implementations will react by immediately discarding any pending writes and closing the connection.</p>
<p >Once <code><a class="el" href="s2n_8h.html#aed14fae7ae16fffda06087b8aec78035">s2n_shutdown_send()</a></code> is complete:</p><ul>
<li>The s2n_connection handle CANNOT be used for writing.</li>
<li>The s2n_connection handle CAN be used for reading.</li>
<li>The write side of the underlying transport can be closed. Most likely via <code>shutdown()</code>.</li>
</ul>
<p >The application should still call <code><a class="el" href="s2n_8h.html#aff6abacafd51a48a2870755d765f56e8">s2n_shutdown()</a></code> or wait for <code><a class="el" href="s2n_8h.html#a3b67ff058796d4c6c6caddfd0f10274e">s2n_recv()</a></code> to return 0 to indicate end-of-data before cleaning up the connection or closing the read side of the underlying transport.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the s2n_connection object </td></tr>
    <tr><td class="paramname">blocked</td><td>A pointer which will be set to the blocked status if an <code>S2N_ERR_T_BLOCKED</code> error is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="ad2220ac8657a5417ee02e8da3b7789b1" name="ad2220ac8657a5417ee02e8da3b7789b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2220ac8657a5417ee02e8da3b7789b1">&#9670;&#160;</a></span>s2n_stack_traces_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> bool s2n_stack_traces_enabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Checks if s2n stack trace captures are enabled.</p>
<dl class="section return"><dt>Returns</dt><dd>True if stack traces are enabled. False if they are disabled. </dd></dl>

</div>
</div>
<a id="a997548b3339d0ee7d154911c733f2126" name="a997548b3339d0ee7d154911c733f2126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a997548b3339d0ee7d154911c733f2126">&#9670;&#160;</a></span>s2n_stack_traces_enabled_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> int s2n_stack_traces_enabled_set </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Configures the s2n stack trace captures option.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newval</td><td>Boolean to determine if stack traces should be enabled. True to enable them. False to disable them. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S2N_SUCCESS on success. S2N_FAILURE on failure </dd></dl>

</div>
</div>
<a id="a57e354c1c73d75888997a81353ea616b" name="a57e354c1c73d75888997a81353ea616b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e354c1c73d75888997a81353ea616b">&#9670;&#160;</a></span>s2n_strerror()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> const char * s2n_strerror </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Translates an s2n_error code to a human readable string explaining the error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>The error code to explain. Usually this is s2n_errno </td></tr>
    <tr><td class="paramname">lang</td><td>The language to explain the error code. Pass "EN" or NULL for English. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The error string </dd></dl>

</div>
</div>
<a id="abe953bd1887fbd7812beebc180639baa" name="abe953bd1887fbd7812beebc180639baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe953bd1887fbd7812beebc180639baa">&#9670;&#160;</a></span>s2n_strerror_debug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> const char * s2n_strerror_debug </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Translates an s2n_error code to a human readable string containing internal debug information, including file name and line number. This function is useful when reporting issues to the s2n-tls development team.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>The error code to explain. Usually this is s2n_errno </td></tr>
    <tr><td class="paramname">lang</td><td>The language to explain the error code. Pass "EN" or NULL for English. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The error string </dd></dl>

</div>
</div>
<a id="a114d3d3ce1bb2a59ee44434af04b068c" name="a114d3d3ce1bb2a59ee44434af04b068c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114d3d3ce1bb2a59ee44434af04b068c">&#9670;&#160;</a></span>s2n_strerror_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> const char * s2n_strerror_name </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Translates an s2n_error code to a human readable string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>The error code to explain. Usually this is s2n_errno </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The error string </dd></dl>

</div>
</div>
<a id="a87f6086b173925bd39185c79538dfdf5" name="a87f6086b173925bd39185c79538dfdf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f6086b173925bd39185c79538dfdf5">&#9670;&#160;</a></span>s2n_strerror_source()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> const char * s2n_strerror_source </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Translates an s2n_error code to a filename and line number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>The error code to explain. Usually this is s2n_errno. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The error string. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a24fa509b7e7b509825866d83a00333d1" name="a24fa509b7e7b509825866d83a00333d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24fa509b7e7b509825866d83a00333d1">&#9670;&#160;</a></span>s2n_errno</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="s2n_8h.html#af1c2b8586154a9094d6978137ef001ac">S2N_API</a> __thread int s2n_errno</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >s2n-tls functions that return 'int' return 0 to indicate success and -1 to indicate failure.</p>
<p >s2n-tls functions that return pointer types return NULL in the case of failure.</p>
<p >When an s2n-tls function returns a failure, s2n_errno will be set to a value corresponding to the error. This error value can be translated into a string explaining the error in English by calling s2n_strerror(s2n_errno, "EN"). A string containing human readable error name; can be generated with <code>s2n_strerror_name</code>. A string containing internal debug information, including filename and line number, can be generated with <code>s2n_strerror_debug</code>. A string containing only the filename and line number can be generated with <code>s2n_strerror_source</code>. This string is useful to include when reporting issues to the s2n-tls development team.</p>
<dl class="section warning"><dt>Warning</dt><dd>To avoid possible confusion, s2n_errno should be cleared after processing an error: <code>s2n_errno = S2N_ERR_T_OK</code> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
