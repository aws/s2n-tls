<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>IO</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="ch00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-api.html"><strong aria-hidden="true">1.</strong> s2n-tls API</a></li><li class="chapter-item expanded "><a href="ch02-initialization.html"><strong aria-hidden="true">2.</strong> Initialization and Teardown</a></li><li class="chapter-item expanded "><a href="ch03-error-handling.html"><strong aria-hidden="true">3.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="ch04-connection.html"><strong aria-hidden="true">4.</strong> TLS Connections</a></li><li class="chapter-item expanded "><a href="ch05-config.html"><strong aria-hidden="true">5.</strong> Configuring the Connection</a></li><li class="chapter-item expanded "><a href="ch06-security-policies.html"><strong aria-hidden="true">6.</strong> Security Policies</a></li><li class="chapter-item expanded "><a href="ch07-io.html" class="active"><strong aria-hidden="true">7.</strong> IO</a></li><li class="chapter-item expanded "><a href="ch08-record-sizes.html"><strong aria-hidden="true">8.</strong> TLS Record Sizes</a></li><li class="chapter-item expanded "><a href="ch09-certificates.html"><strong aria-hidden="true">9.</strong> Certificates and Authentication</a></li><li class="chapter-item expanded "><a href="ch10-client-hello.html"><strong aria-hidden="true">10.</strong> Examining the Client Hello</a></li><li class="chapter-item expanded "><a href="ch11-resumption.html"><strong aria-hidden="true">11.</strong> Session Resumption</a></li><li class="chapter-item expanded "><a href="ch12-private-key-ops.html"><strong aria-hidden="true">12.</strong> Offloading Private Key Operations</a></li><li class="chapter-item expanded "><a href="ch13-preshared-keys.html"><strong aria-hidden="true">13.</strong> Pre-shared Keys</a></li><li class="chapter-item expanded "><a href="ch14-early-data.html"><strong aria-hidden="true">14.</strong> Early Data</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="sending-and-receiving"><a class="header" href="#sending-and-receiving">Sending and Receiving</a></h1>
<h2 id="basic-io-setup"><a class="header" href="#basic-io-setup">Basic IO setup</a></h2>
<p>By default, s2n-tls sends and receives data using a provided file descriptor
(usually a socket) and the read/write system calls. The file descriptor can be set with
<code>s2n_connection_set_fd()</code>, or separate read and write file descriptors can be
set with <code>s2n_connection_set_read_fd()</code> and <code>s2n_connection_set_write_fd()</code>.
The provided file descriptor should be active and connected.</p>
<p>In general the application is free to configure the file descriptor as preferred,
including socket options. s2n-tls itself sets a few socket options:</p>
<ul>
<li>If available, TCP_QUICKACK is used during the TLS handshake</li>
<li>If available and enabled via <code>s2n_connection_use_corked_io()</code>, TCP_CORK is
used during the TLS handshake. TCP_NOPUSH or TCP_NODELAY may be used if TCP_CORK
is not available.</li>
</ul>
<p><strong>Important Note:</strong>
If the read end of the pipe is closed unexpectedly, writing to the pipe will raise
a SIGPIPE signal. <strong>s2n-tls does NOT handle SIGPIPE.</strong> A SIGPIPE signal will cause
the process to terminate unless it is handled or ignored by the application.
See the <a href="https://linux.die.net/man/2/signal">signal man page</a> for instructions on
how to handle C signals, or simply ignore the SIGPIPE signal by calling
<code>signal(SIGPIPE, SIG_IGN)</code> before calling any s2n-tls IO methods.</p>
<h2 id="blocking-or-non-blocking"><a class="header" href="#blocking-or-non-blocking">Blocking or Non-Blocking?</a></h2>
<p>s2n-tls supports both blocking and non-blocking I/O.</p>
<ul>
<li>In blocking mode, each s2n-tls I/O function will not return until it has completed
the requested IO operation.</li>
<li>In non-blocking mode, s2n-tls I/O functions will immediately return, even if the socket couldn't
send or receive all the requested data. In this case, the I/O function will return <code>S2N_FAILURE</code>,
and <code>s2n_error_get_type()</code> will return <code>S2N_ERR_T_BLOCKED</code>. The I/O operation will have to be
called again in order to send or receive the remaining requested data.</li>
</ul>
<p>Some s2n-tls I/O functions take a <code>blocked</code> argument. If an I/O function returns an
<code>S2N_ERR_T_BLOCKED</code> error, the <code>blocked</code> argument will be set to a <code>s2n_blocked_status</code> value,
indicating what s2n-tls is currently blocked on. Note that unless an I/O function returns
<code>S2N_FAILURE</code> with an <code>S2N_ERR_T_BLOCKED</code> error, the <code>blocked</code> argument is meaningless, and should
not be used in any application logic.</p>
<p>Servers in particular usually prefer non-blocking mode. In blocking mode, a single connection
blocks the thread while waiting for more IO. In non-blocking mode, multiple connections
can make progress by returning control while waiting for more IO using methods like
<a href="https://linux.die.net/man/2/poll"><code>poll</code></a> or <a href="https://linux.die.net/man/2/select"><code>select</code></a>.</p>
<p>To use s2n-tls in non-blocking mode, set the underlying file descriptors as non-blocking.
For example:</p>
<pre><code class="language-c">int flags = fcntl(fd, F_GETFL, 0);
if (flags &lt; 0) return S2N_FAILURE;
if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) &lt; 0) return S2N_FAILURE;
</code></pre>
<h2 id="errors-and-alerts"><a class="header" href="#errors-and-alerts">Errors and Alerts</a></h2>
<p>If the peer sends an alert, the next call to a read IO method will report <strong>S2N_FAILURE</strong> and
<code>s2n_error_get_type()</code> will return <strong>S2N_ERR_T_ALERT</strong>. The specific alert received
is available by calling <code>s2n_connection_get_alert()</code>.</p>
<p>In TLS1.3, all alerts are fatal. s2n-tls also treats all alerts as fatal in earlier
versions of TLS by default. <code>s2n_config_set_alert_behavior()</code> can be called to
force s2n-tls to treat pre-TLS1.3 warning alerts as not fatal, but that behavior
is not recommended unless required for compatibility. In the past, attacks against
TLS have involved manipulating the alert level to disguise fatal alerts as warnings.</p>
<p>If s2n-tls encounters a fatal error, the next call to a write IO method will send
a close_notify alert to the peer. Except for a few exceptions, s2n-tls does not
send specific alerts in order to avoid leaking information that could be used for
a sidechannel attack. To ensure that the alert is sent, <code>s2n_shutdown()</code> should
be called after an error.</p>
<h2 id="performing-the-tls-handshake"><a class="header" href="#performing-the-tls-handshake">Performing the TLS Handshake</a></h2>
<p>Before application data can be sent or received, an application must perform a handshake
to establish a TLS connection with the peer.</p>
<p>To perform the handshake, call <code>s2n_negotiate()</code> until it either returns <strong>S2N_SUCCESS</strong>
or returns <strong>S2N_FAILURE</strong> without a <strong>S2N_ERR_T_BLOCKED</strong> error.</p>
<p>For an example of how to perform a basic handshake, see <a href="https://github.com/aws/s2n-tls/blob/main/docs/examples/s2n_negotiate.c">examples/s2n_negotiate.c</a></p>
<h2 id="application-data"><a class="header" href="#application-data">Application Data</a></h2>
<p>After the TLS handshake, an application can send and receive encrypted data.</p>
<p>Although most s2n-tls APIs are not thread-safe, <code>s2n_send()</code> and <code>s2n_recv()</code>
may be called simultaneously from two different threads. This means that an
application may have one thread calling <code>s2n_send()</code> and one thread calling <code>s2n_recv()</code>,
but NOT multiple threads calling <code>s2n_recv()</code> or multiple threads calling <code>s2n_send()</code>.</p>
<p>Even if an application only intends to send data or only intends to receive data,
it should implement both send and receive in order to handle alerts and post-handshake
TLS control messages like session tickets.</p>
<h3 id="sending-application-data"><a class="header" href="#sending-application-data">Sending Application Data</a></h3>
<p><code>s2n_send()</code> and its variants encrypt and send application data to the peer.
The sending methods return the number of bytes written and may indicate a partial
write. Partial writes are possible not just for non-blocking I/O, but also for
connections aborted while active.</p>
<p>A single call to <code>s2n_send()</code> may involve multiple system calls to write the
provided application data. s2n-tls breaks the application data into fixed-sized
records before encryption, and calls write for each record.
<a href="./ch08-record-sizes.html">See the record size documentation for how record size may impact performance</a>.</p>
<p>In non-blocking mode, <code>s2n_send()</code> will send data from the provided buffer and return the number of
bytes sent, as long as the socket was able to send at least 1 byte. If no bytes could be sent on the
socket, <code>s2n_send()</code> will return <code>S2N_FAILURE</code>, and <code>s2n_error_get_type()</code> will return
<code>S2N_ERR_T_BLOCKED</code>. To ensure that all the provided data gets sent, applications should continue
calling <code>s2n_send()</code> until the return values across all calls have added up to the length of the
data, or until <code>s2n_send()</code> returns an <code>S2N_ERR_T_BLOCKED</code> error. After an <code>S2N_ERR_T_BLOCKED</code>
error is returned, applications should call <code>s2n_send()</code> again only after the socket is
able to send more data. This can be determined by using methods like
<a href="https://linux.die.net/man/2/poll"><code>poll</code></a> or <a href="https://linux.die.net/man/2/select"><code>select</code></a>.</p>
<p>Unlike OpenSSL, repeated calls to <code>s2n_send()</code> should not duplicate the original
parameters, but should update the inputs per the indication of size written.</p>
<p><code>s2n_sendv_with_offset()</code> behaves like <code>s2n_send()</code>, but supports vectorized buffers.
The offset input should be updated between calls to reflect the data already written.</p>
<p><code>s2n_sendv()</code> also supports vectorized buffers, but assumes an offset of 0.
Because of this assumption, a caller would have to make sure that the input vectors
are updated to account for a partial write. Therefore <code>s2n_sendv_with_offset()</code>
is preferred.</p>
<p>For examples of how to send <code>data</code> of length <code>data_size</code> with <code>s2n_send()</code>
or <code>s2n_sendv_with_offset()</code>, see <a href="https://github.com/aws/s2n-tls/blob/main/docs/examples/s2n_send.c">examples/s2n_send.c</a></p>
<h3 id="receiving-application-data"><a class="header" href="#receiving-application-data">Receiving Application Data</a></h3>
<p><code>s2n_recv()</code> reads and decrypts application data from the peer, copying it into
the application-provided output buffer. It returns the number of bytes read, and
may indicate a partial read even if blocking IO is used.
It returns &quot;0&quot; to indicate that the peer has shutdown the connection.</p>
<p>By default, <code>s2n_recv()</code> will return after reading a single TLS record. <code>s2n_recv()</code> can be called
repeatedly to read multiple records. To allow <code>s2n_recv()</code> to read multiple records with a single
call, use <code>s2n_config_set_recv_multi_record()</code>.</p>
<p>In non-blocking mode, <code>s2n_recv()</code> will read data into the provided buffer and return the number of
bytes read, as long as at least 1 byte was read from the socket. If no bytes could be read from the
socket, <code>s2n_recv()</code> will return <code>S2N_FAILURE</code>, and <code>s2n_error_get_type()</code> will return
<code>S2N_ERR_T_BLOCKED</code>. To ensure that all data on the socket is properly received, applications
should continue calling <code>s2n_recv()</code> until it returns an <code>S2N_ERR_T_BLOCKED</code> error. After an
<code>S2N_ERR_T_BLOCKED</code> error is returned, applications should call <code>s2n_recv()</code> again only after the
socket has received more data. This can be determined by using methods like
<a href="https://linux.die.net/man/2/poll"><code>poll</code></a> or <a href="https://linux.die.net/man/2/select"><code>select</code></a>.</p>
<p>Unlike OpenSSL, repeated calls to <code>s2n_recv()</code> should not duplicate the original parameters,
but should update the inputs per the indication of size read.</p>
<p>For an example of how to read all the data sent by the peer into one buffer,
see <code>s2n_example_recv()</code> in <a href="https://github.com/aws/s2n-tls/blob/main/docs/examples/s2n_recv.c">examples/s2n_recv.c</a></p>
<p>For an example of how to echo any data sent by the peer,
see <code>s2n_example_recv_echo()</code> in <a href="https://github.com/aws/s2n-tls/blob/main/docs/examples/s2n_recv.c">examples/s2n_recv.c</a></p>
<p><code>s2n_peek()</code> can be used to check if more application data may be returned
from <code>s2n_recv()</code> without performing another read from the file descriptor.
This is useful when using <code>select()</code> on the underlying s2n-tls file descriptor, because
a call to <code>s2n_recv()</code> may read more data into s2n-tls's internal buffer than
was requested or can fit into the application-provided output buffer. This extra
application data will be returned by the next call to <code>s2n_recv()</code>, but <code>select()</code>
will be unable to tell the application that there is more data available and that
<code>s2n_recv()</code> should be called again. An application can solve this problem by
calling <code>s2n_peek()</code> to determine if <code>s2n_recv()</code> needs to be called again.</p>
<h2 id="closing-the-connection"><a class="header" href="#closing-the-connection">Closing the Connection</a></h2>
<p><code>s2n_shutdown()</code> attempts a graceful closure at the TLS layer. It does not close the
underlying transport. The call may block on either reading or writing.</p>
<p><code>s2n_shutdown()</code> should be called after an error in order to ensure that s2n-tls
sends an alert to notify the peer of the failure.</p>
<p><code>s2n_shutdown()</code> will discard any application data received from the peer. This
can lead to data truncation, so <code>s2n_shutdown_send()</code> may be preferred for TLS1.3
connections where the peer continues sending after the application initiates
shutdown. See <a href="#closing-the-connection-for-writes">Closing the connection for writes</a>
below.</p>
<p>Because <code>s2n_shutdown()</code> attempts a graceful shutdown, it will not return success
unless a close_notify alert is successfully both sent and received. As a result,
<code>s2n_shutdown()</code> may fail when interacting with a non-conformant TLS implementation
or if called on a connection in a bad state.</p>
<p>Once <code>s2n_shutdown()</code> is complete:</p>
<ul>
<li>The s2n_connection handle cannot be used for reading or writing.</li>
<li>The underlying transport can be closed, most likely via <code>shutdown()</code> or <code>close()</code>.</li>
<li>The s2n_connection handle can be freed via <code>s2n_connection_free()</code> or reused
via <code>s2n_connection_wipe()</code></li>
</ul>
<h3 id="closing-the-connection-for-writes"><a class="header" href="#closing-the-connection-for-writes">Closing the connection for writes</a></h3>
<p>TLS1.3 supports closing the write side of a TLS connection while leaving the read
side unaffected. This indicates &quot;end-of-data&quot; to the peer without preventing
future reads. This feature is usually referred to as &quot;half-close&quot;.</p>
<p>s2n-tls offers the <code>s2n_shutdown_send()</code> method to close the write side of
a connection. Unlike <code>s2n_shutdown()</code>, it does not wait for the peer to respond
with a close_notify alert and does not discard any incoming application data. An
application can continue to call <code>s2n_recv()</code> after a call to <code>s2n_shutdown_send()</code>.</p>
<p><code>s2n_shutdown_send()</code> may still be called for earlier TLS versions, but most
TLS implementations will react by immediately discarding any pending writes and
closing the connection.</p>
<p>If <code>s2n_shutdown_send()</code> is used, the application should still call <code>s2n_shutdown()</code>
or wait for <code>s2n_recv()</code> to return 0 to indicate end-of-data before cleaning up
the connection or closing the read side of the underlying transport.</p>
<h2 id="custom-io-callbacks"><a class="header" href="#custom-io-callbacks">Custom IO Callbacks</a></h2>
<p>By default, s2n-tls sends and receives data using a provided file descriptor
(usually a socket) and the read/write system calls. To change this default behavior,
an application can implement custom send and receive methods using <code>s2n_connection_set_recv_cb()</code>
and <code>s2n_connection_set_send_cb()</code>.
The application can pass inputs (such as a file descriptor or destination buffer)
to the custom IO methods by using <code>s2n_connection_set_recv_ctx()</code> and <code>s2n_connection_set_send_ctx()</code>.
s2n-tls will call the custom IO methods with the custom context instead of calling
the default implementation.</p>
<p>The custom IO methods may send or receive less than the requested length. They
should return the number of bytes sent/received, or set errno and return an error code &lt; 0.
s2n-tls will interpret errno set to EWOULDBLOCK or EAGAIN as indicating a retriable
blocking error, and set <strong>s2n_errno</strong> and the s2n_blocked_status appropriately.
s2n-tls will interpret a return value of 0 as a closed connection.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch06-security-policies.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch08-record-sizes.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch06-security-policies.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch08-record-sizes.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
