SPECIFICATION: https://datatracker.ietf.org/doc/id/draft-agl-tls-nextprotoneg-03
  SECTION: [Next Protocol Negotiation Extension](#section-3)
    TEXT[implementation]:    The "extension_data" field of a "next_protocol_negotiation" extension
    TEXT[implementation]:    in a "ServerHello" contains an optional list of protocols advertised
    TEXT[implementation]:    by the server.
    TEXT[implementation,test]: The length of
    TEXT[implementation,test]:    "padding" SHOULD be 32 - ((len(selected_protocol) + 2) % 32).
    TEXT[implementation,test]:    For the same reasons, after a handshake has been performed for a
    TEXT[implementation,test]:    given connection, renegotiations on the same connection MUST NOT
    TEXT[implementation,test]:    include the "next_protocol_negotiation" extension.

  SECTION: [Protocol selection](#section-4)
    TEXT[implementation,test]: In the
    TEXT[implementation,test]:    event that the client doesn't support any of server's protocols, or
    TEXT[implementation,test]:    the server doesn't advertise any, it SHOULD select the first protocol
    TEXT[implementation,test]:    that it supports.

SPECIFICATION: [JA4: TLS Client Fingerprinting](https://raw.githubusercontent.com/FoxIO-LLC/ja4/df3c067/technical_details/JA4.md)
  SECTION: [JA4 Algorithm:](#ja4-algorithm)
    TEXT[implementation]: (QUIC=”q”, DTLS="d", or Normal TLS=”t”)
    TEXT[implementation]: (2 character TLS version)
    TEXT[implementation]: (SNI=”d” or no SNI=”i”)
    TEXT[implementation]: (2 character count of ciphers)
    TEXT[implementation]: (2 character count of extensions)
    TEXT[implementation]: (first and last characters of first ALPN extension value)
    TEXT[implementation]: (sha256 hash of the list of cipher hex codes sorted in hex order, truncated to 12 characters)
    TEXT[implementation]: (sha256 hash of (the list of extension hex codes sorted in hex order)_(the list of signature algorithms), truncated to 12 characters)
    TEXT[implementation]: The end result is a fingerprint that looks like:
    TEXT[implementation]: t13d1516h2_8daaf6152771_b186095e22b6

  SECTION: [Details:](#details)
    TEXT[!MUST,implementation]: The program needs to ignore GREASE values anywhere it sees them

  SECTION: [QUIC and DTLS:](#quic-and-dtls)
    TEXT[!MUST,implementation,test]: If the protocol is QUIC then the first character of the fingerprint is “q”, if DTLS it is "d", else it is “t”.

  SECTION: [TLS and DTLS Version:](#tls-and-dtls-version)
    TEXT[!MUST,implementation,test]: If extension 0x002b exists (supported_versions), then the version is the highest value in the extension.
    TEXT[!MUST,implementation,test]: Remember to ignore GREASE values.
    TEXT[!MUST,implementation,test]: If the extension doesn’t exist, then the TLS version is the value of the Protocol Version.
    TEXT[!MUST,implementation,test]: Handshake version (located at the top of the packet) should be ignored.
    TEXT[implementation,test]: 0x0304 = TLS 1.3 = “13”
    TEXT[implementation,test]: 0x0303 = TLS 1.2 = “12”
    TEXT[implementation,test]: 0x0302 = TLS 1.1 = “11”
    TEXT[implementation,test]: 0x0301 = TLS 1.0 = “10”
    TEXT[implementation,test]: 0x0300 = SSL 3.0 = “s3”
    TEXT[implementation,test]: 0x0002 = SSL 2.0 = “s2”
    TEXT[implementation]: Unknown = “00”

  SECTION: [SNI:](#sni)
    TEXT[!MUST,implementation,test]: If the SNI extension (0x0000) exists, then the destination of the connection is a domain, or “d” in the fingerprint.
    TEXT[!MUST,implementation,test]: If the SNI does not exist, then the destination is an IP address, or “i”.

  SECTION: [Number of Ciphers:](#number-of-ciphers)
    TEXT[!MUST,implementation,test]: 2 character number of cipher suites, so if there’s 6 cipher suites in the hello packet, then the value should be “06”.
    TEXT[!MUST,implementation,test]: If there’s > 99, which there should never be, then output “99”.
    TEXT[!MUST,implementation,test]: Remember, ignore GREASE values. They don’t count.

  SECTION: [Number of Extensions:](#number-of-extensions)
    TEXT[!MUST,implementation,test]: Same as counting ciphers.
    TEXT[!MUST,implementation,test]: Ignore GREASE.
    TEXT[!MUST,implementation,test]: Include SNI and ALPN.

  SECTION: [ALPN Extension Value:](#alpn-extension-value)
    TEXT[!MUST,implementation,test]: The first and last alphanumeric characters of the ALPN (Application-Layer Protocol Negotiation) first value.
    TEXT[test]: In the above example, the first ALPN value is h2 so the first and last characters to use in the fingerprint are “h2”.
    TEXT[test]: If the first ALPN listed was http/1.1 then the first and last characters to use in the fingerprint would be “h1”.
    TEXT[!MUST,implementation,test]: If there is no ALPN extension, no ALPN values, or the first ALPN value is empty, then we print "00" as the value in the fingerprint.
    TEXT[!MUST,implementation,test]: If the first ALPN value is only a single character, then that character is treated as both the first and last character.
    TEXT[!MUST,implementation,test]: If the first or last byte of the first ALPN is non-alphanumeric (meaning not `0x30-0x39`, `0x41-0x5A`, or `0x61-0x7A`), then we print the first and last characters of the hex representation of the first ALPN instead.
    TEXT[test]: For example:
    TEXT[test]: * `0xAB` would be printed as "ab"
    TEXT[test]: * `0xAB 0xCD` would be printed as "ad"
    TEXT[test]: * `0x30 0xAB` would be printed as "3b"
    TEXT[test]: * `0x30 0x31 0xAB 0xCD` would be printed as "3d"
    TEXT[test]: * `0x30 0xAB 0xCD 0x31` would be printed as "01"

  SECTION: [Cipher hash:](#cipher-hash)
    TEXT[!MUST,implementation,test]: A 12 character truncated sha256 hash of the list of ciphers sorted in hex order, first 12 characters.
    TEXT[!MUST,implementation,test]: The list is created using the 4 character hex values of the ciphers, lower case, comma delimited, ignoring GREASE.
    TEXT[test]: Example:
    TEXT[test]: ```
    TEXT[test]: 1301,1302,1303,c02b,c02f,c02c,c030,cca9,cca8,c013,c014,009c,009d,002f,0035
    TEXT[test]: ```
    TEXT[test]: 002f,0035,009c,009d,1301,1302,1303,c013,c014,c02b,c02c,c02f,c030,cca8,cca9
    TEXT[test]: = 8daaf6152771
    TEXT[!MUST,implementation,test]: If there are no ciphers in the sorted cipher list, then the value of JA4_b is set to `000000000000`

  SECTION: [Extension hash:](#extension-hash)
    TEXT[!MUST,implementation,test]: A 12 character truncated sha256 hash of the list of extensions, sorted by hex value, followed by the list of signature algorithms, in the order that they appear (not sorted).
    TEXT[!MUST,implementation,test]: The extension list is created using the 4 character hex values of the extensions, lower case, comma delimited, sorted (not in the order they appear).
    TEXT[!MUST,implementation,test]: Ignore the SNI extension (0000) and the ALPN extension (0010) as we’ve already captured them in the _a_ section of the fingerprint.
    TEXT[test]: For example:
    TEXT[test]: ```
    TEXT[test]: 001b,0000,0033,0010,4469,0017,002d,000d,0005,0023,0012,002b,ff01,000b,000a,0015
    TEXT[test]: ```
    TEXT[test]: 0005,000a,000b,000d,0012,0015,0017,001b,0023,002b,002d,0033,4469,ff01
    TEXT[!MUST,implementation,test]: The signature algorithm hex values are then added to the end of the list in the order that they appear (not sorted) with an underscore delimiting the two lists.
    TEXT[test]: For example the signature algorithms:
    TEXT[test]: ```
    TEXT[test]: 0403,0804,0401,0503,0805,0501,0806,0601
    TEXT[test]: ```
    TEXT[test]: Are added to the end of the previous string to create:
    TEXT[test]: ```
    TEXT[test]: 0005,000a,000b,000d,0012,0015,0017,001b,0023,002b,002d,0033,4469,ff01_0403,0804,0401,0503,0805,0501,0806,0601
    TEXT[test]: ```
    TEXT[test]: Hashed to:
    TEXT[test]: ```
    TEXT[test]: e5627efa2ab19723084c1033a96c694a45826ab5a460d2d3fd5ffcfe97161c95
    TEXT[test]: ```
    TEXT[test]: Truncated to first 12 characters:
    TEXT[test]: ```
    TEXT[test]: e5627efa2ab1
    TEXT[test]: ```
    TEXT[!MUST,implementation,test]: If there are no signature algorithms in the hello packet, then the string ends without an underscore and is hashed.
    TEXT[!MUST,implementation,test]: If there are no extensions in the sorted extensions list, then the value of JA4_c is set to `000000000000`

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc4492
  SECTION: [Key Exchange Algorithms](#section-2)
    TEXT[!SHOULD]: Implementations of this
    TEXT[!SHOULD]:    algorithm SHOULD provide authentication by other means.

  SECTION: [ECDH_ECDSA](#section-2.1)
    TEXT[!MUST]:    In ECDH_ECDSA, the server's certificate MUST contain an ECDH-capable
    TEXT[!MUST]:    public key and be signed with ECDSA.
    TEXT[!MUST]:    A ServerKeyExchange MUST NOT be sent (the server's certificate
    TEXT[!MUST]:    contains all the necessary keying information required by the client
    TEXT[!MUST]:    to arrive at the premaster secret).

  SECTION: [ECDHE_ECDSA](#section-2.2)
    TEXT[!MUST]:    In ECDHE_ECDSA, the server's certificate MUST contain an ECDSA-
    TEXT[!MUST]:    capable public key and be signed with ECDSA.
    TEXT[!MUST]: These
    TEXT[!MUST]:    parameters MUST be signed with ECDSA using the private key
    TEXT[!MUST]:    corresponding to the public key in the server's Certificate.

  SECTION: [ECDH_RSA](#section-2.3)
    TEXT[!MUST]:    This key exchange algorithm is the same as ECDH_ECDSA except that the
    TEXT[!MUST]:    server's certificate MUST be signed with RSA rather than ECDSA.

  SECTION: [ECDHE_RSA](#section-2.4)
    TEXT[!MUST]:    This key exchange algorithm is the same as ECDHE_ECDSA except that
    TEXT[!MUST]:    the server's certificate MUST contain an RSA public key authorized
    TEXT[!MUST]:    for signing, and that the signature in the ServerKeyExchange message
    TEXT[!MUST]:    must be computed with the corresponding RSA private key.
    TEXT[!MUST]: The server
    TEXT[!MUST]:    certificate MUST be signed with RSA.

  SECTION: [ECDH_anon](#section-2.5)
    TEXT[!MUST]:    In ECDH_anon, the server's Certificate, the CertificateRequest, the
    TEXT[!MUST]:    client's Certificate, and the CertificateVerify messages MUST NOT be
    TEXT[!MUST]:    sent.
    TEXT[!MUST]:    The server MUST send an ephemeral ECDH public key and a specification
    TEXT[!MUST]:    of the corresponding curve in the ServerKeyExchange message.
    TEXT[!MUST]: These
    TEXT[!MUST]:    parameters MUST NOT be signed.

  SECTION: [ECDSA_sign](#section-3.1)
    TEXT[!MUST]:    To use this authentication mechanism, the client MUST possess a
    TEXT[!MUST]:    certificate containing an ECDSA-capable public key and signed with
    TEXT[!MUST]:    ECDSA.

  SECTION: [ECDSA_fixed_ECDH](#section-3.2)
    TEXT[!MUST]:    To use this authentication mechanism, the client MUST possess a
    TEXT[!MUST]:    certificate containing an ECDH-capable public key, and that
    TEXT[!MUST]:    certificate MUST be signed with ECDSA.
    TEXT[!MUST]: Furthermore, the client's
    TEXT[!MUST]:    ECDH key MUST be on the same elliptic curve as the server's long-term
    TEXT[!MUST]:    (certified) ECDH key.
    TEXT[!MUST]:    When using this authentication mechanism, the client MUST send an
    TEXT[!MUST]:    empty ClientKeyExchange as described in Section 5.7 and MUST NOT send
    TEXT[!MUST]:    the CertificateVerify message.

  SECTION: [RSA_fixed_ECDH](#section-3.3)
    TEXT[!MUST]:    This authentication mechanism is identical to ECDSA_fixed_ECDH except
    TEXT[!MUST]:    that the client's certificate MUST be signed with RSA.

  SECTION: [TLS Extensions for ECC](#section-4)
    TEXT[!SHOULD]:    A TLS client that proposes ECC cipher suites in its ClientHello
    TEXT[!SHOULD]:    message SHOULD include these extensions.
    TEXT[!MUST]: Servers implementing ECC
    TEXT[!MUST]:    cipher suites MUST support these extensions, and when a client uses
    TEXT[!MUST]:    these extensions, servers MUST NOT negotiate the use of an ECC cipher
    TEXT[!MUST]:    suite unless they can complete the handshake while respecting the
    TEXT[!MUST]:    choice of curves and compression techniques specified by the client.
    TEXT[!MUST]:    The client MUST NOT include these extensions in the ClientHello
    TEXT[!MUST]:    message if it does not propose any ECC cipher suites.
    TEXT[implementation,test]: A client that
    TEXT[implementation,test]:    proposes ECC cipher suites may choose not to include these
    TEXT[implementation,test]:    extensions.  In this case, the server is free to choose any one of
    TEXT[implementation,test]:    the elliptic curves or point formats listed in Section 5.

  SECTION: [Client Hello Extensions](#section-5.1)
    TEXT[!SHOULD]:    The extensions SHOULD be sent along with any ClientHello message that
    TEXT[!SHOULD]:    proposes ECC cipher suites.
    TEXT[!SHOULD]: Clients
    TEXT[!SHOULD]:    SHOULD send both the Supported Elliptic Curves Extension and the
    TEXT[!SHOULD]:    Supported Point Formats Extension.
    TEXT[!MUST]: If the Supported Point Formats
    TEXT[!MUST]:    Extension is indeed sent, it MUST contain the value 0 (uncompressed)
    TEXT[!MUST]:    as one of the items in the list of point formats.
    TEXT[!MUST]:    A server that receives a ClientHello containing one or both of these
    TEXT[!MUST]:    extensions MUST use the client's enumerated capabilities to guide its
    TEXT[!MUST]:    selection of an appropriate cipher suite.
    TEXT[!MUST]:    If a server does not understand the Supported Elliptic Curves
    TEXT[!MUST]:    Extension, does not understand the Supported Point Formats Extension,
    TEXT[!MUST]:    or is unable to complete the ECC handshake while restricting itself
    TEXT[!MUST]:    to the enumerated curves and point formats, it MUST NOT negotiate the
    TEXT[!MUST]:    use of an ECC cipher suite.

  SECTION: [Supported Point Formats Extension](#section-5.1.2)
    TEXT[!MUST]: The uncompressed point format is the default format in that
    TEXT[!MUST]:    implementations of this document MUST support it for all of their
    TEXT[!MUST]:    supported curves.
    TEXT[!MAY]: Implementations of this document MAY support the
    TEXT[!MAY]:    ansiX962_compressed_prime and ansiX962_compressed_char2 formats,
    TEXT[!MAY]:    where the former applies only to prime curves and the latter applies
    TEXT[!MAY]:    only to characteristic-2 curves.

  SECTION: [Server Hello Extension](#section-5.2)
    TEXT[!MUST]: The Supported
    TEXT[!MUST]:    Point Formats Extension, when used, MUST contain the value 0
    TEXT[!MUST]:    (uncompressed) as one of the items in the list of point formats.
    TEXT[!MUST]:    A client that receives a ServerHello message containing a Supported
    TEXT[!MUST]:    Point Formats Extension MUST respect the server's choice of point
    TEXT[!MUST]:    formats during the handshake (cf.

  SECTION: [Server Certificate](#section-5.3)
    TEXT[!MUST]: ECC
    TEXT[!MUST]:    public keys MUST be encoded in certificates as described in
    TEXT[!MUST]:    Section 5.9.
    TEXT[!MUST]:           ECDH_ECDSA              Certificate MUST contain an
    TEXT[!MUST]:                                   ECDH-capable public key.
    TEXT[!MUST]: It
    TEXT[!MUST]:                                   MUST be signed with ECDSA.
    TEXT[!MUST]:           ECDHE_ECDSA             Certificate MUST contain an
    TEXT[!MUST]:                                   ECDSA-capable public key.
    TEXT[!MUST]:           ECDH_RSA                Certificate MUST contain an
    TEXT[!MUST]:                                   ECDH-capable public key.
    TEXT[!MUST]: It
    TEXT[!MUST]:                                   MUST be signed with RSA.
    TEXT[!MUST]:           ECDHE_RSA               Certificate MUST contain an
    TEXT[!MUST]:                                   RSA public key authorized for
    TEXT[!MUST]:                                   use in digital signatures.
    TEXT[!MUST]: If the client has used a
    TEXT[!MUST]:    Supported Elliptic Curves Extension, the public key in the server's
    TEXT[!MUST]:    certificate MUST respect the client's choice of elliptic curves; in
    TEXT[!MUST]:    particular, the public key MUST employ a named curve (not the same
    TEXT[!MUST]:    curve as an explicit curve) unless the client has indicated support
    TEXT[!MUST]:    for explicit curves of the appropriate type.
    TEXT[!MUST]: If the client has used
    TEXT[!MUST]:    a Supported Point Formats Extension, both the server's public key
    TEXT[!MUST]:    point and (in the case of an explicit curve) the curve's base point
    TEXT[!MUST]:    MUST respect the client's choice of point formats.
    TEXT[!MUST]: (A server that
    TEXT[!MUST]:    cannot satisfy these requirements MUST NOT choose an ECC cipher suite
    TEXT[!MUST]:    in its ServerHello message.)

  SECTION: [Server Key Exchange](#section-5.4)
    TEXT[!SHOULD]: This option
    TEXT[!SHOULD]:       SHOULD be used when applicable.
    TEXT[!MUST]: This byte string may represent an elliptic curve point
    TEXT[!MUST]:       in uncompressed or compressed format; it MUST conform to what the
    TEXT[!MUST]:       client has requested through a Supported Point Formats Extension
    TEXT[!MUST]:       if this extension was used.

  SECTION: [Client Certificate](#section-5.6)
    TEXT[!MUST]:           ECDSA_sign              Certificate MUST contain an
    TEXT[!MUST]:                                   ECDSA-capable public key and
    TEXT[!MUST]:                                   be signed with ECDSA.
    TEXT[!MUST]:           ECDSA_fixed_ECDH        Certificate MUST contain an
    TEXT[!MUST]:                                   ECDH-capable public key on the
    TEXT[!MUST]:                                   same elliptic curve as the server's
    TEXT[!MUST]:                                   long-term ECDH key.
    TEXT[!MUST]: This certificate
    TEXT[!MUST]:                                   MUST be signed with ECDSA.
    TEXT[!MUST]:           RSA_fixed_ECDH          Certificate MUST contain an
    TEXT[!MUST]:                                   ECDH-capable public key on the
    TEXT[!MUST]:                                   same elliptic curve as the server's
    TEXT[!MUST]:                                   long-term ECDH key.
    TEXT[!MUST]: This certificate
    TEXT[!MUST]:                                   MUST be signed with RSA.

  SECTION: [Client Key Exchange](#section-5.7)
    TEXT[!MUST]: Here, the format MUST
    TEXT[!MUST]:       conform to what the server has requested through a Supported Point
    TEXT[!MUST]:       Formats Extension if this extension was used, and MUST be
    TEXT[!MUST]:       uncompressed if this extension was not used.

  SECTION: [Elliptic Curve Certificates](#section-5.9)
    TEXT[!MUST]:    X.509 certificates containing ECC public keys or signed using ECDSA
    TEXT[!MUST]:    MUST comply with [14] or another RFC that replaces or extends it.
    TEXT[!SHOULD]:    Clients SHOULD use the elliptic curve domain parameters recommended
    TEXT[!SHOULD]:    in ANSI X9.62 [7], FIPS 186-2 [11], and SEC 2 [13].

  SECTION: [ECDH, ECDSA, and RSA Computations](#section-5.10)
    TEXT[!MUST]: Note that this octet string (Z in IEEE 1363 terminology) as
    TEXT[!MUST]:    output by FE2OSP, the Field Element to Octet String Conversion
    TEXT[!MUST]:    Primitive, has constant length for any given field; leading zeros
    TEXT[!MUST]:    found in this octet string MUST NOT be truncated.
    TEXT[!MUST]:    All ECDSA computations MUST be performed according to ANSI X9.62 [7]
    TEXT[!MUST]:    or its successors.

  SECTION: [Cipher Suites](#section-6)
    TEXT[!SHOULD]:    Server implementations SHOULD support all of the following cipher
    TEXT[!SHOULD]:    suites, and client implementations SHOULD support at least one of
    TEXT[!SHOULD]:    them: TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA,
    TEXT[!SHOULD]:    TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA,
    TEXT[!SHOULD]:    TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, and
    TEXT[!SHOULD]:    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc5077
  SECTION: [NewSessionTicket Handshake Message](#section-3.3)
    TEXT[implementation,test]: If the server determines that it does not want to include a
    TEXT[implementation,test]:    ticket after it has included the SessionTicket extension in the
    TEXT[implementation,test]:    ServerHello, then it sends a zero-length ticket in the
    TEXT[implementation,test]:    NewSessionTicket handshake message.

  SECTION: [Interaction with TLS Session ID](#section-3.4)
    TEXT[implementation]: If the server accepts the ticket
    TEXT[implementation]:    and the Session ID is not empty, then it MUST respond with the same
    TEXT[implementation]:    Session ID present in the ClientHello.  This allows the client to
    TEXT[implementation]:    easily differentiate when the server is resuming a session from when
    TEXT[implementation]:    it is falling back to a full handshake.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc5246
  SECTION: [Major Differences from TLS 1.1](#section-1.2)
    TEXT[!MUST]:    -  Alerts MUST now be sent in many cases.
    TEXT[!MUST]:    -  After a certificate_request, if no certificates are available,
    TEXT[!MUST]:       clients now MUST send an empty certificate list.
    TEXT[!SHOULD]:    -  Support for the SSLv2 backward-compatible hello is now a MAY, not
    TEXT[!SHOULD]:       a SHOULD, with sending it a SHOULD NOT.
    TEXT[!SHOULD]: Support will probably
    TEXT[!SHOULD]:       become a SHOULD NOT in the future.

  SECTION: [Cryptographic Attributes](#section-4.7)
    TEXT[!MUST]: As
    TEXT[!MUST]:    discussed in [PKCS1], the DigestInfo MUST be DER-encoded [X680]
    TEXT[!MUST]:    [X690].
    TEXT[!MUST]: For hash algorithms without parameters (which includes
    TEXT[!MUST]:    SHA-1), the DigestInfo.AlgorithmIdentifier.parameters field MUST be
    TEXT[!MUST]:    NULL, but implementations MUST accept both without parameters and
    TEXT[!MUST]:    with NULL parameters.

  SECTION: [HMAC and the Pseudorandom Function](#section-5)
    TEXT[!MAY]: Other cipher suites MAY define their
    TEXT[!MAY]:    own MAC constructions, if needed.
    TEXT[!MUST]: New cipher suites MUST explicitly specify a
    TEXT[!MUST]:    PRF and, in general, SHOULD use the TLS PRF with SHA-256 or a
    TEXT[!MUST]:    stronger standard hash function.

  SECTION: [The TLS Record Protocol](#section-6)
    TEXT[!MUST]:    Implementations MUST NOT send record types not defined in this
    TEXT[!MUST]:    document unless negotiated by some extension.
    TEXT[!MUST]: If a TLS
    TEXT[!MUST]:    implementation receives an unexpected record type, it MUST send an
    TEXT[!MUST]:    unexpected_message alert.

  SECTION: [Connection States](#section-6.1)
    TEXT[!MUST]: These current states MUST be updated for each
    TEXT[!MUST]:    record processed.
    TEXT[!MUST]: The sequence
    TEXT[!MUST]:       number MUST be set to zero whenever a connection state is made the
    TEXT[!MUST]:       active state.
    TEXT[!MUST]: A sequence number is incremented after each
    TEXT[!MUST]:       record: specifically, the first record transmitted under a
    TEXT[!MUST]:       particular connection state MUST use sequence number 0.

  SECTION: [Fragmentation](#section-6.2.1)
    TEXT[implementation]:    The record layer fragments information blocks into TLSPlaintext
    TEXT[implementation]:    records carrying data in chunks of 2^14 bytes or less.
    TEXT[!MAY]: Client
    TEXT[!MAY]:    message boundaries are not preserved in the record layer (i.e.,
    TEXT[!MAY]:    multiple client messages of the same ContentType MAY be coalesced
    TEXT[!MAY]:    into a single TLSPlaintext record, or a single message MAY be
    TEXT[!MAY]:    fragmented across several records).
    TEXT[!MUST]: The
    TEXT[!MUST]:       length MUST NOT exceed 2^14.
    TEXT[!MUST]:    Implementations MUST NOT send zero-length fragments of Handshake,
    TEXT[!MUST]:    Alert, or ChangeCipherSpec content types.
    TEXT[!MAY]: Zero-length fragments of
    TEXT[!MAY]:    Application data MAY be sent as they are potentially useful as a
    TEXT[!MAY]:    traffic analysis countermeasure.
    TEXT[!MAY]:    Note: Data of different TLS record layer content types MAY be
    TEXT[!MAY]:    interleaved.
    TEXT[!MUST]: However, records MUST be
    TEXT[!MUST]:    delivered to the network in the same order as they are protected by
    TEXT[!MUST]:    the record layer.
    TEXT[!MUST]: Recipients MUST receive and process interleaved
    TEXT[!MUST]:    application layer traffic during handshakes subsequent to the first
    TEXT[!MUST]:    one on a connection.

  SECTION: [Record Compression and Decompression](#section-6.2.2)
    TEXT[!MUST]: If the decompression function encounters a
    TEXT[!MUST]:    TLSCompressed.fragment that would decompress to a length in excess of
    TEXT[!MUST]:    2^14 bytes, it MUST report a fatal decompression failure error.
    TEXT[!MUST]:       The length MUST NOT exceed 2^14 + 1024.

  SECTION: [Record Payload Protection](#section-6.2.3)
    TEXT[!MUST]:       The length MUST NOT exceed 2^14 + 2048.

  SECTION: [Null or Standard Stream Cipher](#section-6.2.3.1)
    TEXT[implementation]:    The MAC is generated as:
    TEXT[implementation]:       MAC(MAC_write_key, seq_num +
    TEXT[implementation]:                             TLSCompressed.type +
    TEXT[implementation]:                             TLSCompressed.version +
    TEXT[implementation]:                             TLSCompressed.length +
    TEXT[implementation]:                             TLSCompressed.fragment);
    TEXT[implementation]:    where "+" denotes concatenation.

  SECTION: [CBC Block Cipher](#section-6.2.3.2)
    TEXT[!MUST]:    IV
    TEXT[!MUST]:       The Initialization Vector (IV) SHOULD be chosen at random, and
    TEXT[!MUST]:       MUST be unpredictable.
    TEXT[!MAY]: The
    TEXT[!MAY]:       padding MAY be any length up to 255 bytes, as long as it results
    TEXT[!MAY]:       in the TLSCiphertext.length being an integral multiple of the
    TEXT[!MAY]:       block length.
    TEXT[!MUST]: Each uint8 in the padding data
    TEXT[!MUST]:       vector MUST be filled with the padding length value.
    TEXT[!MUST]: The receiver
    TEXT[!MUST]:       MUST check this padding and MUST use the bad_record_mac alert to
    TEXT[!MUST]:       indicate padding errors.
    TEXT[!MUST]:    padding_length
    TEXT[!MUST]:       The padding length MUST be such that the total size of the
    TEXT[!MUST]:       GenericBlockCipher structure is a multiple of the cipher's block
    TEXT[!MUST]:       length.
    TEXT[!MUST]: In order to defend against this attack, implementations
    TEXT[!MUST]:    MUST ensure that record processing time is essentially the same
    TEXT[!MUST]:    whether or not the padding is correct.

  SECTION: [AEAD Ciphers](#section-6.2.3.3)
    TEXT[!MUST]:    Each AEAD cipher suite MUST specify how the nonce supplied to the
    TEXT[!MUST]:    AEAD operation is constructed, and what is the length of the
    TEXT[!MUST]:    GenericAEADCipher.nonce_explicit part.
    TEXT[!SHOULD]: In this case, the implicit part SHOULD be derived
    TEXT[!SHOULD]:    from key_block as client_write_iv and server_write_iv (as described
    TEXT[!SHOULD]:    in Section 6.3), and the explicit part is included in
    TEXT[!SHOULD]:    GenericAEAEDCipher.nonce_explicit.
    TEXT[!MUST]: Each
    TEXT[!MUST]:    AEAD cipher MUST NOT produce an expansion of greater than 1024 bytes.
    TEXT[!MUST]:    If the decryption fails, a fatal bad_record_mac alert MUST be
    TEXT[!MUST]:    generated.

  SECTION: [Change Cipher Spec Protocol](#section-7.1)
    TEXT[!MUST]:    Immediately after sending this message, the sender MUST instruct the
    TEXT[!MUST]:    record layer to make the write pending state the write active state.
    TEXT[!MUST]: However, once the ChangeCipherSpec has been sent, the
    TEXT[!MUST]:    new CipherSpec MUST be used.
    TEXT[!MAY]: Thus, a small window of time,
    TEXT[!MAY]:    during which the recipient must buffer the data, MAY exist.

  SECTION: [Alert Protocol](#section-7.2)
    TEXT[!MUST]: In this case, other connections corresponding to the
    TEXT[!MUST]:    session may continue, but the session identifier MUST be invalidated,
    TEXT[!MUST]:    preventing the failed session from being used to establish new
    TEXT[!MUST]:    connections.
    TEXT[implementation]:           no_renegotiation(100),

  SECTION: [Closure Alerts](#section-7.2.1)
    TEXT[!MUST]: The other party MUST respond with a close_notify
    TEXT[!MUST]:    alert of its own and close down the connection immediately,
    TEXT[!MUST]:    discarding any pending writes.
    TEXT[!MAY]: If the application protocol will not
    TEXT[!MAY]:    transfer any additional data, but will only close the underlying
    TEXT[!MAY]:    transport connection, then the implementation MAY choose to close the
    TEXT[!MAY]:    transport without waiting for the responding close_notify.

  SECTION: [Error Alerts](#section-7.2.2)
    TEXT[!MUST]: Servers and clients MUST
    TEXT[!MUST]:    forget any session-identifiers, keys, and secrets associated with a
    TEXT[!MUST]:    failed connection.
    TEXT[!MUST]: Thus, any connection terminated with a fatal
    TEXT[!MUST]:    alert MUST NOT be resumed.
    TEXT[!MUST]:    Whenever an implementation encounters a condition which is defined as
    TEXT[!MUST]:    a fatal alert, it MUST send the appropriate alert prior to closing
    TEXT[!MUST]:    the connection.
    TEXT[!MAY]: For all errors where an alert level is not
    TEXT[!MAY]:    explicitly specified, the sending party MAY determine at its
    TEXT[!MAY]:    discretion whether to treat this as a fatal error or not.
    TEXT[!MUST]: If the
    TEXT[!MUST]:    implementation chooses to send an alert but intends to close the
    TEXT[!MUST]:    connection immediately afterwards, it MUST send that alert at the
    TEXT[!MUST]:    fatal alert level.
    TEXT[!SHOULD]: If the receiving party decides
    TEXT[!SHOULD]:    not to proceed with the connection (e.g., after having received a
    TEXT[!SHOULD]:    no_renegotiation alert that it is not willing to accept), it SHOULD
    TEXT[!SHOULD]:    send a fatal alert to terminate the connection.
    TEXT[!MUST]: This alert also MUST be returned if an alert is sent because
    TEXT[!MUST]:       a TLSCiphertext decrypted in an invalid way: either it wasn't an
    TEXT[!MUST]:       even multiple of the block length, or its padding values, when
    TEXT[!MUST]:       checked, weren't correct.
    TEXT[!MUST]: It MUST
    TEXT[!MUST]:       NOT be sent by compliant implementations.

  SECTION: [Handshake Protocol Overview](#section-7.3)
    TEXT[!MUST]: This secret MUST be quite long; currently defined key
    TEXT[!MUST]:    exchange methods exchange secrets that range from 46 bytes upwards.
    TEXT[!MUST]: If the server has sent
    TEXT[!MUST]:    a CertificateRequest message, the client MUST send the Certificate
    TEXT[!MUST]:    message.
    TEXT[!MUST]: (See
    TEXT[!MUST]:    flow chart below.)  Application data MUST NOT be sent prior to the
    TEXT[!MUST]:    completion of the first handshake (before a cipher suite other than
    TEXT[!MUST]:    TLS_NULL_WITH_NULL_NULL is established).
    TEXT[!MUST]: At this point, both
    TEXT[!MUST]:    client and server MUST send ChangeCipherSpec messages and proceed
    TEXT[!MUST]:    directly to Finished messages.
    TEXT[!MAY]: Once the re-establishment is
    TEXT[!MAY]:    complete, the client and server MAY begin to exchange application
    TEXT[!MAY]:    layer data.

  SECTION: [Handshake Protocol](#section-7.4)
    TEXT[!MUST]:    The handshake protocol messages are presented below in the order they
    TEXT[!MUST]:    MUST be sent; sending handshake messages in an unexpected order
    TEXT[!MUST]:    results in a fatal error.
    TEXT[!SHOULD,implementation]: The one message that is not bound by these ordering rules
    TEXT[!SHOULD,implementation]:    is the HelloRequest message, which can be sent at any time, but which
    TEXT[!SHOULD,implementation]:    SHOULD be ignored by the client if it arrives in the middle of a
    TEXT[!SHOULD,implementation]:    handshake.

  SECTION: [Hello Request](#section-7.4.1.1)
    TEXT[!MAY,implementation]:       The HelloRequest message MAY be sent by the server at any time.
    TEXT[!SHOULD]: Servers SHOULD NOT send a
    TEXT[!SHOULD]:       HelloRequest immediately upon the client's initial connection.
    TEXT[!MAY,implementation,test]: This message MAY be ignored by
    TEXT[!MAY,implementation,test]:       the client if it does not wish to renegotiate a session, or the
    TEXT[!MAY,implementation,test]:       client may, if it wishes, respond with a no_renegotiation alert.
    TEXT[!SHOULD]:       After sending a HelloRequest, servers SHOULD NOT repeat the
    TEXT[!SHOULD]:       request until the subsequent handshake negotiation is complete.
    TEXT[!MUST]:    This message MUST NOT be included in the message hashes that are
    TEXT[!MUST]:    maintained throughout the handshake and used in the Finished messages
    TEXT[!MUST]:    and the certificate verify message.

  SECTION: [Client Hello](#section-7.4.1.2)
    TEXT[!MAY]: The session identifier MAY be from an earlier connection,
    TEXT[!MUST]:    Warning: Because the SessionID is transmitted without encryption or
    TEXT[!MUST]:    immediate MAC protection, servers MUST NOT place confidential
    TEXT[!MUST]:    information in session identifiers or let the contents of fake
    TEXT[!MUST]:    session identifiers cause any breach of security.
    TEXT[!MUST]: If the list contains cipher
    TEXT[!MUST]:    suites the server does not recognize, support, or wish to use, the
    TEXT[!MUST]:    server MUST ignore those cipher suites, and process the remaining
    TEXT[!MUST]:    ones as usual.
    TEXT[!SHOULD]: This SHOULD be the latest
    TEXT[!SHOULD]:       (highest valued) version supported by the client.
    TEXT[!MUST]: If the
    TEXT[!MUST]:       session_id field is not empty (implying a session resumption
    TEXT[!MUST]:       request), this vector MUST include at least the cipher_suite from
    TEXT[!MUST]:       that session.
    TEXT[!MUST]: If the session_id field is not empty
    TEXT[!MUST]:       (implying a session resumption request), it MUST include the
    TEXT[!MUST]: This vector MUST contain,
    TEXT[!MUST]:       and all implementations MUST support, CompressionMethod.null.
    TEXT[!MAY]:    extensions
    TEXT[!MAY]:       Clients MAY request extended functionality from servers by sending
    TEXT[!MAY]:       data in the extensions field.
    TEXT[!MAY]:    In the event that a client requests additional functionality using
    TEXT[!MAY]:    extensions, and this functionality is not supplied by the server, the
    TEXT[!MAY]:    client MAY abort the handshake.
    TEXT[!MUST]: A server MUST accept ClientHello
    TEXT[!MUST]:    messages both with and without the extensions field, and (as for all
    TEXT[!MUST]:    other messages) it MUST check that the amount of data in the message
    TEXT[!MUST]:    precisely matches one of these formats; if not, then it MUST send a
    TEXT[!MUST]:    fatal "decode_error" alert.

  SECTION: [Server Hello](#section-7.4.1.3)
    TEXT[!MUST]:    random
    TEXT[!MUST]:       This structure is generated by the server and MUST be
    TEXT[!MUST]:       independently generated from the ClientHello.random.
    TEXT[!MUST]: Clients MUST be prepared to do a full
    TEXT[!MUST]:       negotiation -- including negotiating new cipher suites -- during
    TEXT[!MUST]:       any handshake.

  SECTION: [Hello Extensions](#section-7.4.1.4)
    TEXT[!MUST]:    An extension type MUST NOT appear in the ServerHello unless the same
    TEXT[!MUST]:    extension type appeared in the corresponding ClientHello.
    TEXT[!MUST]: If a
    TEXT[!MUST]:    client receives an extension type in ServerHello that it did not
    TEXT[!MUST]:    request in the associated ClientHello, it MUST abort the handshake
    TEXT[!MUST]:    with an unsupported_extension fatal alert.
    TEXT[!MAY]:    When multiple extensions of different types are present in the
    TEXT[!MAY]:    ClientHello or ServerHello messages, the extensions MAY appear in any
    TEXT[!MAY]:    order.
    TEXT[!MUST]: There MUST NOT be more than one extension of the same type.
    TEXT[!SHOULD]: Indeed, a client
    TEXT[!SHOULD]:    that requests session resumption does not in general know whether the
    TEXT[!SHOULD]:    server will accept this request, and therefore it SHOULD send the
    TEXT[!SHOULD]:    same extensions as it would send if it were not attempting
    TEXT[!SHOULD]:    resumption.

  SECTION: [Signature Algorithms](#section-7.4.1.4.1)
    TEXT[!MUST]: It MUST NOT appear in this extension.
    TEXT[!MAY]:    If the client supports only the default hash and signature algorithms
    TEXT[!MAY]:    (listed in this section), it MAY omit the signature_algorithms
    TEXT[!MAY]:    extension.
    TEXT[!MUST]: If the client does not support the default algorithms, or
    TEXT[!MUST]:    supports other hash and signature algorithms (and it is willing to
    TEXT[!MUST]:    use them for verifying messages sent by the server, i.e., server
    TEXT[!MUST]:    certificates and server key exchange), it MUST send the
    TEXT[!MUST,implementation]:    If the client does not send the signature_algorithms extension, the
    TEXT[!MUST,implementation]:    server MUST do the following:
    TEXT[implementation]:    -  If the negotiated key exchange algorithm is one of (RSA, DHE_RSA,
    TEXT[implementation]:       DH_RSA, RSA_PSK, ECDH_RSA, ECDHE_RSA), behave as if client had
    TEXT[implementation]:       sent the value {sha1,rsa}.
    TEXT[implementation]:    -  If the negotiated key exchange algorithm is one of (DHE_DSS,
    TEXT[implementation]:       DH_DSS), behave as if the client had sent the value {sha1,dsa}.
    TEXT[implementation]:    -  If the negotiated key exchange algorithm is one of (ECDH_ECDSA,
    TEXT[implementation]:       ECDHE_ECDSA), behave as if the client had sent value {sha1,ecdsa}.
    TEXT[!MUST]:    Clients MUST NOT offer it if they are offering prior versions.
    TEXT[!MUST]:    Servers MUST NOT send this extension.
    TEXT[!MUST]: TLS servers MUST support
    TEXT[!MUST]:    receiving this extension.

  SECTION: [Server Certificate](#section-7.4.2)
    TEXT[!MUST]:       The server MUST send a Certificate message whenever the agreed-
    TEXT[!MUST]:       upon key exchange method uses certificates for authentication
    TEXT[!MUST]:       (this includes all key exchange methods defined in this document
    TEXT[!MUST]:       except DH_anon).
    TEXT[!MUST]:       The certificate MUST be appropriate for the negotiated cipher
    TEXT[!MUST]:       suite's key exchange algorithm and any negotiated extensions.
    TEXT[!MUST]: The sender's
    TEXT[!MUST]:       certificate MUST come first in the list.
    TEXT[!MUST]: Each following
    TEXT[!MUST]:       certificate MUST directly certify the one preceding it.
    TEXT[!MAY]: Because
    TEXT[!MAY]:       certificate validation requires that root keys be distributed
    TEXT[!MAY]:       independently, the self-signed certificate that specifies the root
    TEXT[!MAY]:       certificate authority MAY be omitted from the chain, under the
    TEXT[!MAY]:       assumption that the remote end must already possess it in order to
    TEXT[!MAY]:       validate it in any case.
    TEXT[!MAY]: Note that a client MAY
    TEXT[!MAY]:    send no certificates if it does not have an appropriate certificate
    TEXT[!MAY]:    to send in response to the server's authentication request.
    TEXT[!MUST]:    -  The certificate type MUST be X.509v3, unless explicitly negotiated
    TEXT[!MUST]:       otherwise (e.g., [TLSPGP]).
    TEXT[!MUST]:    -  The end entity certificate's public key (and associated
    TEXT[!MUST]:       restrictions) MUST be compatible with the selected key exchange
    TEXT[!MUST]:       algorithm.
    TEXT[!MUST]:       RSA                RSA public key; the certificate MUST allow the
    TEXT[!MUST]:       RSA_PSK            key to be used for encryption (the
    TEXT[!MUST]:                          keyEncipherment bit MUST be set if the key
    TEXT[!MUST]:                          usage extension is present).
    TEXT[!MUST]:       DHE_RSA            RSA public key; the certificate MUST allow the
    TEXT[!MUST]:       ECDHE_RSA          key to be used for signing (the
    TEXT[!MUST]:                          digitalSignature bit MUST be set if the key
    TEXT[!MUST]:                          usage extension is present) with the signature
    TEXT[!MUST]:                          scheme and hash algorithm that will be employed
    TEXT[!MUST]:                          in the server key exchange message.
    TEXT[!MUST]:       DHE_DSS            DSA public key; the certificate MUST allow the
    TEXT[!MUST]:                          key to be used for signing with the hash
    TEXT[!MUST]:                          algorithm that will be employed in the server
    TEXT[!MUST]:                          key exchange message.
    TEXT[!MUST]:       DH_DSS             Diffie-Hellman public key; the keyAgreement bit
    TEXT[!MUST]:       DH_RSA             MUST be set if the key usage extension is
    TEXT[!MUST]:                          present.
    TEXT[!MUST]:       ECDH_ECDSA         ECDH-capable public key; the public key MUST
    TEXT[!MUST]:       ECDH_RSA           use a curve and point format supported by the
    TEXT[!MUST]:                          client, as described in [TLSECC].
    TEXT[!MUST]:       ECDHE_ECDSA        ECDSA-capable public key; the certificate MUST
    TEXT[!MUST]:                          allow the key to be used for signing with the
    TEXT[!MUST]:                          hash algorithm that will be employed in the
    TEXT[!MUST]:                          server key exchange message.
    TEXT[!MUST]: The public key
    TEXT[!MUST]:                          MUST use a curve and point format supported by
    TEXT[!MUST]:                          the client, as described in  [TLSECC].
    TEXT[!MUST,exception]:    If the client provided a "signature_algorithms" extension, then all
    TEXT[!MUST,exception]:    certificates provided by the server MUST be signed by a
    TEXT[!MUST,exception]:    hash/signature algorithm pair that appears in that extension.
    TEXT[!MAY]: Note
    TEXT[!MAY]:    that this implies that a certificate containing a key for one
    TEXT[!MAY]:    signature algorithm MAY be signed using a different signature
    TEXT[!MAY]:    algorithm (for instance, an RSA key signed with a DSA key).
    TEXT[!MAY]: Fixed DH certificates MAY be
    TEXT[!MAY]:    signed with any hash/signature algorithm pair appearing in the
    TEXT[!MAY]:    extension.
    TEXT[!SHOULD]: If the server has a single certificate, it SHOULD attempt to
    TEXT[!SHOULD]:    validate that it meets these criteria.

  SECTION: [Server Key Exchange Message](#section-7.4.3)
    TEXT[!MUST]:       Other key exchange algorithms, such as those defined in [TLSECC],
    TEXT[!MUST]:       MUST specify whether the ServerKeyExchange message is sent or not;
    TEXT[!MUST]:       and if the message is sent, its contents.
    TEXT[!MUST,exception]:    If the client has offered the "signature_algorithms" extension, the
    TEXT[!MUST,exception]:    signature algorithm and hash algorithm MUST be a pair listed in that
    TEXT[!MUST,exception]:    extension.
    TEXT[!MUST]: In
    TEXT[!MUST]:    order to negotiate correctly, the server MUST check any candidate
    TEXT[!MUST]:    cipher suites against the "signature_algorithms" extension before
    TEXT[!MUST]:    selecting them.
    TEXT[!MUST]:    In addition, the hash and signature algorithms MUST be compatible
    TEXT[!MUST]:    with the key in the server's end-entity certificate.
    TEXT[!MAY]: RSA keys MAY be
    TEXT[!MAY]:    used with any permitted hash algorithm, subject to restrictions in
    TEXT[!MAY]:    the certificate, if any.

  SECTION: [Certificate Request](#section-7.4.4)
    TEXT[!MAY]: If
    TEXT[!MAY]:       the certificate_authorities list is empty, then the client MAY
    TEXT[!MAY]:       send any certificate of the appropriate ClientCertificateType,
    TEXT[!MAY]:       unless there is some external arrangement to the contrary.
    TEXT[!MUST]:    -  Any certificates provided by the client MUST be signed using a
    TEXT[!MUST]:       hash/signature algorithm pair found in
    TEXT[!MUST]:       supported_signature_algorithms.
    TEXT[!MUST]:    -  The end-entity certificate provided by the client MUST contain a
    TEXT[!MUST]:       key that is compatible with certificate_types.
    TEXT[!MUST]: If the key is a
    TEXT[!MUST]:       signature key, it MUST be usable with some hash/signature
    TEXT[!MUST]:       algorithm pair in supported_signature_algorithms.
    TEXT[!MAY]: For
    TEXT[!MAY]:       example, if the server sends dss_fixed_dh certificate type and
    TEXT[!MAY]:       {{sha1, dsa}, {sha1, rsa}} signature types, the client MAY reply
    TEXT[!MAY]:       with a certificate containing a static DH key, signed with RSA-
    TEXT[!MAY]:       SHA1.

  SECTION: [Server Hello Done](#section-7.4.5)
    TEXT[!SHOULD]:       Upon receipt of the ServerHelloDone message, the client SHOULD
    TEXT[!SHOULD]:       verify that the server provided a valid certificate, if required,
    TEXT[!SHOULD]:       and check that the server hello parameters are acceptable.

  SECTION: [Client Certificate](#section-7.4.6)
    TEXT[!MUST]: If no suitable certificate is available,
    TEXT[!MUST]:       the client MUST send a certificate message containing no
    TEXT[!MUST]:       certificates.
    TEXT[!MAY]: If the client does not send any certificates, the
    TEXT[!MAY]:       server MAY at its discretion either continue the handshake without
    TEXT[!MAY]:       client authentication, or respond with a fatal handshake_failure
    TEXT[!MAY]:       alert.
    TEXT[!MAY]: Also, if some aspect of the certificate chain was
    TEXT[!MAY]:       unacceptable (e.g., it was not signed by a known, trusted CA), the
    TEXT[!MAY]:       server MAY at its discretion either continue the handshake
    TEXT[!MAY]:       (considering the client unauthenticated) or send a fatal alert.
    TEXT[!MUST]: The certificate MUST be appropriate for the negotiated
    TEXT[!MUST]:       cipher suite's key exchange algorithm, and any negotiated
    TEXT[!MUST]:       extensions.
    TEXT[!MUST]:    -  The certificate type MUST be X.509v3, unless explicitly negotiated
    TEXT[!MUST]:       otherwise (e.g., [TLSPGP]).
    TEXT[!MUST]:       rsa_sign            RSA public key; the certificate MUST allow the
    TEXT[!MUST]:                           key to be used for signing with the signature
    TEXT[!MUST]:                           scheme and hash algorithm that will be
    TEXT[!MUST]:                           employed in the certificate verify message.
    TEXT[!MUST]:       dss_sign            DSA public key; the certificate MUST allow the
    TEXT[!MUST]:                           key to be used for signing with the hash
    TEXT[!MUST]:                           algorithm that will be employed in the
    TEXT[!MUST]:                           certificate verify message.
    TEXT[!MUST]:       ecdsa_sign          ECDSA-capable public key; the certificate MUST
    TEXT[!MUST]:                           allow the key to be used for signing with the
    TEXT[!MUST]:                           hash algorithm that will be employed in the
    TEXT[!MUST]:                           certificate verify message; the public key
    TEXT[!MUST]:                           MUST use a curve and point format supported by
    TEXT[!MUST]:                           the server.
    TEXT[!MUST]:       rsa_fixed_dh        Diffie-Hellman public key; MUST use the same
    TEXT[!MUST]:       dss_fixed_dh        parameters as server's key.
    TEXT[!MUST]:       rsa_fixed_ecdh      ECDH-capable public key; MUST use the
    TEXT[!MUST]:       ecdsa_fixed_ecdh    same curve as the server's key, and MUST use a
    TEXT[!MUST]:                           point format supported by the server.
    TEXT[!SHOULD]:    -  If the certificate_authorities list in the certificate request
    TEXT[!SHOULD]:       message was non-empty, one of the certificates in the certificate
    TEXT[!SHOULD]:       chain SHOULD be issued by one of the listed CAs.
    TEXT[!MUST]:    -  The certificates MUST be signed using an acceptable hash/
    TEXT[!MUST]:       signature algorithm pair, as described in Section 7.4.4.

  SECTION: [Client Key Exchange Message](#section-7.4.7)
    TEXT[!MUST]: It MUST immediately
    TEXT[!MUST]:       follow the client certificate message, if it is sent.
    TEXT[!MUST]: Otherwise,
    TEXT[!MUST]:       it MUST be the first message sent by the client after it receives
    TEXT[!MUST]:       the ServerHelloDone message.
    TEXT[!MUST]: If the client is sending a certificate containing a static
    TEXT[!MUST]:       DH exponent (i.e., it is doing fixed_dh client authentication),
    TEXT[!MUST]:       then this message MUST be sent but MUST be empty.

  SECTION: [RSA-Encrypted Premaster Secret Message](#section-7.4.7.1)
    TEXT[!MUST]:    Client implementations MUST always send the correct version number in
    TEXT[!MUST]:    PreMasterSecret.
    TEXT[!MUST]: If ClientHello.client_version is TLS 1.1 or higher,
    TEXT[!MUST]:    server implementations MUST check the version number as described in
    TEXT[!MUST]:    the note below.
    TEXT[!SHOULD]: If the version number is TLS 1.0 or earlier, server
    TEXT[!SHOULD]:    implementations SHOULD check the version number, but MAY have a
    TEXT[!SHOULD]:    configuration option to disable the check.
    TEXT[!SHOULD]: Note that if the check
    TEXT[!SHOULD]:    fails, the PreMasterSecret SHOULD be randomized as described below.
    TEXT[!SHOULD]: [KPR03] describe some theoretical attacks, and therefore
    TEXT[!SHOULD]:    the first construction described is RECOMMENDED.
    TEXT[!MUST]:    In any case, a TLS server MUST NOT generate an alert if processing an
    TEXT[!MUST]:    RSA-encrypted premaster secret message fails, or the version number
    TEXT[!MUST]:    is not as expected.
    TEXT[!MUST]: Instead, it MUST continue the handshake with a
    TEXT[!MUST]:    randomly generated premaster secret.
    TEXT[!MUST]:    upgrading from SSLv3 MUST modify their implementations to generate
    TEXT[!MUST]:    and accept the correct encoding.
    TEXT[!MUST]: Accordingly, implementations that use static RSA keys MUST
    TEXT[!MUST]:    use RSA blinding or some other anti-timing technique, as described in
    TEXT[!MUST]:    [TIMING].

  SECTION: [Client Diffie-Hellman Public Value](#section-7.4.7.2)
    TEXT[!MUST]: In this
    TEXT[!MUST]:          case, the client key exchange message will be sent, but it MUST
    TEXT[!MUST]:          be empty.

  SECTION: [Certificate Verify](#section-7.4.8)
    TEXT[!MUST]: When
    TEXT[!MUST]:       sent, it MUST immediately follow the client key exchange message.
    TEXT[!MUST,exception]:       The hash and signature algorithms used in the signature MUST be
    TEXT[!MUST,exception]:       one of those present in the supported_signature_algorithms field
    TEXT[!MUST,exception]:       of the CertificateRequest message.
    TEXT[!MUST]: In addition, the hash and
    TEXT[!MUST]:       signature algorithms MUST be compatible with the key in the
    TEXT[!MUST]:       client's end-entity certificate.
    TEXT[!MAY]: RSA keys MAY be used with any
    TEXT[!MAY]:       permitted hash algorithm, subject to restrictions in the
    TEXT[!MAY]:       certificate, if any.

  SECTION: [Finished](#section-7.4.9)
    TEXT[!MUST]: Recipients of Finished
    TEXT[!MUST]:       messages MUST verify that the contents are correct.
    TEXT[!MUST]: For the PRF
    TEXT[!MUST]:       defined in Section 5, the Hash MUST be the Hash used as the basis
    TEXT[!MUST]:       for the PRF.
    TEXT[!MUST]: Any cipher suite which defines a different PRF MUST
    TEXT[!MUST]:       also define the Hash to use in the Finished computation.
    TEXT[!MUST]:       Future cipher suites MAY specify other lengths but such length
    TEXT[!MUST]:       MUST be at least 12 bytes.

  SECTION: [Mandatory Cipher Suites](#section-9)
    TEXT[!MUST]:    In the absence of an application profile standard specifying
    TEXT[!MUST]:    otherwise, a TLS-compliant application MUST implement the cipher
    TEXT[!MUST]:    suite TLS_RSA_WITH_AES_128_CBC_SHA (see Appendix A.5 for the
    TEXT[!MUST]:    definition).

  SECTION: [The Cipher Suite](#appendix-A.5)
    TEXT[!MUST]:    TLS_NULL_WITH_NULL_NULL is specified and is the initial state of a
    TEXT[!MUST]:    TLS connection during the first handshake on that channel, but MUST
    TEXT[!MUST]:    NOT be negotiated, as it provides no more protection than an
    TEXT[!MUST]:    unsecured connection.
    TEXT[!MUST]: Using this mode therefore is of limited use: These
    TEXT[!MUST]:    cipher suites MUST NOT be used by TLS 1.2 implementations unless the
    TEXT[!MUST]:    application layer has specifically requested to allow anonymous key
    TEXT[!MUST]:    exchange.

  SECTION: [Compatibility with TLS 1.0/1.1 and SSL 3.0](#appendix-E.1)
    TEXT[!MUST]:    If the version chosen by the server is not supported by the client
    TEXT[!MUST]:    (or not acceptable), the client MUST send a "protocol_version" alert
    TEXT[!MUST]:    message and close the connection.
    TEXT[!MUST]:    If a TLS server receives a ClientHello containing a version number
    TEXT[!MUST]:    greater than the highest version supported by the server, it MUST
    TEXT[!MUST]:    reply according to the highest version supported by the server.
    TEXT[!MUST]: If server supports (or is
    TEXT[!MUST]:    willing to use) only versions greater than client_version, it MUST
    TEXT[!MUST]:    send a "protocol_version" alert message and close the connection.
    TEXT[!SHOULD]:    Whenever a client already knows the highest protocol version known to
    TEXT[!SHOULD]:    a server (for example, when resuming a session), it SHOULD initiate
    TEXT[!SHOULD]:    the connection in that native protocol.
    TEXT[!MUST]: Thus, TLS servers
    TEXT[!MUST]:    compliant with this specification MUST accept any value {03,XX} as
    TEXT[!MUST]:    the record layer version number for ClientHello.
    TEXT[!MAY]:    TLS clients that wish to negotiate with older servers MAY send any
    TEXT[!MAY]:    value {03,XX} as the record layer version number.

  SECTION: [Compatibility with SSL 2.0](#appendix-E.2)
    TEXT[!MUST]:    TLS 1.2 clients that wish to support SSL 2.0 servers MUST send
    TEXT[!MUST]:    version 2.0 CLIENT-HELLO messages defined in [SSL2].
    TEXT[!MUST]: The message
    TEXT[!MUST]:    MUST contain the same version number as would be used for ordinary
    TEXT[!MUST]:    ClientHello, and MUST encode the supported TLS cipher suites in the
    TEXT[!MUST]:    CIPHER-SPECS-DATA field as described below.
    TEXT[!SHOULD]: TLS 1.2 clients SHOULD NOT support SSL 2.0.
    TEXT[!MAY]:    However, even TLS servers that do not support SSL 2.0 MAY accept
    TEXT[!MAY]:    version 2.0 CLIENT-HELLO messages.
    TEXT[!MUST]: Note that this message MUST be sent directly on the
    TEXT[!MUST]:    wire, not wrapped as a TLS record.
    TEXT[!MUST,implementation]:    msg_length
    TEXT[!MUST,implementation]:       The highest bit MUST be 1; the remaining bits contain the length
    TEXT[!MUST,implementation]:       of the following data in bytes.
    TEXT[!MUST]: The value MUST be 1.
    TEXT[!MUST]: It
    TEXT[!MUST]:       cannot be zero and MUST be a multiple of the V2CipherSpec length
    TEXT[!MUST]:       (3).
    TEXT[!MUST]:    session_id_length
    TEXT[!MUST]:       This field MUST have a value of zero for a client that claims to
    TEXT[!MUST]:       support TLS 1.2.
    TEXT[!SHOULD]: When using the SSLv2 backward-
    TEXT[!SHOULD]:       compatible handshake the client SHOULD use a 32-byte challenge.
    TEXT[!MUST]:    session_id
    TEXT[!MUST]:       This field MUST be empty.
    TEXT[!MUST]:    Note: Requests to resume a TLS session MUST use a TLS client hello.

  SECTION: [Avoiding Man-in-the-Middle Version Rollback](#appendix-E.3)
    TEXT[!MUST]:    When TLS clients fall back to Version 2.0 compatibility mode, they
    TEXT[!MUST]:    MUST use special PKCS#1 block formatting.
    TEXT[!MUST]:    When a client negotiates SSL 2.0 but also supports TLS, it MUST set
    TEXT[!MUST]:    the right-hand (least-significant) 8 random bytes of the PKCS padding
    TEXT[!MUST]:    (not including the terminal null of the padding) for the RSA
    TEXT[!MUST]:    encryption of the ENCRYPTED-KEY-DATA field of the CLIENT-MASTER-KEY
    TEXT[!MUST]:    to 0x03 (the other padding bytes are random).
    TEXT[!SHOULD]:    When a TLS-capable server negotiates SSL 2.0 it SHOULD, after
    TEXT[!SHOULD]:    decrypting the ENCRYPTED-KEY-DATA field, check that these 8 padding
    TEXT[!SHOULD]:    bytes are 0x03.
    TEXT[!SHOULD]: If they are not, the server SHOULD generate a random
    TEXT[!SHOULD]:    value for SECRET-KEY-DATA, and continue the handshake (which will
    TEXT[!SHOULD]:    eventually fail since the keys will not match).

  SECTION: [Diffie-Hellman Key Exchange with Authentication](#appendix-F.1.1.3)
    TEXT[!SHOULD]: Implementations SHOULD follow the
    TEXT[!SHOULD]:    guidelines found in [SUBGROUP].
    TEXT[!SHOULD]: Implementations SHOULD generate a
    TEXT[!SHOULD]:    new X for each handshake when using DHE cipher suites.
    TEXT[!SHOULD]: The client SHOULD also verify that the DH public
    TEXT[!SHOULD]:    exponent appears to be of adequate size.
    TEXT[!MAY]: The server MAY choose
    TEXT[!MAY]:    to assist the client by providing a known group, such as those
    TEXT[!MAY]:    defined in [IKEALG] or [MODP].

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc5746
  SECTION: [Client Behavior: Initial Handshake](#section-3.4)
    TEXT[!MUST,implementation,test]:    o  The client MUST include either an empty "renegotiation_info"
    TEXT[!MUST,implementation,test]:       extension, or the TLS_EMPTY_RENEGOTIATION_INFO_SCSV signaling
    TEXT[!MUST,implementation,test]:       cipher suite value in the ClientHello.
    TEXT[!SHOULD,implementation,test]: Including both is NOT
    TEXT[!SHOULD,implementation,test]:       RECOMMENDED.
    TEXT[!MUST,implementation,test]:    o  When a ServerHello is received, the client MUST check if it
    TEXT[!MUST,implementation,test]:       includes the "renegotiation_info" extension:
    TEXT[implementation,test]:       *  If the extension is not present, the server does not support
    TEXT[implementation,test]:          secure renegotiation; set secure_renegotiation flag to FALSE.
    TEXT[implementation]:          In this case, some clients may want to terminate the handshake
    TEXT[implementation]:          instead of continuing; see Section 4.1 for discussion.
    TEXT[implementation]:       *  If the extension is present, set the secure_renegotiation flag
    TEXT[implementation]:          to TRUE
    TEXT[implementation,test]: .
    TEXT[!MUST,implementation,test]: The client MUST then verify that the length of the
    TEXT[!MUST,implementation,test]:          "renegotiated_connection" field is zero, and if it is not, MUST
    TEXT[!MUST,implementation,test]:          abort the handshake (by sending a fatal handshake_failure
    TEXT[!MUST,implementation,test]:          alert).
    TEXT[implementation]:          Note: later in Section 3, "abort the handshake" is used as
    TEXT[implementation]:          shorthand for "send a fatal handshake_failure alert and
    TEXT[implementation]:          terminate the connection".

  SECTION: [Client Behavior: Secure Renegotiation](#section-3.5)
    TEXT[implementation]:    This text applies if the connection's "secure_renegotiation" flag is
    TEXT[implementation]:    set to TRUE (if it is set to FALSE, see Section 4.2).
    TEXT[!MUST,implementation,test]:    o  The client MUST include the "renegotiation_info" extension in the
    TEXT[!MUST,implementation,test]:       ClientHello, containing the saved client_verify_data.
    TEXT[!MUST,implementation,test]: The SCSV
    TEXT[!MUST,implementation,test]:       MUST NOT be included.
    TEXT[!MUST,implementation,test]:    o  When a ServerHello is received, the client MUST verify that the
    TEXT[!MUST,implementation,test]:       "renegotiation_info" extension is present; if it is not, the
    TEXT[!MUST,implementation,test]:       client MUST abort the handshake.
    TEXT[!MUST,implementation,test]:    o  The client MUST then verify that the first half of the
    TEXT[!MUST,implementation,test]:       "renegotiated_connection" field is equal to the saved
    TEXT[!MUST,implementation,test]:       client_verify_data value, and the second half is equal to the
    TEXT[!MUST,implementation,test]:       saved server_verify_data value.
    TEXT[!MUST,implementation,test]: If they are not, the client MUST
    TEXT[!MUST,implementation,test]:       abort the handshake.

  SECTION: [Server Behavior: Initial Handshake](#section-3.6)
    TEXT[!MUST,implementation,test]:    o  When a ClientHello is received, the server MUST check if it
    TEXT[!MUST,implementation,test]:       includes the TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSV.
    TEXT[implementation,test]:   If it does,
    TEXT[implementation,test]:       set the secure_renegotiation flag to TRUE.
    TEXT[!MUST,implementation,test]:    o  The server MUST check if the "renegotiation_info" extension is
    TEXT[!MUST,implementation,test]:       included in the ClientHello.
    TEXT[implementation]: If the extension is present, set
    TEXT[implementation]:       secure_renegotiation flag to TRUE.
    TEXT[!MUST,implementation,test]: The server MUST then verify
    TEXT[!MUST,implementation,test]:       that the length of the "renegotiated_connection" field is zero,
    TEXT[!MUST,implementation,test]:       and if it is not, MUST abort the handshake.
    TEXT[implementation]:    o  If neither the TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSV nor the
    TEXT[implementation]:       "renegotiation_info" extension was included, set the
    TEXT[implementation]:       secure_renegotiation flag to FALSE.  In this case, some servers
    TEXT[implementation]:       may want to terminate the handshake instead of continuing
    TEXT[!MUST,implementation,test]:    o  If the secure_renegotiation flag is set to TRUE, the server MUST
    TEXT[!MUST,implementation,test]:       include an empty "renegotiation_info" extension in the ServerHello
    TEXT[!MUST,implementation,test]:       message.
    TEXT[!MUST,exception]:    TLS servers implementing this specification MUST ignore any unknown
    TEXT[!MUST,exception]:    extensions offered by the client and they MUST accept version numbers
    TEXT[!MUST,exception]:    higher than their highest version number and negotiate the highest
    TEXT[!MUST,exception]:    common version.
    TEXT[exception]:   These two requirements reiterate preexisting
    TEXT[exception]:    requirements in RFC 5246 and are merely stated here in the interest
    TEXT[exception]:    of forward compatibility.
    TEXT[implementation]:    Note that sending a "renegotiation_info" extension in response to a
    TEXT[implementation]:    ClientHello containing only the SCSV is an explicit exception to the
    TEXT[implementation]:    prohibition in RFC 5246, Section 7.4.1.4, on the server sending
    TEXT[implementation]:    unsolicited extensions and is only allowed because the client is
    TEXT[implementation]:    signaling its willingness to receive the extension via the
    TEXT[implementation]:    TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSV.
    TEXT[!MUST,exception]: TLS implementations MUST
    TEXT[!MUST,exception]:    continue to comply with Section 7.4.1.4 for all other extensions.

  SECTION: [Server Behavior: Secure Renegotiation](#section-3.7)
    TEXT[implementation]:    This text applies if the connection's "secure_renegotiation" flag is
    TEXT[implementation]:    set to TRUE (if it is set to FALSE, see Section 4.4).
    TEXT[!MUST,implementation,test]:    o  When a ClientHello is received, the server MUST verify that it
    TEXT[!MUST,implementation,test]:       does not contain the TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSV.
    TEXT[!MUST,implementation,test]: If
    TEXT[!MUST,implementation,test]:       the SCSV is present, the server MUST abort the handshake.
    TEXT[!MUST,implementation,test]:    o  The server MUST verify that the "renegotiation_info" extension is
    TEXT[!MUST,implementation,test]:       present; if it is not, the server MUST abort the handshake.
    TEXT[!MUST,implementation,test]:    o  The server MUST verify that the value of the
    TEXT[!MUST,implementation,test]:       "renegotiated_connection" field is equal to the saved
    TEXT[!MUST,implementation,test]:       client_verify_data value; if it is not, the server MUST abort the
    TEXT[!MUST,implementation,test]:       handshake.
    TEXT[!MUST,implementation,test]:    o  The server MUST include a "renegotiation_info" extension
    TEXT[!MUST,implementation,test]:       containing the saved client_verify_data and server_verify_data in
    TEXT[!MUST,implementation,test]:       the ServerHello.

  SECTION: [Client Considerations](#section-4.1)
    TEXT[exception]:    If clients wish to ensure that such attacks are impossible, they need
    TEXT[exception]:    to terminate the connection immediately upon failure to receive the
    TEXT[exception]:    extension without completing the handshake.
    TEXT[!MUST,exception]: Such clients MUST
    TEXT[!MUST,exception]:    generate a fatal "handshake_failure" alert prior to terminating the
    TEXT[!MUST,exception]:    connection.
    TEXT[exception]:   However, it is expected that many TLS servers that do
    TEXT[exception]:    not support renegotiation (and thus are not vulnerable) will not
    TEXT[exception]:    support this extension either, so in general, clients that implement
    TEXT[exception]:    this behavior will encounter interoperability problems.

  SECTION: [Client Behavior: Legacy (Insecure) Renegotiation](#section-4.2)
    TEXT[implementation,test]:    This text applies if the connection's "secure_renegotiation" flag is
    TEXT[implementation,test]:    set to FALSE.
    TEXT[implementation,test]:    It is possible that un-upgraded servers will request that the client
    TEXT[implementation,test]:    renegotiate.
    TEXT[!SHOULD,implementation,test]: It is RECOMMENDED that clients refuse this
    TEXT[!SHOULD,implementation,test]:    renegotiation request.
    TEXT[!MUST,implementation,test]: Clients that do so MUST respond to such
    TEXT[!MUST,implementation,test]:    requests with a "no_renegotiation" alert (RFC 5246 requires this
    TEXT[!MUST,implementation,test]:    alert to be at the "warning" level).
    TEXT[implementation,test]:   It is possible that the
    TEXT[implementation,test]:    apparently un-upgraded server is in fact an attacker who is then
    TEXT[implementation,test]:    allowing the client to renegotiate with a different, legitimate,
    TEXT[implementation,test]:    upgraded server.
    TEXT[!MUST,exception]: If clients nevertheless choose to renegotiate, they
    TEXT[!MUST,exception]:    MUST behave as described below.
    TEXT[!MUST,exception]:    Clients that choose to renegotiate MUST provide either the
    TEXT[!MUST,exception]:    TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSV or "renegotiation_info" in
    TEXT[!MUST,exception]:    their ClientHello.
    TEXT[exception]:   In a legitimate renegotiation with an un-upgraded
    TEXT[exception]:    server, that server should ignore both of these signals.  However, if
    TEXT[exception]:    the server (incorrectly) fails to ignore extensions, sending the
    TEXT[exception]:    "renegotiation_info" extension may cause a handshake failure.
    TEXT[!SHOULD,exception]: Thus,
    TEXT[!SHOULD,exception]:    it is permitted, though NOT RECOMMENDED, for the client to simply
    TEXT[!SHOULD,exception]:    send the SCSV.
    TEXT[exception]:   This is the only situation in which clients are
    TEXT[exception]:    permitted to not send the "renegotiation_info" extension in a
    TEXT[exception]:    ClientHello that is used for renegotiation.
    TEXT[!MUST,exception]:    When the ServerHello is received, the client MUST verify that it does
    TEXT[!MUST,exception]:    not contain the "renegotiation_info" extension.
    TEXT[!MUST,exception]: If it does, the
    TEXT[!MUST,exception]:    client MUST abort the handshake.
    TEXT[exception]:   (Because the server has already
    TEXT[exception]:    indicated it does not support secure renegotiation, the only way that
    TEXT[exception]:    this can happen is if the server is broken or there is an attack.)

  SECTION: [Server Considerations](#section-4.3)
    TEXT[!MUST,implementation,test]:    In order to enable clients to probe, even servers that do not support
    TEXT[!MUST,implementation,test]:    renegotiation MUST implement the minimal version of the extension
    TEXT[!MUST,implementation,test]:    described in this document for initial handshakes, thus signaling
    TEXT[!MUST,implementation,test]:    that they have been upgraded.

  SECTION: [Server Behavior: Legacy (Insecure) Renegotiation](#section-4.4)
    TEXT[!SHOULD,exception]:    It is RECOMMENDED that servers not permit legacy renegotiation.
    TEXT[!MUST,exception]: If
    TEXT[!MUST,exception]:    servers nevertheless do permit it, they MUST follow the requirements
    TEXT[!MUST,exception]:    in this section.
    TEXT[!MUST,exception]:    o  When a ClientHello is received, the server MUST verify that it
    TEXT[!MUST,exception]:       does not contain the TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSV.
    TEXT[!MUST,exception]: If
    TEXT[!MUST,exception]:       the SCSV is present, the server MUST abort the handshake.
    TEXT[!MUST,exception]:    o  The server MUST verify that the "renegotiation_info" extension is
    TEXT[!MUST,exception]:       not present; if it is, the server MUST abort the handshake.

  SECTION: [SSLv3](#section-4.5)
    TEXT[!MUST,implementation,test]: Clients
    TEXT[!MUST,implementation,test]:    that support SSLv3 and offer secure renegotiation (either via SCSV or
    TEXT[!MUST,implementation,test]:    "renegotiation_info") MUST accept the "renegotiation_info" extension
    TEXT[!MUST,implementation,test]:    from the server, even if the server version is {0x03, 0x00}, and
    TEXT[!MUST,implementation,test]:    behave as described in this specification.
    TEXT[!MUST,implementation,test]: TLS servers that support
    TEXT[!MUST,implementation,test]:    secure renegotiation and support SSLv3 MUST accept SCSV or the
    TEXT[!MUST,implementation,test]:    "renegotiation_info" extension and respond as described in this
    TEXT[!MUST,implementation,test]:    specification even if the offered client version is {0x03, 0x00}.
    TEXT[implementation,test]:    SSLv3 does not define the "no_renegotiation" alert (and does
    TEXT[implementation,test]:    not offer a way to indicate a refusal to renegotiate at a "warning"
    TEXT[implementation,test]:    level).
    TEXT[!SHOULD,implementation,test]: SSLv3 clients that refuse renegotiation SHOULD use a fatal
    TEXT[!SHOULD,implementation,test]:    handshake_failure alert.

  SECTION: [Security Considerations](#section-5)
    TEXT[!SHOULD,exception]: Servers SHOULD NOT allow
    TEXT[!SHOULD,exception]:    clients to renegotiate without using this extension.
    TEXT[!SHOULD,implementation,test]:    TLS implementations SHOULD provide a mechanism to disable and enable
    TEXT[!SHOULD,implementation,test]:    renegotiation.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc5869
  SECTION: [To Skip or not to Skip](#section-3.3)
    TEXT[!SHOULD]: Note, however, that if
    TEXT[!SHOULD]:    the IKM is a Diffie-Hellman value, as in the case of TLS with Diffie-
    TEXT[!SHOULD]:    Hellman, then the extract part SHOULD NOT be skipped.
    TEXT[!SHOULD]: This, however, is
    TEXT[!SHOULD]:    NOT RECOMMENDED, especially because it would omit the use of 'info'
    TEXT[!SHOULD]:    as part of the derivation process (and adding 'info' as an input to
    TEXT[!SHOULD]:    the extract step is not advisable -- see [HKDF-paper]).

  SECTION: [Test Case 1](#appendix-A.1)
    TEXT[implementation]:    PRK  = 0x077709362c2e32df0ddc3f0dc47bba63
    TEXT[implementation]:           90b6c73bb50f9c3122ec844ad7c2b3e5 (32 octets)

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc6066
  SECTION: [Maximum Fragment Length Negotiation](#section-4)
    TEXT[test,exception]:    If a server receives a maximum fragment length negotiation request
    TEXT[test,exception]:    for a value other than the allowed values, it MUST abort the
    TEXT[test,exception]:    handshake with an "illegal_parameter" alert.
    TEXT[implementation,test]: Similarly, if a client
    TEXT[implementation,test]:    receives a maximum fragment length negotiation response that differs
    TEXT[implementation,test]:    from the length it requested, it MUST also abort the handshake with
    TEXT[implementation,test]:    an "illegal_parameter" alert.
    TEXT[implementation]:    Once a maximum fragment length other than 2^14 has been successfully
    TEXT[implementation]:    negotiated, the client and server MUST immediately begin fragmenting
    TEXT[implementation]:    messages (including handshake messages) to ensure that no fragment
    TEXT[implementation]:    larger than the negotiated length is sent.

  SECTION: [Certificate Status Request](#section-8)
    TEXT[implementation]:       struct {
    TEXT[implementation]:           CertificateStatusType status_type;
    TEXT[implementation]:           select (status_type) {
    TEXT[implementation]:               case ocsp: OCSPResponse;
    TEXT[implementation]:           } response;
    TEXT[implementation]:       } CertificateStatus;
    TEXT[implementation]:       opaque OCSPResponse<1..2^24-1>;
    TEXT[implementation]:    An "ocsp_response" contains a complete, DER-encoded OCSP response
    TEXT[implementation]:    (using the ASN.1 type OCSPResponse defined in [RFC2560]).  Only one
    TEXT[implementation]:    OCSP response may be sent.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc6125
  SECTION: [Checking of Common Names](#section-6.4.4)
    TEXT[implementation]:    As noted, a client MUST NOT seek a match for a reference identifier
    TEXT[implementation]:    of CN-ID if the presented identifiers include a DNS-ID, SRV-ID,
    TEXT[implementation]:    URI-ID, or any application-specific identifier types supported by the
    TEXT[implementation]:    client.
    TEXT[implementation]:    Therefore, if and only if the presented identifiers do not include a
    TEXT[implementation]:    DNS-ID, SRV-ID, URI-ID, or any application-specific identifier types
    TEXT[implementation]:    supported by the client, then the client MAY as a last resort check
    TEXT[implementation]:    for a string whose form matches that of a fully qualified DNS domain
    TEXT[implementation]:    name in a Common Name field of the subject field (i.e., a CN-ID).

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc6960
  SECTION: [Semantics of thisUpdate, nextUpdate, and producedAt](#section-2.4)
    TEXT[implementation]:    thisUpdate      The most recent time at which the status being
    TEXT[implementation]:                    indicated is known by the responder to have been
    TEXT[implementation]:                    correct.
    TEXT[implementation]:    nextUpdate      The time at or before which newer information will be
    TEXT[implementation]:                    available about the status of the certificate.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc7301
  SECTION: [The Application-Layer Protocol Negotiation Extension](#section-3.1)
    TEXT[implementation]: Empty strings
    TEXT[implementation]:    MUST NOT be included and byte strings MUST NOT be truncated.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc7627
  SECTION: [The TLS Session Hash](#section-3)
    TEXT[test]:    When a full TLS handshake takes place, we define
    TEXT[test]:          session_hash = Hash(handshake_messages)
    TEXT[test]:    where "handshake_messages" refers to all handshake messages sent or
    TEXT[test]:    received, starting at the ClientHello up to and including the
    TEXT[test]:    ClientKeyExchange message, including the type and length fields of
    TEXT[test]:    the handshake messages.

  SECTION: [The Extended Master Secret](#section-4)
    TEXT[implementation,test]:    When the extended master secret extension is negotiated in a full
    TEXT[implementation,test]:    handshake, the "master_secret" is computed as
    TEXT[implementation,test]:    master_secret = PRF(pre_master_secret, "extended master secret",
    TEXT[implementation,test]:                        session_hash)
    TEXT[implementation,test]:                        [0..47];
    TEXT[!SHOULD]:    Clients and servers SHOULD NOT accept handshakes that do not use the
    TEXT[!SHOULD]:    extended master secret, especially if they rely on features like
    TEXT[!SHOULD]:    compound authentication that fall into the vulnerable cases described
    TEXT[!SHOULD]:    in Section 6.1.

  SECTION: [Extension Definition](#section-5.1)
    TEXT[implementation]:    This document defines a new TLS extension, "extended_master_secret"
    TEXT[implementation]:    (with extension type 0x0017), which is used to signal both client and
    TEXT[implementation]:    server to use the extended master secret computation.  The
    TEXT[implementation]:    "extension_data" field of this extension is empty.  Thus, the entire
    TEXT[implementation]:    encoding of the extension is 00 17 00 00 (in hexadecimal.)
    TEXT[!MUST]:    If the client and server agree on this extension and a full handshake
    TEXT[!MUST]:    takes place, both client and server MUST use the extended master
    TEXT[!MUST]:    secret derivation algorithm, as defined in Section 4.

  SECTION: [Client and Server Behavior: Full Handshake](#section-5.2)
    TEXT[!MUST]:    In all handshakes, a client implementing this document MUST send the
    TEXT[!MUST]:    "extended_master_secret" extension in its ClientHello.
    TEXT[!MUST]:    If a server implementing this document receives the
    TEXT[!MUST]:    "extended_master_secret" extension, it MUST include the extension in
    TEXT[!MUST]:    its ServerHello message.
    TEXT[!SHOULD]:    If the server receives a ClientHello without the extension, it SHOULD
    TEXT[!SHOULD]:    abort the handshake if it does not wish to interoperate with legacy
    TEXT[!SHOULD]:    clients.
    TEXT[!MUST]: If it chooses to continue the handshake, then it MUST NOT
    TEXT[!MUST]:    include the extension in the ServerHello.
    TEXT[!SHOULD]:    If a client receives a ServerHello without the extension, it SHOULD
    TEXT[!SHOULD]:    abort the handshake if it does not wish to interoperate with legacy
    TEXT[!SHOULD]:    servers.
    TEXT[!MUST]:    If the client and server choose to continue a full handshake without
    TEXT[!MUST]:    the extension, they MUST use the standard master secret derivation
    TEXT[!MUST]:    for the new session.

  SECTION: [Client and Server Behavior: Abbreviated Handshake](#section-5.3)
    TEXT[!SHOULD]:    The client SHOULD NOT offer an abbreviated handshake to resume a
    TEXT[!SHOULD]:    session that does not use an extended master secret.
    TEXT[!SHOULD]: Instead, it
    TEXT[!SHOULD]:    SHOULD offer a full handshake.
    TEXT[!MUST,exception]:    When offering an abbreviated handshake, the client MUST send the
    TEXT[!MUST,exception]:    "extended_master_secret" extension in its ClientHello.
    TEXT[!MUST,implementation]:    o
    TEXT[!MUST,implementation,test]: If the original session did not use the "extended_master_secret"
    TEXT[!MUST,implementation,test]:       extension but the new ClientHello contains the extension, then the
    TEXT[!MUST,implementation,test]:       server MUST NOT perform the abbreviated handshake.
    TEXT[!SHOULD,implementation,test]: Instead, it
    TEXT[!SHOULD,implementation,test]:       SHOULD continue with a full handshake (as described in
    TEXT[!SHOULD,implementation,test]:       Section 5.2) to negotiate a new session.
    TEXT[!MUST,implementation]:    o
    TEXT[!MUST,implementation,test]: If the original session used the "extended_master_secret"
    TEXT[!MUST,implementation,test]:       extension but the new ClientHello does not contain it, the server
    TEXT[!MUST,implementation,test]:       MUST abort the abbreviated handshake.
    TEXT[!SHOULD]:    o  If neither the original session nor the new ClientHello uses the
    TEXT[!SHOULD]:       extension, the server SHOULD abort the handshake.
    TEXT[!MUST]:    o  If the new ClientHello contains the extension and the server
    TEXT[!MUST]:       chooses to continue the handshake, then the server MUST include
    TEXT[!MUST]:       the "extended_master_secret" extension in its ServerHello message.
    TEXT[!MUST]:    o
    TEXT[!MUST,implementation,test]: If the original session did not use the "extended_master_secret"
    TEXT[!MUST,implementation,test]:       extension but the new ServerHello contains the extension, the
    TEXT[!MUST,implementation,test]:       client MUST abort the handshake.
    TEXT[!MUST]:    o
    TEXT[!MUST,implementation,test]: If the original session used the extension but the new ServerHello
    TEXT[!MUST,implementation,test]:       does not contain the extension, the client MUST abort the
    TEXT[!MUST,implementation,test]:       handshake.

  SECTION: [Interoperability Considerations](#section-5.4)
    TEXT[!MUST]: Hence, the client or server MUST NOT
    TEXT[!MUST]:    export any key material based on the new master secret for any
    TEXT[!MUST]:    subsequent application-level authentication.
    TEXT[!MUST]: In particular, it MUST
    TEXT[!MUST]:    disable [RFC5705] and any Extensible Authentication Protocol (EAP)
    TEXT[!MUST]:    relying on compound authentication [COMPOUND-AUTH].
    TEXT[!MUST]:    Hence, the client or server MUST NOT use the current handshake's
    TEXT[!MUST]:    "verify_data" for application-level authentication.
    TEXT[!MUST]: In particular,
    TEXT[!MUST]:    the client MUST disable renegotiation and any use of the "tls-unique"
    TEXT[!MUST]:    channel binding [RFC5929] on the current connection.
    TEXT[!MAY]:    If the original session uses an extended master secret but the
    TEXT[!MAY]:    ClientHello or ServerHello in the abbreviated handshake does not
    TEXT[!MAY]:    include the extension, it MAY be safe to continue the abbreviated
    TEXT[!MAY]:    handshake since it is protected by the extended master secret of the
    TEXT[!MAY]:    original session.
    TEXT[!MUST]: Since such situations are unusual and likely
    TEXT[!MUST]:    to be the result of transient or inadvertent misconfigurations, this
    TEXT[!MUST]:    document recommends that the client and server MUST abort such
    TEXT[!MUST]:    handshakes.

  SECTION: [Cryptographic Properties of the Hash Function](#section-6.2)
    TEXT[!SHOULD]: As such, hash functions such as MD5 or
    TEXT[!SHOULD]:    SHA1 are NOT RECOMMENDED.

  SECTION: [No SSL 3.0 Support](#section-6.4)
    TEXT[!SHOULD]: Clients and servers
    TEXT[!SHOULD]:    implementing this document SHOULD refuse SSL 3.0 handshakes.
    TEXT[!MUST]: If they
    TEXT[!MUST]:    choose to support SSL 3.0, the resulting sessions MUST use the legacy
    TEXT[!MUST]:    master secret computation, and the interoperability considerations of
    TEXT[!MUST]:    Section 5.4 apply.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc8422
  SECTION: [Key Exchange Algorithm](#section-2)
    TEXT[!SHOULD]: Applications using TLS
    TEXT[!SHOULD]:    with this algorithm SHOULD provide authentication by other means.

  SECTION: [ECDHE_ECDSA](#section-2.1)
    TEXT[!MUST]:    In ECDHE_ECDSA, the server's certificate MUST contain an ECDSA- or
    TEXT[!MUST]:    EdDSA-capable public key.
    TEXT[!MUST]: These
    TEXT[!MUST]:    parameters MUST be signed with ECDSA or EdDSA using the private key
    TEXT[!MUST]:    corresponding to the public key in the server's Certificate.

  SECTION: [ECDHE_RSA](#section-2.2)
    TEXT[!MUST]:    This key exchange algorithm is the same as ECDHE_ECDSA except that
    TEXT[!MUST]:    the server's certificate MUST contain an RSA public key authorized
    TEXT[!MUST]:    for signing and the signature in the ServerKeyExchange message must
    TEXT[!MUST]:    be computed with the corresponding RSA private key.

  SECTION: [ECDH_anon](#section-2.3)
    TEXT[!MUST]:    In ECDH_anon, the server's Certificate, the CertificateRequest, the
    TEXT[!MUST]:    client's Certificate, and the CertificateVerify messages MUST NOT be
    TEXT[!MUST]:    sent.
    TEXT[!MUST]:    The server MUST send an ephemeral ECDH public key and a specification
    TEXT[!MUST]:    of the corresponding curve in the ServerKeyExchange message.
    TEXT[!MUST]: These
    TEXT[!MUST]:    parameters MUST NOT be signed.

  SECTION: [Client Authentication](#section-3)
    TEXT[!SHOULD]:    If these conditions are not met, the client SHOULD send a client
    TEXT[!SHOULD]:    Certificate message containing no certificates.
    TEXT[!MUST]: In this case, the
    TEXT[!MUST]:    ClientKeyExchange MUST be sent as described in Section 2, and the
    TEXT[!MUST]:    CertificateVerify MUST NOT be sent.

  SECTION: [ECDSA_sign](#section-3.1)
    TEXT[!MUST]:    To use this authentication mechanism, the client MUST possess a
    TEXT[!MUST]:    certificate containing an ECDSA- or EdDSA-capable public key.

  SECTION: [TLS Extensions for ECC](#section-4)
    TEXT[!SHOULD]:    A TLS client that proposes ECC cipher suites in its ClientHello
    TEXT[!SHOULD]:    message SHOULD include these extensions.
    TEXT[!MUST]: Servers implementing ECC
    TEXT[!MUST]:    cipher suites MUST support these extensions, and when a client uses
    TEXT[!MUST]:    these extensions, servers MUST NOT negotiate the use of an ECC cipher
    TEXT[!MUST]:    suite unless they can complete the handshake while respecting the
    TEXT[!MUST]:    choice of curves specified by the client.
    TEXT[!MUST]:    The client MUST NOT include these extensions in the ClientHello
    TEXT[!MUST]:    message if it does not propose any ECC cipher suites.

  SECTION: [Client Hello Extensions](#section-5.1)
    TEXT[!SHOULD]:    The extensions SHOULD be sent along with any ClientHello message that
    TEXT[!SHOULD]:    proposes ECC cipher suites.
    TEXT[!SHOULD]: Clients
    TEXT[!SHOULD]:    SHOULD send both the Supported Elliptic Curves Extension and the
    TEXT[!SHOULD]:    Supported Point Formats Extension.
    TEXT[!MUST]: If the Supported Point Formats
    TEXT[!MUST]:    Extension is indeed sent, it MUST contain the value 0 (uncompressed)
    TEXT[!MUST]:    as one of the items in the list of point formats.
    TEXT[!MUST]:    A server that receives a ClientHello containing one or both of these
    TEXT[!MUST]:    extensions MUST use the client's enumerated capabilities to guide its
    TEXT[!MUST]:    selection of an appropriate cipher suite.
    TEXT[!MUST]: The
    TEXT[!MUST]:    server MUST consider the extensions in both cases.
    TEXT[!MUST]:    If a server does not understand the Supported Elliptic Curves
    TEXT[!MUST]:    Extension, does not understand the Supported Point Formats Extension,
    TEXT[!MUST]:    or is unable to complete the ECC handshake while restricting itself
    TEXT[!MUST]:    to the enumerated curves and point formats, it MUST NOT negotiate the
    TEXT[!MUST]:    use of an ECC cipher suite.

  SECTION: [Supported Point Formats Extension](#section-5.1.2)
    TEXT[!MUST]: Implementations of this document MUST support the
    TEXT[!MUST]:    uncompressed format for all of their supported curves and MUST NOT
    TEXT[!MUST]:    support other formats for curves defined in this specification.
    TEXT[!MAY]: For
    TEXT[!MAY]:    backwards compatibility purposes, the point format list extension MAY
    TEXT[!MAY]:    still be included and contain exactly one value: the uncompressed
    TEXT[!MAY]:    point format (0).
    TEXT[!MUST,exception]:    If the client sends the extension and the extension does not contain
    TEXT[!MUST,exception]:    the uncompressed point format, and the client has used the Supported
    TEXT[!MUST,exception]:    Groups extension to indicate support for any of the curves defined in
    TEXT[!MUST,exception]:    this specification, then the server MUST abort the handshake and
    TEXT[!MUST,exception]:    return an illegal_parameter alert.
    TEXT[!MUST]:    A client compliant with this specification that supports no other
    TEXT[!MUST]:    curves MUST send the following octets; note that the first two octets
    TEXT[!MUST]:    indicate the extension type (Supported Point Formats Extension):

  SECTION: [Server Hello Extension](#section-5.2)
    TEXT[!MAY]: Note
    TEXT[!MAY]:    that the server MAY include items that were not found in the client's
    TEXT[!MAY]:    list.
    TEXT[!MUST]: The Supported
    TEXT[!MUST]:    Point Formats Extension, when used, MUST contain the value 0
    TEXT[!MUST]:    (uncompressed) as one of the items in the list of point formats.
    TEXT[!MUST]:    A client that receives a ServerHello message containing a Supported
    TEXT[!MUST]:    Point Formats Extension MUST respect the server's choice of point
    TEXT[!MUST]:    formats during the handshake (cf.

  SECTION: [Server Certificate](#section-5.3)
    TEXT[!MUST]: ECC
    TEXT[!MUST]:    public keys MUST be encoded in certificates as described in
    TEXT[!MUST]:    Section 5.9.
    TEXT[!MUST]:    +-------------+-----------------------------------------------------+
    TEXT[!MUST]:    | Algorithm   | Server Certificate Type                             |
    TEXT[!MUST]:    +-------------+-----------------------------------------------------+
    TEXT[!MUST]:    | ECDHE_ECDSA | Certificate MUST contain an ECDSA- or EdDSA-capable |
    TEXT[!MUST]:    |             | public key.
    TEXT[!MUST]:    | ECDHE_RSA   | Certificate MUST contain an RSA public key.
    TEXT[!MUST]:    certificate MUST respect the client's choice of elliptic curves.
    TEXT[!MUST]:    server that cannot satisfy this requirement MUST NOT choose an ECC
    TEXT[!MUST]:    cipher suite in its ServerHello message.)

  SECTION: [Server Key Exchange](#section-5.4)
    TEXT[!MUST]: This structure MUST NOT be used with Ed25519 and
    TEXT[!MUST]:    Ed448 public keys.

  SECTION: [Client Certificate](#section-5.6)
    TEXT[!MUST]: The certificate MUST
    TEXT[!MUST]:    contain an ECDSA- or EdDSA-capable public key.

  SECTION: [Elliptic Curve Certificates](#section-5.9)
    TEXT[!MUST]:    X.509 certificates containing ECC public keys or signed using ECDSA
    TEXT[!MUST]:    MUST comply with [RFC3279] or another RFC that replaces or extends
    TEXT[!MUST]:    it.
    TEXT[!MUST]: X.509 certificates containing ECC public keys or signed using
    TEXT[!MUST]:    EdDSA MUST comply with [RFC8410].
    TEXT[!SHOULD]: Clients SHOULD use the elliptic
    TEXT[!SHOULD]:    curve domain parameters recommended in ANSI X9.62, FIPS 186-4, and
    TEXT[!SHOULD]:    SEC 2 [SECG-SEC2], or in [RFC8032].
    TEXT[!MUST]:    EdDSA keys using the Ed25519 algorithm MUST use the ed25519 signature
    TEXT[!MUST]:    algorithm, and Ed448 keys MUST use the ed448 signature algorithm.
    TEXT[!MUST]: Ed25519, Ed25519ph, Ed448, and Ed448ph keys MUST NOT be used
    TEXT[!MUST]:    with ECDSA.

  SECTION: [ECDH, ECDSA, and RSA Computations](#section-5.10)
    TEXT[!MUST]:    Element to Octet String Conversion Primitive), has constant length
    TEXT[!MUST]:    for any given field; leading zeros found in this octet string MUST
    TEXT[!MUST]:    NOT be truncated.
    TEXT[!MUST]:    An ECDHE key exchange using X25519 (curve x25519) goes as follows:
    TEXT[!MUST]:    (1) each party picks a secret key d uniformly at random and computes
    TEXT[!MUST]:    the corresponding public key x = X25519(d, G); (2) parties exchange
    TEXT[!MUST]:    their public keys and compute a shared secret as x_S = X25519(d,
    TEXT[!MUST]:    x_peer); and (3), if either party obtains all-zeroes x_S, it MUST
    TEXT[!MUST]:    abort the handshake (as required by definition of X25519 and X448).
    TEXT[!MUST]:    All ECDSA computations MUST be performed according to ANSI X9.62 or
    TEXT[!MUST]:    its successors.
    TEXT[!MUST]:    A secure hash function such as SHA-256, SHA-384, or SHA-512 from
    TEXT[!MUST]:    [FIPS.180-4] MUST be used.
    TEXT[!MUST]:    All EdDSA computations MUST be performed according to [RFC8032] or
    TEXT[!MUST]:    its successors.
    TEXT[!MUST]: The context parameter for Ed448 MUST be
    TEXT[!MUST]:    set to the empty string.
    TEXT[!MUST]: EdDSA signatures MUST have HashAlgorithm of 8
    TEXT[!MUST]:    (Intrinsic).

  SECTION: [Public Key Validation](#section-5.11)
    TEXT[!MUST,implementation]:    With the NIST curves, each party MUST validate the public key sent by
    TEXT[!MUST,implementation]:    its peer in the ClientKeyExchange and ServerKeyExchange messages.
    TEXT[implementation]:   A
    TEXT[!MUST,implementation]:    receiving party MUST check that the x and y parameters from the
    TEXT[!MUST,implementation]:    peer's public value satisfy the curve equation, y^2 = x^3 + ax + b
    TEXT[!MUST,implementation]:    mod p.
    TEXT[!MUST]:    With X25519 and X448, a receiving party MUST check whether the
    TEXT[!MUST]:    computed premaster secret is the all-zero value and abort the
    TEXT[!MUST]:    handshake if so, as described in Section 6 of [RFC7748].

  SECTION: [Cipher Suites](#section-6)
    TEXT[!SHOULD]:    Server implementations SHOULD support all of the following cipher
    TEXT[!SHOULD]:    suites, and client implementations SHOULD support at least one of
    TEXT[!SHOULD]:    them:

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc8446
  SECTION: [Protocol Overview](#section-2)
    TEXT[!MUST]: If (EC)DHE key establishment
    TEXT[!MUST]:    is in use, then the ServerHello contains a "key_share" extension with
    TEXT[!MUST]:    the server's ephemeral Diffie-Hellman share; the server's share MUST
    TEXT[!MUST]:    be in the same group as one of the client's shares.
    TEXT[!MUST]:    Application Data MUST NOT be sent prior to sending the Finished
    TEXT[!MUST]:    message, except as specified in Section 2.3.

  SECTION: [Incorrect DHE Share](#section-2.1)
    TEXT[!MUST]: If no
    TEXT[!MUST]:    common cryptographic parameters can be negotiated, the server MUST
    TEXT[!MUST]:    abort the handshake with an appropriate alert.

  SECTION: [Resumption and Pre-Shared Key (PSK)](#section-2.2)
    TEXT[!SHOULD]: When a client offers
    TEXT[!SHOULD]:    resumption via a PSK, it SHOULD also supply a "key_share" extension
    TEXT[!SHOULD]:    to the server to allow the server to decline resumption and fall back
    TEXT[!SHOULD]:    to a full handshake, if needed.
    TEXT[!MUST]:    When PSKs are provisioned out of band, the PSK identity and the KDF
    TEXT[!MUST]:    hash algorithm to be used with the PSK MUST also be provisioned.

  SECTION: [Handshake Protocol](#section-4)
    TEXT[!MUST]:    Protocol messages MUST be sent in the order defined in Section 4.4.1
    TEXT[!MUST]:    and shown in the diagrams in Section 2.
    TEXT[!MUST]: A peer which receives a
    TEXT[!MUST]:    handshake message in an unexpected order MUST abort the handshake
    TEXT[!MUST]:    with an "unexpected_message" alert.

  SECTION: [Cryptographic Negotiation](#section-4.1.1)
    TEXT[!MUST]: If there is no overlap between the received
    TEXT[!MUST]:    "supported_groups" and the groups supported by the server, then the
    TEXT[!MUST]:    server MUST abort the handshake with a "handshake_failure" or an
    TEXT[!MUST]:    "insufficient_security" alert.
    TEXT[!MUST]:    If the server selects a PSK, then it MUST also select a key
    TEXT[!MUST]:    establishment mode from the set indicated by the client's
    TEXT[!MUST]:    "psk_key_exchange_modes" extension (at present, PSK alone or with
    TEXT[!MUST]:    (EC)DHE).
    TEXT[!MUST,implementation,test]:    If the server selects an (EC)DHE group and the client did not offer a
    TEXT[!MUST,implementation,test]:    compatible "key_share" extension in the initial ClientHello, the
    TEXT[!MUST,implementation,test]:    server MUST respond with a HelloRetryRequest (Section 4.1.4) message.
    TEXT[!MUST]:    If the server is unable to negotiate a supported set of parameters
    TEXT[!MUST]:    (i.e., there is no overlap between the client and server parameters),
    TEXT[!MUST]:    it MUST abort the handshake with either a "handshake_failure" or
    TEXT[!MUST]:    "insufficient_security" fatal alert (see Section 6).

  SECTION: [Client Hello](#section-4.1.2)
    TEXT[!MUST]:    When a client first connects to a server, it is REQUIRED to send the
    TEXT[!MUST]:    ClientHello as its first TLS message.
    TEXT[implementation,test]: The client will also send a
    TEXT[implementation,test]:    ClientHello when the server has responded to its ClientHello with a
    TEXT[implementation,test]:    HelloRetryRequest.
    TEXT[!MUST,implementation,test]: In that case, the client MUST send the same
    TEXT[!MUST,implementation,test]:    ClientHello without modification
    TEXT[!MUST,implementation]: , except as follows:
    TEXT[implementation,test]:    -  If a "key_share" extension was supplied in the HelloRetryRequest,
    TEXT[implementation,test]:       replacing the list of shares with a list containing a single
    TEXT[implementation,test]:       KeyShareEntry from the indicated group.
    TEXT[implementation,test]:    -  Removing the "early_data" extension (Section 4.2.10) if one was
    TEXT[implementation,test]:       present.  Early data is not permitted after a HelloRetryRequest.
    TEXT[implementation,test]:    -  Including a "cookie" extension if one was provided in the
    TEXT[implementation,test]:       HelloRetryRequest.
    TEXT[implementation,test]:    -  Updating the "pre_shared_key" extension if present by recomputing
    TEXT[implementation,test]:       the "obfuscated_ticket_age" and binder values and (optionally)
    TEXT[implementation,test]:       removing any PSKs which are incompatible with the server's
    TEXT[implementation,test]:       indicated cipher suite.
    TEXT[!MUST]:    Because TLS 1.3 forbids renegotiation, if a server has negotiated
    TEXT[!MUST]:    TLS 1.3 and receives a ClientHello at any other time, it MUST
    TEXT[!MUST]:    terminate the connection with an "unexpected_message" alert.
    TEXT[!MUST]:    If a server established a TLS connection with a previous version of
    TEXT[!MUST]:    TLS and receives a TLS 1.3 ClientHello in a renegotiation, it MUST
    TEXT[!MUST]:    retain the previous protocol version.
    TEXT[!MUST]: In particular, it MUST NOT
    TEXT[!MUST]:    negotiate TLS 1.3.
    TEXT[!MUST]: In
    TEXT[!MUST]:       TLS 1.3, the client indicates its version preferences in the
    TEXT[!MUST]:       "supported_versions" extension (Section 4.2.1) and the
    TEXT[!MUST]:       legacy_version field MUST be set to 0x0303, which is the version
    TEXT[!MUST]:       number for TLS 1.2.
    TEXT[!SHOULD]: A client which has a
    TEXT[!SHOULD]:       cached session ID set by a pre-TLS 1.3 server SHOULD set this
    TEXT[!SHOULD]:       field to that value.
    TEXT[!MUST]: In compatibility mode (see Appendix D.4),
    TEXT[!MUST]:       this field MUST be non-empty, so a client not offering a
    TEXT[!MUST]:       pre-TLS 1.3 session MUST generate a new 32-byte value.
    TEXT[!SHOULD]: This value
    TEXT[!SHOULD]:       need not be random but SHOULD be unpredictable to avoid
    TEXT[!SHOULD]:       implementations fixating on a specific value (also known as
    TEXT[!SHOULD]:       ossification).
    TEXT[!MUST]: Otherwise, it MUST be set as a zero-length vector
    TEXT[!MUST]:       (i.e., a zero-valued single byte length field).
    TEXT[!MUST]: If the list contains cipher suites that the server
    TEXT[!MUST]:       does not recognize, support, or wish to use, the server MUST
    TEXT[!MUST]:       ignore those cipher suites and process the remaining ones as
    TEXT[!MUST]:       usual.
    TEXT[!SHOULD]: If the client is attempting a PSK key establishment, it
    TEXT[!SHOULD]:       SHOULD advertise at least one cipher suite indicating a Hash
    TEXT[!SHOULD]:       associated with the PSK.
    TEXT[!MUST]: For every TLS 1.3 ClientHello, this vector
    TEXT[!MUST]:       MUST contain exactly one byte, set to zero, which corresponds to
    TEXT[!MUST]:       the "null" compression method in prior versions of TLS.
    TEXT[!MUST]: If a
    TEXT[!MUST]:       TLS 1.3 ClientHello is received with any other value in this
    TEXT[!MUST]:       field, the server MUST abort the handshake with an
    TEXT[!MUST]:       "illegal_parameter" alert.
    TEXT[!MUST]: Note that TLS 1.3 servers might
    TEXT[!MUST]:       receive TLS 1.2 or prior ClientHellos which contain other
    TEXT[!MUST]:       compression methods and (if negotiating such a prior version) MUST
    TEXT[!MUST]:       follow the procedures for the appropriate prior version of TLS.
    TEXT[!MUST]: Servers MUST ignore unrecognized extensions.
    TEXT[!MUST]: If negotiating a version of TLS prior to 1.3,
    TEXT[!MUST]:    a server MUST check that the message either contains no data after
    TEXT[!MUST]:    legacy_compression_methods or that it contains a valid extensions
    TEXT[!MUST]:    block with no data following.
    TEXT[!MUST]: If not, then it MUST abort the
    TEXT[!MUST]:    handshake with a "decode_error" alert.
    TEXT[!MAY]:    In the event that a client requests additional functionality using
    TEXT[!MAY]:    extensions and this functionality is not supplied by the server, the
    TEXT[!MAY]:    client MAY abort the handshake.

  SECTION: [Server Hello](#section-4.1.3)
    TEXT[!MUST]: In TLS 1.3, the TLS server indicates
    TEXT[!MUST]:       its version using the "supported_versions" extension
    TEXT[!MUST]:       (Section 4.2.1), and the legacy_version field MUST be set to
    TEXT[!MUST]:       0x0303, which is the version number for TLS 1.2.
    TEXT[!MUST]: The last 8 bytes MUST be
    TEXT[!MUST]:       overwritten as described below if negotiating TLS 1.2 or TLS 1.1,
    TEXT[!MUST]:       but the remaining bytes MUST be random.
    TEXT[!MUST]: This structure is
    TEXT[!MUST]:       generated by the server and MUST be generated independently of the
    TEXT[!MUST]:       ClientHello.random.
    TEXT[!MUST,implementation]: A client which
    TEXT[!MUST,implementation]:       receives a legacy_session_id_echo field that does not match what
    TEXT[!MUST,implementation]:       it sent in the ClientHello MUST abort the handshake with an
    TEXT[!MUST,implementation]:       "illegal_parameter" alert.
    TEXT[!MUST,implementation]: A client which receives a
    TEXT[!MUST,implementation]:       cipher suite that was not offered MUST abort the handshake with an
    TEXT[!MUST,implementation]:       "illegal_parameter" alert.
    TEXT[!MUST,implementation]:    legacy_compression_method:  A single byte which MUST have the
    TEXT[!MUST,implementation]:       value 0.
    TEXT[!MUST]: The ServerHello MUST only include
    TEXT[!MUST]:       extensions which are required to establish the cryptographic
    TEXT[!MUST]:       context and negotiate the protocol version.
    TEXT[!MUST]: All TLS 1.3
    TEXT[!MUST]:       ServerHello messages MUST contain the "supported_versions"
    TEXT[!MUST]:       extension.
    TEXT[!MUST,implementation,test]:    Upon receiving a message with type server_hello, implementations MUST
    TEXT[!MUST,implementation,test]:    first examine the Random value and, if it matches this value, process
    TEXT[!MUST,implementation,test]:    it as described in Section 4.1.4).
    TEXT[!MUST]: TLS 1.3 servers which negotiate TLS 1.2 or below in
    TEXT[!MUST]:    response to a ClientHello MUST set the last 8 bytes of their Random
    TEXT[!MUST]:    value specially in their ServerHello.
    TEXT[!MUST]:    If negotiating TLS 1.2, TLS 1.3 servers MUST set the last 8 bytes of
    TEXT[!MUST]:    their Random value to the bytes:
    TEXT[!MUST]:    If negotiating TLS 1.1 or below, TLS 1.3 servers MUST, and TLS 1.2
    TEXT[!MUST]:    servers SHOULD, set the last 8 bytes of their ServerHello.Random
    TEXT[!MUST]:    value to the bytes:
    TEXT[!MUST]:    TLS 1.3 clients receiving a ServerHello indicating TLS 1.2 or below
    TEXT[!MUST]:    MUST check that the last 8 bytes are not equal to either of these
    TEXT[!MUST]:    values.
    TEXT[!SHOULD]: TLS 1.2 clients SHOULD also check that the last 8 bytes are
    TEXT[!SHOULD]:    not equal to the second value if the ServerHello indicates TLS 1.1 or
    TEXT[!SHOULD]:    below.
    TEXT[!MUST]: If a match is found, the client MUST abort the handshake with
    TEXT[!MUST]:    an "illegal_parameter" alert.
    TEXT[!MUST]:    A legacy TLS client performing renegotiation with TLS 1.2 or prior
    TEXT[!MUST]:    and which receives a TLS 1.3 ServerHello during renegotiation MUST
    TEXT[!MUST]:    abort the handshake with a "protocol_version" alert.

  SECTION: [Hello Retry Request](#section-4.1.4)
    TEXT[!MUST,implementation,test]:    The server's extensions MUST contain "supported_versions".
    TEXT[!SHOULD]:    Additionally, it SHOULD contain the minimal set of extensions
    TEXT[!SHOULD]:    necessary for the client to generate a correct ClientHello pair.
    TEXT[!MUST,implementation,test]: As
    TEXT[!MUST,implementation,test]:    with the ServerHello, a HelloRetryRequest MUST NOT contain any
    TEXT[!MUST,implementation,test]:    extensions that were not first offered by the client in its
    TEXT[!MUST,implementation,test]:    ClientHello, with the exception of optionally the "cookie" (see
    TEXT[!MUST,implementation,test]:    Section 4.2.2) extension.
    TEXT[!MUST,implementation,test]:    Upon receipt of a HelloRetryRequest, the client MUST check the
    TEXT[!MUST,implementation,test]:    legacy_version, legacy_session_id_echo, cipher_suite, and
    TEXT[!MUST,implementation,test]:    legacy_compression_method
    TEXT[!MUST,test]:  as specified in Section 4.1.3 and then
    TEXT[!MUST,test]:    process the extensions, starting with determining the version using
    TEXT[!MUST,test]:    "supported_versions".
    TEXT[!MUST,implementation,test]: Clients MUST abort the handshake with an
    TEXT[!MUST,implementation,test]:    "illegal_parameter" alert if the HelloRetryRequest would not result
    TEXT[!MUST,implementation,test]:    in any change in the ClientHello.
    TEXT[!MUST,implementation,test]: If a client receives a second
    TEXT[!MUST,implementation,test]:    HelloRetryRequest in the same connection (i.e., where the ClientHello
    TEXT[!MUST,implementation,test]:    was itself in response to a HelloRetryRequest), it MUST abort the
    TEXT[!MUST,implementation,test]:    handshake with an "unexpected_message" alert.
    TEXT[!MUST,implementation,test]:    Otherwise, the client MUST process all extensions in the
    TEXT[!MUST,implementation,test]:    HelloRetryRequest
    TEXT[!MUST,test]:  and send a second updated ClientHello.
    TEXT[implementation]: The
    TEXT[implementation]:    HelloRetryRequest extensions defined in this specification are:
    TEXT[implementation]:    -  supported_versions (see Section 4.2.1)
    TEXT[implementation]:    -  cookie (see Section 4.2.2)
    TEXT[implementation]:    -  key_share (see Section 4.2.8)
    TEXT[!MUST,implementation,test]:    A client which receives a cipher suite that was not offered MUST
    TEXT[!MUST,implementation,test]:    abort the handshake.
    TEXT[!MUST,implementation,test]: Servers MUST ensure that they negotiate the
    TEXT[!MUST,implementation,test]:    same cipher suite when receiving a conformant updated ClientHello (if
    TEXT[!MUST,implementation,test]:    the server selects the cipher suite as the first step in the
    TEXT[!MUST,implementation,test]:    negotiation, then this will happen automatically).
    TEXT[!MUST,implementation,test]: Upon receiving
    TEXT[!MUST,implementation,test]:    the ServerHello, clients MUST check that the cipher suite supplied in
    TEXT[!MUST,implementation,test]:    the ServerHello is the same as that in the HelloRetryRequest and
    TEXT[!MUST,implementation,test]:    otherwise abort the handshake with an "illegal_parameter" alert.
    TEXT[!SHOULD,implementation,test]:    In addition, in its updated ClientHello, the client SHOULD NOT offer
    TEXT[!SHOULD,implementation,test]:    any pre-shared keys associated with a hash other than that of the
    TEXT[!SHOULD,implementation,test]:    selected cipher suite.
    TEXT[implementation,test]:   This allows the client to avoid having to
    TEXT[implementation,test]:    compute partial hash transcripts for multiple hashes in the second
    TEXT[implementation,test]:    ClientHello.
    TEXT[!MUST,implementation,test]:    The value of selected_version in the HelloRetryRequest
    TEXT[!MUST,implementation,test]:    "supported_versions" extension MUST be retained in the ServerHello,
    TEXT[!MUST,implementation,test]:    and a client MUST abort the handshake with an "illegal_parameter"
    TEXT[!MUST,implementation,test]:    alert if the value changes.

  SECTION: [Extensions](#section-4.2)
    TEXT[!MAY]: The server sends extension requests in the
    TEXT[!MAY]:    CertificateRequest message which a client MAY respond to with a
    TEXT[!MAY]:    Certificate message.
    TEXT[!MAY]: The server MAY also send unsolicited extensions
    TEXT[!MAY]:    in the NewSessionTicket, though the client does not respond directly
    TEXT[!MAY]:    to these.
    TEXT[!MUST,implementation,test]:    Implementations MUST NOT send extension responses if the remote
    TEXT[!MUST,implementation,test]:    endpoint did not send the corresponding extension requests, with the
    TEXT[!MUST,implementation,test]:    exception of the "cookie" extension in the HelloRetryRequest.
    TEXT[!MUST,implementation,test]: Upon
    TEXT[!MUST,implementation,test]:    receiving such an extension, an endpoint MUST abort the handshake
    TEXT[!MUST,implementation,test]:    with an "unsupported_extension" alert.
    TEXT[!MUST,exception]: If an implementation receives an extension
    TEXT[!MUST,exception]:    which it recognizes and which is not specified for the message in
    TEXT[!MUST,exception]:    which it appears, it MUST abort the handshake with an
    TEXT[!MUST,exception]:    "illegal_parameter" alert.
    TEXT[!MUST]:    When multiple extensions of different types are present, the
    TEXT[!MUST]:    extensions MAY appear in any order, with the exception of
    TEXT[!MUST]:    "pre_shared_key" (Section 4.2.11) which MUST be the last extension in
    TEXT[!MUST]:    the ClientHello (but can appear anywhere in the ServerHello
    TEXT[!MUST]:    extensions block).
    TEXT[!MUST]: There MUST NOT be more than one extension of the
    TEXT[!MUST]:    same type in a given extension block.

  SECTION: [Supported Versions](#section-4.2.1)
    TEXT[!MUST]:    Implementations of this specification MUST send this extension in the
    TEXT[!MUST]:    ClientHello containing all versions of TLS which they are prepared to
    TEXT[!MUST]:    negotiate (for this specification, that means minimally 0x0304, but
    TEXT[!MUST]:    if previous versions of TLS are allowed to be negotiated, they MUST
    TEXT[!MUST]:    be present as well).
    TEXT[!MUST]:    If this extension is not present, servers which are compliant with
    TEXT[!MUST]:    this specification and which also support TLS 1.2 MUST negotiate
    TEXT[!MUST]:    TLS 1.2 or prior as specified in [RFC5246], even if
    TEXT[!MUST]:    ClientHello.legacy_version is 0x0304 or later.
    TEXT[!MAY]: Servers MAY abort the
    TEXT[!MAY]:    handshake upon receiving a ClientHello with legacy_version 0x0304 or
    TEXT[!MAY]:    later.
    TEXT[!MUST,exception]:    If this extension is present in the ClientHello, servers MUST NOT use
    TEXT[!MUST,exception]:    the ClientHello.legacy_version value for version negotiation and MUST
    TEXT[!MUST,exception]:    use only the "supported_versions" extension to determine client
    TEXT[!MUST,exception]:    preferences.
    TEXT[!MUST]: Servers MUST only select a version of TLS present in
    TEXT[!MUST]:    that extension and MUST ignore any unknown versions that are present
    TEXT[!MUST]:    in that extension.
    TEXT[!SHOULD]: Implementations of TLS 1.3 which choose to support prior
    TEXT[!SHOULD]:    versions of TLS SHOULD support TLS 1.2.
    TEXT[!MUST]: Servers MUST be prepared to
    TEXT[!MUST]:    receive ClientHellos that include this extension but do not include
    TEXT[!MUST]:    0x0304 in the list of versions.
    TEXT[!MUST]:    A server which negotiates a version of TLS prior to TLS 1.3 MUST set
    TEXT[!MUST]:    ServerHello.version and MUST NOT send the "supported_versions"
    TEXT[!MUST]:    extension.
    TEXT[!MUST]: A server which negotiates TLS 1.3 MUST respond by sending
    TEXT[!MUST]:    a "supported_versions" extension containing the selected version
    TEXT[!MUST]:    value (0x0304).
    TEXT[!MUST]: It MUST set the ServerHello.legacy_version field to
    TEXT[!MUST]:    0x0303 (TLS 1.2).
    TEXT[!MUST]: Clients MUST check for this extension prior to
    TEXT[!MUST]:    processing the rest of the ServerHello (although they will have to
    TEXT[!MUST]: If this
    TEXT[!MUST]:    extension is present, clients MUST ignore the
    TEXT[!MUST]:    ServerHello.legacy_version value and MUST use only the
    TEXT[!MUST]:    "supported_versions" extension to determine the selected version.
    TEXT[!MUST]: If
    TEXT[!MUST]:    the "supported_versions" extension in the ServerHello contains a
    TEXT[!MUST]:    version not offered by the client or contains a version prior to
    TEXT[!MUST]:    TLS 1.3, the client MUST abort the handshake with an
    TEXT[!MUST]:    "illegal_parameter" alert.

  SECTION: [Cookie](#section-4.2.2)
    TEXT[implementation]:       struct {
    TEXT[implementation]:           opaque cookie<1..2^16-1>;
    TEXT[implementation]:       } Cookie;
    TEXT[implementation]:    Cookies serve two primary purposes:
    TEXT[implementation]:    -  Allowing the server to force the client to demonstrate
    TEXT[implementation]:       reachability at their apparent network address (thus providing a
    TEXT[implementation]:       measure of DoS protection).  This is primarily useful for
    TEXT[implementation]:       non-connection-oriented transports (see [RFC6347] for an example
    TEXT[implementation]:       of this).
    TEXT[implementation]:    -  Allowing the server to offload state to the client, thus allowing
    TEXT[implementation]:       it to send a HelloRetryRequest without storing any state.  The
    TEXT[implementation]:       server can do this by storing the hash of the ClientHello in the
    TEXT[implementation]:       HelloRetryRequest cookie (protected with some suitable integrity
    TEXT[implementation]:       protection algorithm).
    TEXT[!MAY,implementation,test]:    When sending a HelloRetryRequest, the server MAY provide a "cookie"
    TEXT[!MAY,implementation,test]:    extension to the client (this is an exception to the usual rule that
    TEXT[!MAY,implementation,test]:    the only extensions that may be sent are those that appear in the
    TEXT[!MAY,implementation,test]:    ClientHello).
    TEXT[!MUST,implementation,test]: When sending the new ClientHello, the client MUST copy
    TEXT[!MUST,implementation,test]:    the contents of the extension received in the HelloRetryRequest into
    TEXT[!MUST,implementation,test]:    a "cookie" extension in the new ClientHello.
    TEXT[!MUST]: Clients MUST NOT use
    TEXT[!MUST]:    cookies in their initial ClientHello in subsequent connections.
    TEXT[!MUST]: Servers operating statelessly MUST ignore these records.

  SECTION: [Signature Algorithms](#section-4.2.3)
    TEXT[!MUST]: The keys found in certificates MUST also
    TEXT[!MUST]:    be of appropriate type for the signature algorithms they are used
    TEXT[!MUST]:    with.
    TEXT[exception]: If no "signature_algorithms_cert" extension is
    TEXT[exception]:    present, then the "signature_algorithms" extension also applies to
    TEXT[exception]:    signatures appearing in certificates.
    TEXT[!MUST]: Clients which desire the
    TEXT[!MUST]:    server to authenticate itself via a certificate MUST send the
    TEXT[!MUST]:    "signature_algorithms" extension.
    TEXT[!MUST]: If a server is authenticating via
    TEXT[!MUST]:    a certificate and the client has not sent a "signature_algorithms"
    TEXT[!MUST]:    extension, then the server MUST abort the handshake with a
    TEXT[!MUST]:    "missing_extension" alert (see Section 9.2).
    TEXT[!SHOULD]:    TLS 1.2 implementations SHOULD also process this extension.
    TEXT[!MAY]:    Implementations which have the same policy in both cases MAY omit the
    TEXT[!MAY]:    "signature_algorithms_cert" extension.
    TEXT[!MAY]: These values refer solely to signatures
    TEXT[!MAY]:       which appear in certificates (see Section 4.4.2.2) and are not
    TEXT[!MAY]:       defined for use in signed TLS handshake messages, although they
    TEXT[!MAY]:       MAY appear in "signature_algorithms" and
    TEXT[!MAY]:       "signature_algorithms_cert" for backward compatibility with
    TEXT[!MAY]:       TLS 1.2.
    TEXT[!MUST]:       The length of the Salt MUST be equal to the length of the output
    TEXT[!MUST]:       of the digest algorithm.
    TEXT[!MUST]: If the public key is carried in an X.509
    TEXT[!MUST]:       certificate, it MUST use the rsaEncryption OID [RFC5280].
    TEXT[!MUST]:       The length of the Salt MUST be equal to the length of the digest
    TEXT[!MUST]:       algorithm.
    TEXT[!MUST]: If the public key is carried in an X.509 certificate,
    TEXT[!MUST]:       it MUST use the RSASSA-PSS OID [RFC5756].
    TEXT[!MUST]: When used in
    TEXT[!MUST]:       certificate signatures, the algorithm parameters MUST be DER
    TEXT[!MUST]:       encoded.
    TEXT[!MUST]: If the corresponding public key's parameters are
    TEXT[!MUST]:       present, then the parameters in the signature MUST be identical to
    TEXT[!MUST]:       those in the public key.
    TEXT[!SHOULD]: Endpoints SHOULD NOT negotiate these algorithms but are
    TEXT[!SHOULD]:       permitted to do so solely for backward compatibility.
    TEXT[!MUST]: Clients
    TEXT[!MUST]:       offering these values MUST list them as the lowest priority
    TEXT[!MUST]:       (listed after all other algorithms in SignatureSchemeList).
    TEXT[!MUST]:       TLS 1.3 servers MUST NOT offer a SHA-1 signed certificate unless
    TEXT[!MUST]:       no valid certificate chain can be produced without it (see
    TEXT[!MUST]:       Section 4.4.2.2).
    TEXT[!MAY]: A certificate that
    TEXT[!MAY]:    begins a certification path MAY use a signature algorithm that is not
    TEXT[!MAY]:    advertised as being supported in the "signature_algorithms"
    TEXT[!MAY]:    extension.
    TEXT[!MUST]: TLS 1.3
    TEXT[!MUST]:    implementations willing to negotiate TLS 1.2 MUST behave in
    TEXT[!MUST]:    accordance with the requirements of [RFC5246] when negotiating that
    TEXT[!MUST]:    version.
    TEXT[!MAY]:    -  TLS 1.2 ClientHellos MAY omit this extension.
    TEXT[!MUST]: They MUST NOT be offered or negotiated by any
    TEXT[!MUST]:       implementation.
    TEXT[!MUST]: In particular, MD5 [SLOTH], SHA-224, and DSA
    TEXT[!MUST]:       MUST NOT be used.
    TEXT[!MUST]: If TLS 1.2 is negotiated, implementations MUST be prepared
    TEXT[!MUST]:       to accept a signature that uses any curve that they advertised in
    TEXT[!MUST]:       the "supported_groups" extension.
    TEXT[!MUST]:    -  Implementations that advertise support for RSASSA-PSS (which is
    TEXT[!MUST]:       mandatory in TLS 1.3) MUST be prepared to accept a signature using
    TEXT[!MUST]:       that scheme even when TLS 1.2 is negotiated.

  SECTION: [Certificate Authorities](#section-4.2.4)
    TEXT[!SHOULD,exception]:    The "certificate_authorities" extension is used to indicate the
    TEXT[!SHOULD,exception]:    certificate authorities (CAs) which an endpoint supports and which
    TEXT[!SHOULD,exception]:    SHOULD be used by the receiving endpoint to guide certificate
    TEXT[!SHOULD,exception]:    selection.
    TEXT[!MAY,test,exception]:    The client MAY send the "certificate_authorities" extension in the
    TEXT[!MAY,test,exception]:    ClientHello message.
    TEXT[!MAY,implementation,test]: The server MAY send it in the
    TEXT[!MAY,implementation,test]:    CertificateRequest message.

  SECTION: [OID Filters](#section-4.2.5)
    TEXT[!MUST]: This extension, if provided by the server, MUST only be sent
    TEXT[!MUST]:    in the CertificateRequest message.
    TEXT[!MUST]: If the server has included a non-empty
    TEXT[!MUST]:       filters list, the client certificate included in the response MUST
    TEXT[!MUST]:       contain all of the specified extension OIDs that the client
    TEXT[!MUST]:       recognizes.
    TEXT[!MUST]: For each extension OID recognized by the client, all
    TEXT[!MUST]:       of the specified values MUST be present in the client certificate
    TEXT[!MUST]:       (but the certificate MAY have other values as well).
    TEXT[!MUST]: However, the
    TEXT[!MUST]:       client MUST ignore and skip any unrecognized certificate extension
    TEXT[!MUST]:       OIDs.
    TEXT[!MAY]: If the client ignored some of the required certificate
    TEXT[!MAY]:       extension OIDs and supplied a certificate that does not satisfy
    TEXT[!MAY]:       the request, the server MAY at its discretion either continue the
    TEXT[!MAY]:       connection without client authentication or abort the handshake
    TEXT[!MAY]:       with an "unsupported_certificate" alert.
    TEXT[!MUST]: Any given OID MUST NOT
    TEXT[!MUST]:       appear more than once in the filters list.
    TEXT[!MUST]: The
    TEXT[!MUST]:       special anyExtendedKeyUsage OID MUST NOT be used in the request.

  SECTION: [Post-Handshake Client Authentication](#section-4.2.6)
    TEXT[!MUST]:    Servers MUST NOT send a post-handshake CertificateRequest to clients
    TEXT[!MUST]:    which do not offer this extension.
    TEXT[!MUST]: Servers MUST NOT send this
    TEXT[!MUST]:    extension.

  SECTION: [Supported Groups](#section-4.2.7)
    TEXT[!MUST]: Clients MUST NOT act upon any information
    TEXT[!MUST]:    found in "supported_groups" prior to successful completion of the
    TEXT[!MUST]:    handshake but MAY use the information learned from a successfully
    TEXT[!MUST]:    completed handshake to change what groups they use in their
    TEXT[!MUST]:    "key_share" extension in subsequent connections.
    TEXT[!SHOULD]: If the server has a
    TEXT[!SHOULD]:    group it prefers to the ones in the "key_share" extension but is
    TEXT[!SHOULD]:    still willing to accept the ClientHello, it SHOULD send
    TEXT[!SHOULD]:    "supported_groups" to update the client's view of its preferences;
    TEXT[!SHOULD]:    this extension SHOULD contain all groups the server supports,
    TEXT[!SHOULD]:    regardless of whether they are currently supported by the client.

  SECTION: [Key Share](#section-4.2.8)
    TEXT[!MAY]:    Clients MAY send an empty client_shares vector in order to request
    TEXT[!MAY]:    group selection from the server, at the cost of an additional round
    TEXT[!MAY]:    trip (see Section 4.1.4).
    TEXT[!MAY]:    This vector MAY be empty if the client is requesting a
    TEXT[!MAY]:    HelloRetryRequest.
    TEXT[!MUST]: Each KeyShareEntry value MUST correspond to a
    TEXT[!MUST]:    group offered in the "supported_groups" extension and MUST appear in
    TEXT[!MUST]:    the same order.
    TEXT[!MAY]: However, the values MAY be a non-contiguous subset
    TEXT[!MAY]:    of the "supported_groups" extension and MAY omit the most preferred
    TEXT[!MAY]:    groups.
    TEXT[!MUST]: The
    TEXT[!MUST]:    key_exchange values for each KeyShareEntry MUST be generated
    TEXT[!MUST]:    independently.
    TEXT[!MUST]: Clients MUST NOT offer multiple KeyShareEntry values
    TEXT[!MUST]:    for the same group.
    TEXT[!MUST]: Clients MUST NOT offer any KeyShareEntry values
    TEXT[!MUST]:    for groups not listed in the client's "supported_groups" extension.
    TEXT[!MAY]:    Servers MAY check for violations of these rules and abort the
    TEXT[!MAY]:    handshake with an "illegal_parameter" alert if one is violated.
    TEXT[!MUST,implementation,test]:    Upon receipt of this extension in a HelloRetryRequest, the client
    TEXT[!MUST,implementation,test]:    MUST verify that (1) the selected_group field corresponds to a group
    TEXT[!MUST,implementation,test]:    which was provided in the "supported_groups" extension in the
    TEXT[!MUST,implementation,test]:    original ClientHello
    TEXT[!MUST,implementation,test]: and (2) the selected_group field does not
    TEXT[!MUST,implementation,test]:    correspond to a group which was provided in the "key_share" extension
    TEXT[!MUST,implementation,test]:    in the original ClientHello.
    TEXT[!MUST,implementation]: If either of these checks fails, then
    TEXT[!MUST,implementation]:    the client MUST abort the handshake with an "illegal_parameter"
    TEXT[!MUST,implementation]:    alert.
    TEXT[!MUST,implementation,test]: Otherwise, when sending the new ClientHello, the client MUST
    TEXT[implementation,test]:    replace the original "key_share" extension with one containing only a
    TEXT[implementation,test]:    new KeyShareEntry for the group indicated in the selected_group field
    TEXT[implementation,test]:    of the triggering HelloRetryRequest.
    TEXT[!MUST]: This value MUST be in the same
    TEXT[!MUST]:    group as the KeyShareEntry value offered by the client that the
    TEXT[!MUST]:    server has selected for the negotiated key exchange.
    TEXT[!MUST]: Servers
    TEXT[!MUST]:    MUST NOT send a KeyShareEntry for any group not indicated in the
    TEXT[!MUST]:    client's "supported_groups" extension and MUST NOT send a
    TEXT[!MUST]:    KeyShareEntry when using the "psk_ke" PskKeyExchangeMode.
    TEXT[!MUST,implementation,test]: If using
    TEXT[!MUST,implementation,test]:    (EC)DHE key establishment and a HelloRetryRequest containing a
    TEXT[!MUST,implementation,test]:    "key_share" extension was received by the client, the client MUST
    TEXT[!MUST,implementation,test]:    verify that the selected NamedGroup in the ServerHello is the same as
    TEXT[!MUST,implementation,test]:    that in the HelloRetryRequest.
    TEXT[!MUST,implementation,test]: If this check fails, the client MUST
    TEXT[!MUST,implementation,test]:    abort the handshake with an "illegal_parameter" alert.

  SECTION: [Diffie-Hellman Parameters](#section-4.2.8.1)
    TEXT[!MUST]:    Peers MUST validate each other's public key Y by ensuring that 1 < Y
    TEXT[!MUST]:    < p-1.

  SECTION: [ECDHE Parameters](#section-4.2.8.2)
    TEXT[!MUST,implementation,test]:    For the curves secp256r1, secp384r1, and secp521r1, peers MUST
    TEXT[!MUST,implementation,test]:    validate each other's public value Q by ensuring that the point is a
    TEXT[!MUST,implementation,test]:    valid point on the elliptic curve.
    TEXT[test]:   The appropriate validation
    TEXT[test]:    procedures are defined in Section 4.3.7 of [ECDSA] and alternatively
    TEXT[test]:    in Section 5.6.2.3 of [KEYAGREEMENT].  This process consists of three
    TEXT[test]:    steps: (1) verify that Q is not the point at infinity (O), (2) verify
    TEXT[test]:    that for Q = (x, y) both integers x and y are in the correct
    TEXT[test]:    interval, and (3) ensure that (x, y) is a correct solution to the
    TEXT[test]:    elliptic curve equation.  For these curves, implementors do not need
    TEXT[test]:    to verify membership in the correct subgroup.

  SECTION: [Pre-Shared Key Exchange Modes](#section-4.2.9)
    TEXT[!MUST]:    In order to use PSKs, clients MUST also send a
    TEXT[!MUST]:    "psk_key_exchange_modes" extension.
    TEXT[!MUST]:    A client MUST provide a "psk_key_exchange_modes" extension if it
    TEXT[!MUST]:    offers a "pre_shared_key" extension.
    TEXT[!MUST,implementation]: If clients offer
    TEXT[!MUST,implementation]:    "pre_shared_key" without a "psk_key_exchange_modes" extension,
    TEXT[!MUST,implementation]:    servers MUST abort the handshake.
    TEXT[!MUST,implementation]: Servers MUST NOT select a key
    TEXT[!MUST,implementation]:    exchange mode that is not listed by the client.
    TEXT[implementation]:   This extension also
    TEXT[implementation]:    restricts the modes for use with PSK resumption.
    TEXT[!SHOULD]: Servers SHOULD NOT
    TEXT[!SHOULD]:    send NewSessionTicket with tickets that are not compatible with the
    TEXT[!SHOULD]:    advertised modes; however, if a server does so, the impact will just
    TEXT[!SHOULD]:    be that the client's attempts at resumption fail.
    TEXT[!MUST]:    The server MUST NOT send a "psk_key_exchange_modes" extension.
    TEXT[!MUST]: In this mode, the server
    TEXT[!MUST]:       MUST NOT supply a "key_share" value.
    TEXT[!MUST]: In this mode, the
    TEXT[!MUST]:       client and server MUST supply "key_share" values as described in
    TEXT[!MUST]:       Section 4.2.8.

  SECTION: [Early Data Indication](#section-4.2.10)
    TEXT[implementation,test]:    When a PSK is used and early data is allowed for that PSK, the client
    TEXT[implementation,test]:    can send Application Data in its first flight of messages.
    TEXT[!MUST,implementation,test]: If the
    TEXT[!MUST,implementation,test]:    client opts to do so, it MUST supply both the "pre_shared_key" and
    TEXT[!MUST,implementation,test]:    "early_data" extensions.
    TEXT[implementation]:    The "extension_data" field of this extension contains an
    TEXT[implementation]:    "EarlyDataIndication" value.
    TEXT[implementation]:       struct {} Empty;
    TEXT[implementation]:       struct {
    TEXT[implementation]:           select (Handshake.msg_type) {
    TEXT[implementation]:               case new_session_ticket:   uint32 max_early_data_size;
    TEXT[implementation]:               case client_hello:         Empty;
    TEXT[implementation]:               case encrypted_extensions: Empty;
    TEXT[implementation]:           };
    TEXT[implementation]:       } EarlyDataIndication;
    TEXT[!MUST]: The PSK used to encrypt the
    TEXT[!MUST]:    early data MUST be the first PSK listed in the client's
    TEXT[!MUST]:    "pre_shared_key" extension.
    TEXT[!MUST,implementation]:    For PSKs provisioned via NewSessionTicket, a server MUST validate
    TEXT[!MUST,implementation]:    that the ticket age for the selected PSK identity (computed by
    TEXT[!MUST,implementation]:    subtracting ticket_age_add from PskIdentity.obfuscated_ticket_age
    TEXT[!MUST,implementation]:    modulo 2^32) is within a small tolerance of the time since the ticket
    TEXT[!MUST,implementation]:    was issued (see Section 8).
    TEXT[!SHOULD]: If it is not, the server SHOULD proceed
    TEXT[!SHOULD]:    with the handshake but reject 0-RTT, and SHOULD NOT take any other
    TEXT[!SHOULD]:    action that assumes that this ClientHello is fresh.
    TEXT[!MUST,implementation,test]:    A server which receives an "early_data" extension MUST behave in one
    TEXT[!MUST,implementation,test]:    of three ways:
    TEXT[implementation]:    -  Ignore the extension and return a regular 1-RTT response.
    TEXT[implementation,test]:    -  Request that the client send another ClientHello by responding
    TEXT[implementation,test]:       with a HelloRetryRequest.
    TEXT[!MUST,implementation,test]: A client MUST NOT include the
    TEXT[!MUST,implementation,test]:       "early_data" extension in its followup ClientHello.
    TEXT[implementation,test]:    -  Return its own "early_data" extension in EncryptedExtensions,
    TEXT[implementation,test]:       indicating that it intends to process the early data.
    TEXT[!MUST,implementation,test]:    In order to accept early data, the server MUST have accepted a PSK
    TEXT[!MUST,implementation,test]:    cipher suite and selected the first key offered in the client's
    TEXT[!MUST,implementation,test]:    "pre_shared_key" extension.
    TEXT[!MUST,implementation,test]: In addition, it MUST verify that the
    TEXT[!MUST,implementation,test]:    following values are the same as those associated with the
    TEXT[!MUST,implementation,test]:    selected PSK:
    TEXT[implementation,test]:    -  The TLS version number
    TEXT[implementation,test]:    -  The selected cipher suite
    TEXT[implementation,test]:    -  The selected ALPN [RFC7301] protocol, if any
    TEXT[!MUST]:    Future extensions MUST define their interaction with 0-RTT.
    TEXT[!MUST,implementation]:    If any of these checks fail, the server MUST NOT respond with the
    TEXT[!MUST,implementation]:    extension
    TEXT[!MUST]:  and must discard all the first-flight data using one of the
    TEXT[!MUST]:    first two mechanisms listed above (thus falling back to 1-RTT or
    TEXT[!MUST]:    2-RTT).
    TEXT[implementation,test]: If the client attempts a 0-RTT handshake but the server
    TEXT[implementation,test]:    rejects it, the server will generally not have the 0-RTT record
    TEXT[implementation,test]:    protection keys and must instead use trial decryption (either with
    TEXT[implementation,test]:    the 1-RTT handshake keys or by looking for a cleartext ClientHello in
    TEXT[implementation,test]:    the case of a HelloRetryRequest) to find the first non-0-RTT message.
    TEXT[!MUST,implementation,test]:    If the server chooses to accept the "early_data" extension, then it
    TEXT[!MUST,implementation,test]:    MUST comply with the same error-handling requirements specified for
    TEXT[!MUST,implementation,test]:    all records when processing early data records.
    TEXT[!MUST,implementation,test]: Specifically, if the
    TEXT[!MUST,implementation,test]:    server fails to decrypt a 0-RTT record following an accepted
    TEXT[!MUST,implementation,test]:    "early_data" extension, it MUST terminate the connection with a
    TEXT[!MUST,implementation,test]:    "bad_record_mac" alert as per Section 5.2.
    TEXT[!MAY]:    If the server rejects the "early_data" extension, the client
    TEXT[!MAY]:    application MAY opt to retransmit the Application Data previously
    TEXT[!MAY]:    sent in early data once the handshake has been completed.
    TEXT[!SHOULD]:    A TLS implementation SHOULD NOT automatically resend early data;
    TEXT[!SHOULD]:    applications are in a better position to decide when retransmission
    TEXT[!SHOULD]:    is appropriate.
    TEXT[!MUST]: A TLS implementation MUST NOT automatically resend
    TEXT[!MUST]:    early data unless the negotiated connection selects the same ALPN
    TEXT[!MUST]:    protocol.

  SECTION: [Pre-Shared Key Extension](#section-4.2.11)
    TEXT[!MUST,implementation,test]: For identities
    TEXT[!MUST,implementation,test]:       established externally, an obfuscated_ticket_age of 0 SHOULD be
    TEXT[!MUST,implementation,test]:       used, and servers MUST ignore the value.
    TEXT[!MUST]:    For externally established PSKs, the Hash algorithm MUST be set when
    TEXT[!MUST,implementation,test]: The server MUST ensure that it selects a compatible PSK
    TEXT[!MUST,implementation,test]:    (if any) and cipher suite.
    TEXT[!SHOULD]: Clients, however, SHOULD
    TEXT[!SHOULD]:    store the SNI with the PSK to fulfill the requirements of
    TEXT[!SHOULD]:    Section 4.6.1.
    TEXT[!SHOULD]: Any unknown PSKs (e.g., ones
    TEXT[!SHOULD]:    not in the PSK database or encrypted with an unknown key) SHOULD
    TEXT[!SHOULD]:    simply be ignored.
    TEXT[!SHOULD,implementation]: If no acceptable PSKs are found, the server
    TEXT[!SHOULD,implementation]:    SHOULD perform a non-PSK handshake if possible.
    TEXT[!SHOULD]: If backward
    TEXT[!SHOULD]:    compatibility is important, client-provided, externally established
    TEXT[!SHOULD]:    PSKs SHOULD influence cipher suite selection.
    TEXT[!MUST,implementation]:    Prior to accepting PSK key establishment, the server MUST validate
    TEXT[!MUST,implementation]:    the corresponding binder value (see Section 4.2.11.2 below).
    TEXT[!MUST,implementation]: If this
    TEXT[!MUST,implementation]:    value is not present or does not validate, the server MUST abort the
    TEXT[!MUST,implementation]:    handshake.
    TEXT[!SHOULD]: Servers SHOULD NOT attempt to validate multiple binders;
    TEXT[!SHOULD]:    rather, they SHOULD select a single PSK and validate solely the
    TEXT[!SHOULD]:    binder that corresponds to that PSK.
    TEXT[!MUST]:    Clients MUST verify that the server's selected_identity is within the
    TEXT[!MUST]:    range supplied by the client,
    TEXT[!MUST,implementation,test]: that the server selected a cipher suite
    TEXT[!MUST,implementation,test]:    indicating a Hash associated with the PSK
    TEXT[!MUST]: , and that a server
    TEXT[!MUST]:    "key_share" extension is present if required by the ClientHello
    TEXT[!MUST]:    "psk_key_exchange_modes" extension.
    TEXT[!MUST]: If these values are not
    TEXT[!MUST]:    consistent, the client MUST abort the handshake with an
    TEXT[!MUST]:    "illegal_parameter" alert.
    TEXT[!MUST]:    If the server supplies an "early_data" extension, the client MUST
    TEXT[!MUST]:    verify that the server's selected_identity is 0.
    TEXT[!MUST]: If any other value
    TEXT[!MUST]:    is returned, the client MUST abort the handshake with an
    TEXT[!MUST]:    "illegal_parameter" alert.
    TEXT[!MUST,implementation]:    The "pre_shared_key" extension MUST be the last extension in the
    TEXT[!MUST,implementation]:    ClientHello (this facilitates implementation as described below).
    TEXT[!MUST,implementation]:    Servers MUST check that it is the last extension and otherwise fail
    TEXT[!MUST,implementation]:    the handshake with an "illegal_parameter" alert.

  SECTION: [Ticket Age](#section-4.2.11.1)
    TEXT[!MUST]: Clients MUST NOT attempt to
    TEXT[!MUST]:    use tickets which have ages greater than the "ticket_lifetime" value
    TEXT[!MUST]:    which was provided with the ticket.
    TEXT[implementation]: The "obfuscated_ticket_age"
    TEXT[implementation]:    field of each PskIdentity contains an obfuscated version of the
    TEXT[implementation]:    ticket age formed by taking the age in milliseconds and adding the
    TEXT[implementation]:    "ticket_age_add" value that was included with the ticket (see
    TEXT[implementation]:    Section 4.6.1), modulo 2^32.

  SECTION: [Processing Order](#section-4.2.11.3)
    TEXT[!MUST]: In order to avoid deadlocks,
    TEXT[!MUST]:    when accepting "early_data", servers MUST process the client's
    TEXT[!MUST]:    ClientHello and then immediately send their flight of messages,
    TEXT[!MUST]:    rather than waiting for the client's EndOfEarlyData message before
    TEXT[!MUST]:    sending its ServerHello.

  SECTION: [Encrypted Extensions](#section-4.3.1)
    TEXT[!MUST]:    In all handshakes, the server MUST send the EncryptedExtensions
    TEXT[!MUST]:    message immediately after the ServerHello message.
    TEXT[!MUST]: The client MUST check EncryptedExtensions for the
    TEXT[!MUST]:    presence of any forbidden extensions and if any are found MUST abort
    TEXT[!MUST]:    the handshake with an "illegal_parameter" alert.

  SECTION: [Certificate Request](#section-4.3.2)
    TEXT[!MAY]:    A server which is authenticating with a certificate MAY optionally
    TEXT[!MAY]:    request a certificate from the client.
    TEXT[!MUST]: This message, if sent, MUST
    TEXT[!MUST]:    follow EncryptedExtensions.
    TEXT[!MUST]: The certificate_request_context MUST be
    TEXT[!MUST]:       unique within the scope of this connection (thus preventing replay
    TEXT[!MUST]:       of client CertificateVerify messages).
    TEXT[!MUST]: This field SHALL be zero
    TEXT[!MUST]:       length unless used for the post-handshake authentication exchanges
    TEXT[!MUST]:       described in Section 4.6.2.
    TEXT[!SHOULD]: When requesting post-handshake
    TEXT[!SHOULD]:       authentication, the server SHOULD make the context unpredictable
    TEXT[!SHOULD]:       to the client (e.g., by randomly generating it) in order to
    TEXT[!SHOULD]:       prevent an attacker who has temporary access to the client's
    TEXT[!SHOULD]:       private key from pre-computing valid CertificateVerify messages.
    TEXT[!MUST]: The "signature_algorithms" extension
    TEXT[!MUST]:       MUST be specified, and other extensions may optionally be included
    TEXT[!MUST]:       if defined for this message.
    TEXT[!MUST]: Clients MUST ignore unrecognized
    TEXT[!MUST]:       extensions.
    TEXT[!MUST]:    Servers which are authenticating with a PSK MUST NOT send the
    TEXT[!MUST]:    CertificateRequest message in the main handshake, though they MAY
    TEXT[!MUST]:    send it in post-handshake authentication (see Section 4.6.2) provided
    TEXT[!MUST]:    that the client has sent the "post_handshake_auth" extension (see
    TEXT[!MUST]:    Section 4.2.6).

  SECTION: [Certificate](#section-4.4.2)
    TEXT[!MUST]:    The server MUST send a Certificate message whenever the agreed-upon
    TEXT[!MUST]:    key exchange method uses certificates for authentication (this
    TEXT[!MUST]:    includes all key exchange methods defined in this document
    TEXT[!MUST]:    except PSK).
    TEXT[!MUST]:    The client MUST send a Certificate message if and only if the server
    TEXT[!MUST]:    has requested client authentication via a CertificateRequest message
    TEXT[!MUST]:    (Section 4.3.2).
    TEXT[!MUST]: If the server requests client authentication but no
    TEXT[!MUST]:    suitable certificate is available, the client MUST send a Certificate
    TEXT[!MUST]:    message containing no certificates (i.e., with the "certificate_list"
    TEXT[!MUST]:    field having length 0).
    TEXT[!MUST]: A Finished message MUST be sent regardless
    TEXT[!MUST]:    of whether the Certificate message is empty.
    TEXT[!MUST]: Otherwise (in the case of server authentication),
    TEXT[!MUST]:       this field SHALL be zero length.
    TEXT[!MUST]: Extensions in the Certificate message from the server MUST
    TEXT[!MUST]:       correspond to ones from the ClientHello message.
    TEXT[!MUST]: Extensions in
    TEXT[!MUST]:       the Certificate message from the client MUST correspond to
    TEXT[!MUST]:       extensions in the CertificateRequest message from the server.
    TEXT[!SHOULD,implementation]: If
    TEXT[!SHOULD,implementation]:       an extension applies to the entire chain, it SHOULD be included in
    TEXT[!SHOULD,implementation]:       the first CertificateEntry.
    TEXT[!MUST]: The sender's certificate MUST come in the first
    TEXT[!MUST]:    CertificateEntry in the list.
    TEXT[!SHOULD]: Each following certificate SHOULD
    TEXT[!SHOULD]:    directly certify the one immediately preceding it.
    TEXT[!MAY]: Because
    TEXT[!MAY]:    certificate validation requires that trust anchors be distributed
    TEXT[!MAY]:    independently, a certificate that specifies a trust anchor MAY be
    TEXT[!MAY]:    omitted from the chain, provided that supported peers are known to
    TEXT[!MAY]:    possess any omitted certificates.
    TEXT[!MUST]: For maximum
    TEXT[!MUST]:    compatibility, all implementations SHOULD be prepared to handle
    TEXT[!MUST]:    potentially extraneous certificates and arbitrary orderings from any
    TEXT[!MUST]:    TLS version, with the exception of the end-entity certificate which
    TEXT[!MUST]:    MUST be first.
    TEXT[!MUST]:    If the RawPublicKey certificate type was negotiated, then the
    TEXT[!MUST]:    certificate_list MUST contain no more than one CertificateEntry,
    TEXT[!MUST]:    which contains an ASN1_subjectPublicKeyInfo value as defined in
    TEXT[!MUST]:    [RFC7250], Section 3.
    TEXT[!MUST]:    The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.
    TEXT[!MUST]:    The server's certificate_list MUST always be non-empty.

  SECTION: [OCSP Status and SCT Extensions](#section-4.4.2.1)
    TEXT[!MUST]: Specifically, the body of the
    TEXT[!MUST]:    "status_request" extension from the server MUST be a
    TEXT[!MUST]:    CertificateStatus structure as defined in [RFC6066], which is
    TEXT[!MUST]:    interpreted as defined in [RFC6960].
    TEXT[!MUST]:    TLS 1.3 servers MUST NOT act upon its presence or information in it
    TEXT[!MUST]:    when processing ClientHello messages; in particular, they MUST NOT
    TEXT[!MUST]:    send the status_request_v2 extension in the EncryptedExtensions,
    TEXT[!MUST]:    CertificateRequest, or Certificate messages.
    TEXT[!MUST]: TLS 1.3 servers MUST be
    TEXT[!MUST]:    able to process ClientHello messages that include it, as it MAY be
    TEXT[!MUST]:    sent by clients that wish to use it in earlier protocol versions.
    TEXT[!MAY,implementation]:    A server MAY request that a client present an OCSP response with its
    TEXT[!MAY,implementation]:    certificate by sending an empty "status_request" extension in its
    TEXT[!MAY,implementation]:    CertificateRequest message.
    TEXT[!MUST]: If the client opts to send an OCSP
    TEXT[!MUST]:    response, the body of its "status_request" extension MUST be a
    TEXT[!MUST]:    CertificateStatus structure as defined in [RFC6066].

  SECTION: [Server Certificate Selection](#section-4.4.2.2)
    TEXT[!MUST]:    -  The certificate type MUST be X.509v3 [RFC5280], unless explicitly
    TEXT[!MUST]:       negotiated otherwise (e.g., [RFC7250]).
    TEXT[!MUST]:    -  The server's end-entity certificate's public key (and associated
    TEXT[!MUST]:       restrictions) MUST be compatible with the selected authentication
    TEXT[!MUST]:       algorithm from the client's "signature_algorithms" extension
    TEXT[!MUST]:       (currently RSA, ECDSA, or EdDSA).
    TEXT[!MUST]:    -  The certificate MUST allow the key to be used for signing (i.e.,
    TEXT[!MUST]:       the digitalSignature bit MUST be set if the Key Usage extension is
    TEXT[!MUST]:       present) with a signature scheme indicated in the client's
    TEXT[!MUST]:       "signature_algorithms"/"signature_algorithms_cert" extensions (see
    TEXT[!MUST]:       Section 4.2.3).
    TEXT[!SHOULD]: As servers
    TEXT[!SHOULD]:       MAY require the presence of the "server_name" extension, clients
    TEXT[!SHOULD]:       SHOULD send this extension, when applicable.
    TEXT[!MUST]:    All certificates provided by the server MUST be signed by a signature
    TEXT[!MUST]:    algorithm advertised by the client if it is able to provide such a
    TEXT[!MUST]:    chain (see Section 4.2.3).
    TEXT[!MAY]: Certificates that are self-signed or
    TEXT[!MAY]:    certificates that are expected to be trust anchors are not validated
    TEXT[!MAY]:    as part of the chain and therefore MAY be signed with any algorithm.
    TEXT[!SHOULD]:    If the server cannot produce a certificate chain that is signed only
    TEXT[!SHOULD]:    via the indicated supported algorithms, then it SHOULD continue the
    TEXT[!SHOULD]:    handshake by sending the client a certificate chain of its choice
    TEXT[!SHOULD]:    that may include algorithms that are not known to be supported by the
    TEXT[!SHOULD]:    client.
    TEXT[!MUST]: This fallback chain SHOULD NOT use the deprecated SHA-1 hash
    TEXT[!MUST]:    algorithm in general, but MAY do so if the client's advertisement
    TEXT[!MUST]:    permits it, and MUST NOT do so otherwise.
    TEXT[!MUST]:    If the client cannot construct an acceptable chain using the provided
    TEXT[!MUST]:    certificates and decides to abort the handshake, then it MUST abort
    TEXT[!MUST]:    the handshake with an appropriate certificate-related alert (by
    TEXT[!MUST]:    default, "unsupported_certificate"; see Section 6.2 for more
    TEXT[!MUST]:    information).

  SECTION: [Client Certificate Selection](#section-4.4.2.3)
    TEXT[!MUST]:    -  The certificate type MUST be X.509v3 [RFC5280], unless explicitly
    TEXT[!MUST]:       negotiated otherwise (e.g., [RFC7250]).
    TEXT[!SHOULD]:    -  If the "certificate_authorities" extension in the
    TEXT[!SHOULD]:       CertificateRequest message was present, at least one of the
    TEXT[!SHOULD]:       certificates in the certificate chain SHOULD be issued by one of
    TEXT[!SHOULD]:       the listed CAs.
    TEXT[!MUST]:    -  The certificates MUST be signed using an acceptable signature
    TEXT[!MUST]:       algorithm, as described in Section 4.3.2.
    TEXT[!MUST]:    -  If the CertificateRequest message contained a non-empty
    TEXT[!MUST]:       "oid_filters" extension, the end-entity certificate MUST match the
    TEXT[!MUST]:       extension OIDs that are recognized by the client, as described in
    TEXT[!MUST]:       Section 4.2.5.

  SECTION: [Receiving a Certificate Message](#section-4.4.2.4)
    TEXT[!MUST]:    If the server supplies an empty Certificate message, the client MUST
    TEXT[!MUST]:    abort the handshake with a "decode_error" alert.
    TEXT[!MAY]:    If the client does not send any certificates (i.e., it sends an empty
    TEXT[!MAY]:    Certificate message), the server MAY at its discretion either
    TEXT[!MAY]:    continue the handshake without client authentication or abort the
    TEXT[!MAY]:    handshake with a "certificate_required" alert.
    TEXT[!MAY]: Also, if some aspect
    TEXT[!MAY]:    of the certificate chain was unacceptable (e.g., it was not signed by
    TEXT[!MAY]:    a known, trusted CA), the server MAY at its discretion either
    TEXT[!MAY]:    continue the handshake (considering the client unauthenticated) or
    TEXT[!MAY]:    abort the handshake.
    TEXT[!MUST]:    Any endpoint receiving any certificate which it would need to
    TEXT[!MUST]:    validate using any signature algorithm using an MD5 hash MUST abort
    TEXT[!MUST]:    the handshake with a "bad_certificate" alert.
    TEXT[!SHOULD]: SHA-1 is deprecated,
    TEXT[!SHOULD]:    and it is RECOMMENDED that any endpoint receiving any certificate
    TEXT[!SHOULD]:    which it would need to validate using any signature algorithm using a
    TEXT[!SHOULD]:    SHA-1 hash abort the handshake with a "bad_certificate" alert.
    TEXT[!SHOULD]:    All endpoints are RECOMMENDED to transition to SHA-256 or better as
    TEXT[!SHOULD]:    soon as possible to maintain interoperability with implementations
    TEXT[!SHOULD]:    currently in the process of phasing out SHA-1 support.
    TEXT[!MAY]:    Note that a certificate containing a key for one signature algorithm
    TEXT[!MAY]:    MAY be signed using a different signature algorithm (for instance, an
    TEXT[!MAY]:    RSA key signed with an ECDSA key).

  SECTION: [Certificate Verify](#section-4.4.3)
    TEXT[!MUST]: Servers MUST send this message when authenticating
    TEXT[!MUST]:    via a certificate.
    TEXT[!MUST]: Clients MUST send this message whenever
    TEXT[!MUST]:    authenticating via a certificate (i.e., when the Certificate message
    TEXT[!MUST]:    is non-empty).
    TEXT[!MUST]: When sent, this message MUST appear immediately after
    TEXT[!MUST]:    the Certificate message and immediately prior to the Finished
    TEXT[!MUST]:    message.
    TEXT[!MUST,implementation]:    If the CertificateVerify message is sent by a server, the signature
    TEXT[!MUST,implementation]:    algorithm MUST be one offered in the client's "signature_algorithms"
    TEXT[!MUST,implementation]:    extension unless no valid certificate chain can be produced without
    TEXT[!MUST,implementation]:    unsupported algorithms
    TEXT[!MUST]:  (see Section 4.2.3).
    TEXT[!MUST,exception]:    If sent by a client, the signature algorithm used in the signature
    TEXT[!MUST,exception]:    MUST be one of those present in the supported_signature_algorithms
    TEXT[!MUST,exception]:    field of the "signature_algorithms" extension in the
    TEXT[!MUST,exception]:    CertificateRequest message.
    TEXT[!MUST]:    In addition, the signature algorithm MUST be compatible with the key
    TEXT[!MUST]:    in the sender's end-entity certificate.
    TEXT[!MUST]: RSA signatures MUST use an
    TEXT[!MUST]:    RSASSA-PSS algorithm, regardless of whether RSASSA-PKCS1-v1_5
    TEXT[!MUST]:    algorithms appear in "signature_algorithms".
    TEXT[!MUST]: The SHA-1 algorithm
    TEXT[!MUST]:    MUST NOT be used in any signatures of CertificateVerify messages.
    TEXT[!MUST]:    The receiver of a CertificateVerify message MUST verify the signature
    TEXT[!MUST]:    field.
    TEXT[!MUST]:    If the verification fails, the receiver MUST terminate the handshake
    TEXT[!MUST]:    with a "decrypt_error" alert.

  SECTION: [Finished](#section-4.4.4)
    TEXT[!MUST]:    Recipients of Finished messages MUST verify that the contents are
    TEXT[!MUST]:    correct and if incorrect MUST terminate the connection with a
    TEXT[!MUST]:    "decrypt_error" alert.
    TEXT[!MAY]: Servers MAY send data after sending their first flight, but
    TEXT[!MAY]:        because the handshake is not yet complete, they have no assurance
    TEXT[!MAY]:        of either the peer's identity or its liveness (i.e., the
    TEXT[!MAY]:        ClientHello might have been replayed).
    TEXT[implementation]:    The key used to compute the Finished message is computed from the
    TEXT[implementation]:    Base Key defined in Section 4.4 using HKDF (see Section 7.1).
    TEXT[implementation]:    Specifically:
    TEXT[implementation]:    finished_key =
    TEXT[implementation]:        HKDF-Expand-Label(BaseKey, "finished", "", Hash.length)
    TEXT[!MUST]:    Any records following a Finished message MUST be encrypted under the
    TEXT[!MUST]:    appropriate application traffic key as described in Section 7.2.

  SECTION: [End of Early Data](#section-4.5)
    TEXT[!MUST]:    If the server sent an "early_data" extension in EncryptedExtensions,
    TEXT[!MUST]:    the client MUST send an EndOfEarlyData message after receiving the
    TEXT[!MUST]:    server Finished.
    TEXT[!MUST]: If the server does not send an "early_data"
    TEXT[!MUST]:    extension in EncryptedExtensions, then the client MUST NOT send an
    TEXT[!MUST]:    EndOfEarlyData message.
    TEXT[!MUST]:    Servers MUST NOT send this message, and clients receiving it MUST
    TEXT[!MUST]:    terminate the connection with an "unexpected_message" alert.

  SECTION: [New Session Ticket Message](#section-4.6.1)
    TEXT[!MAY]:    At any time after the server has received the client Finished
    TEXT[!MAY]:    message, it MAY send a NewSessionTicket message.
    TEXT[!MAY]:    The client MAY use this PSK for future handshakes by including the
    TEXT[!MAY]:    ticket value in the "pre_shared_key" extension in its ClientHello
    TEXT[!MAY]:    (Section 4.2.11).
    TEXT[!MAY]: Servers MAY send multiple tickets on a single
    TEXT[!MAY]:    connection, either immediately after each other or after specific
    TEXT[!MAY]:    events (see Appendix C.4).
    TEXT[!MUST]:    Any ticket MUST only be resumed with a cipher suite that has the same
    TEXT[!MUST]:    KDF hash algorithm as that used to establish the original connection.
    TEXT[!MUST]:    Clients MUST only resume if the new SNI value is valid for the server
    TEXT[!MUST]:    certificate presented in the original session and SHOULD only resume
    TEXT[!MUST]:    if the SNI value matches the one used in the original session.
    TEXT[!MAY]: If such an indication
    TEXT[!MAY]:    is provided (externally or by any other means), clients MAY resume
    TEXT[!MAY]:    with a different SNI value.
    TEXT[!MUST]:    On resumption, if reporting an SNI value to the calling application,
    TEXT[!MUST]:    implementations MUST use the value sent in the resumption ClientHello
    TEXT[!MUST]:    rather than the value sent in the previous session.
    TEXT[!MAY]:    Note: Although the resumption master secret depends on the client's
    TEXT[!MAY]:    second flight, a server which does not request client authentication
    TEXT[!MAY]:    MAY compute the remainder of the transcript independently and then
    TEXT[!MAY]:    send a NewSessionTicket immediately upon sending its Finished rather
    TEXT[!MAY]:    than waiting for the client Finished.
    TEXT[implementation]:       struct {
    TEXT[implementation]:           uint32 ticket_lifetime;
    TEXT[implementation]:           uint32 ticket_age_add;
    TEXT[implementation]:           opaque ticket_nonce<0..255>;
    TEXT[implementation]:           opaque ticket<1..2^16-1>;
    TEXT[implementation]:           Extension extensions<0..2^16-2>;
    TEXT[implementation]:       } NewSessionTicket;
    TEXT[implementation]: Indicates the lifetime in seconds as a 32-bit
    TEXT[implementation]:       unsigned integer in network byte order from the time of ticket
    TEXT[implementation]:       issuance.
    TEXT[!MUST,implementation,test]: Servers MUST NOT use any value greater than
    TEXT[!MUST,implementation,test]:       604800 seconds (7 days).
    TEXT[implementation,test]: The value of zero indicates that the
    TEXT[implementation,test]:       ticket should be discarded immediately.
    TEXT[!MUST,implementation,test]: Clients MUST NOT cache
    TEXT[!MUST,implementation,test]:       tickets for longer than 7 days, regardless of the ticket_lifetime,
    TEXT[!MUST,implementation,test]:       and MAY delete tickets earlier based on local policy.
    TEXT[!MAY]: A server
    TEXT[!MAY]:       MAY treat a ticket as valid for a shorter period of time than what
    TEXT[!MAY]:       is stated in the ticket_lifetime.
    TEXT[implementation]: A securely generated, random 32-bit value that is
    TEXT[implementation]:       used to obscure the age of the ticket that the client includes in
    TEXT[implementation]:       the "pre_shared_key" extension.
    TEXT[!MUST,implementation,test]: The server MUST generate a fresh value
    TEXT[!MUST,implementation,test]:       for each ticket it sends.
    TEXT[implementation]: A per-ticket value that is unique across all tickets
    TEXT[implementation]:       issued on this connection.
    TEXT[!MAY]: It MAY be either a database
    TEXT[!MAY]:       lookup key or a self-encrypted and self-authenticated value.
    TEXT[!MUST]: Clients MUST ignore
    TEXT[!MUST]:       unrecognized extensions.
    TEXT[!SHOULD]: A server receiving more than
    TEXT[!SHOULD]:       max_early_data_size bytes of 0-RTT data SHOULD terminate the
    TEXT[!SHOULD]:       connection with an "unexpected_message" alert.
    TEXT[!SHOULD]: Note that servers
    TEXT[!SHOULD]:       that reject early data due to lack of cryptographic material will
    TEXT[!SHOULD]:       be unable to differentiate padding from content, so clients
    TEXT[!SHOULD]:       SHOULD NOT depend on being able to send large quantities of
    TEXT[!SHOULD]:       padding in early data records.
    TEXT[implementation]:    The PSK associated with the ticket is computed as:
    TEXT[implementation]:        HKDF-Expand-Label(resumption_master_secret,
    TEXT[implementation]:                         "resumption", ticket_nonce, Hash.length)
    TEXT[implementation,test]:    Note that in principle it is possible to continue issuing new tickets
    TEXT[implementation,test]:    which indefinitely extend the lifetime of the keying material
    TEXT[implementation,test]:    originally derived from an initial non-PSK handshake (which was most
    TEXT[implementation,test]:    likely tied to the peer's certificate).
    TEXT[!SHOULD,implementation,test]: It is RECOMMENDED that
    TEXT[!SHOULD,implementation,test]:    implementations place limits on the total lifetime of such keying
    TEXT[!SHOULD,implementation,test]:    material; these limits should take into account the lifetime of the
    TEXT[!SHOULD,implementation,test]:    peer's certificate, the likelihood of intervening revocation, and the
    TEXT[!SHOULD,implementation,test]:    time since the peer's online CertificateVerify signature.

  SECTION: [Post-Handshake Authentication](#section-4.6.2)
    TEXT[!MAY]:    When the client has sent the "post_handshake_auth" extension (see
    TEXT[!MAY]:    Section 4.2.6), a server MAY request client authentication at any
    TEXT[!MAY]:    time after the handshake has completed by sending a
    TEXT[!MAY]:    CertificateRequest message.
    TEXT[!MUST]: The client MUST respond with the
    TEXT[!MUST]:    appropriate Authentication messages (see Section 4.4).
    TEXT[!MUST]: If the client
    TEXT[!MUST]:    chooses to authenticate, it MUST send Certificate, CertificateVerify,
    TEXT[!MUST]: If it declines, it MUST send a Certificate message
    TEXT[!MUST]:    containing no certificates followed by Finished.
    TEXT[!MUST]: All of the client's
    TEXT[!MUST]:    messages for a given response MUST appear consecutively on the wire
    TEXT[!MUST]:    with no intervening messages of other types.
    TEXT[!MUST,implementation]:    A client that receives a CertificateRequest message without having
    TEXT[!MUST,implementation]:    sent the "post_handshake_auth" extension MUST send an
    TEXT[!MUST,implementation]:    "unexpected_message" fatal alert.
    TEXT[!MUST]:    Note: Because client authentication could involve prompting the user,
    TEXT[!MUST]:    servers MUST be prepared for some delay, including receiving an
    TEXT[!MUST]:    arbitrary number of other messages between sending the
    TEXT[!MUST]:    CertificateRequest and receiving a response.
    TEXT[!MAY]: In addition, clients
    TEXT[!MAY]:    which receive multiple CertificateRequests in close succession MAY
    TEXT[!MAY]:    respond to them in a different order than they were received (the
    TEXT[!MAY]:    certificate_request_context value allows the server to disambiguate
    TEXT[!MAY]:    the responses).

  SECTION: [Key and Initialization Vector Update](#section-4.6.3)
    TEXT[!MUST]: Implementations
    TEXT[!MUST]:    that receive a KeyUpdate message prior to receiving a Finished
    TEXT[!MUST]:    message MUST terminate the connection with an "unexpected_message"
    TEXT[!MUST]:    alert.
    TEXT[!MUST]: After sending a KeyUpdate message, the sender SHALL send all
    TEXT[!MUST]:    its traffic using the next generation of keys, computed as described
    TEXT[!MUST]:    in Section 7.2.
    TEXT[!MUST]: Upon receiving a KeyUpdate, the receiver MUST update
    TEXT[!MUST]:    its receiving keys.
    TEXT[!MUST]: If an implementation
    TEXT[!MUST]:       receives any other value, it MUST terminate the connection with an
    TEXT[!MUST]:       "illegal_parameter" alert.
    TEXT[!MUST]:    If the request_update field is set to "update_requested", then the
    TEXT[!MUST]:    receiver MUST send a KeyUpdate of its own with request_update set to
    TEXT[!MUST]:    "update_not_requested" prior to sending its next Application Data
    TEXT[!MUST]:    record.
    TEXT[!MUST]:    Both sender and receiver MUST encrypt their KeyUpdate messages with
    TEXT[!MUST]:    the old keys.
    TEXT[!MUST]: Additionally, both sides MUST enforce that a KeyUpdate
    TEXT[!MUST]:    with the old key is received before accepting any messages encrypted
    TEXT[!MUST]:    with the new key.

  SECTION: [Record Protocol](#section-5)
    TEXT[!MUST]:    An implementation may receive an unencrypted record of type
    TEXT[!MUST]:    change_cipher_spec consisting of the single byte value 0x01 at any
    TEXT[!MUST]:    time after the first ClientHello message has been sent or received
    TEXT[!MUST]:    and before the peer's Finished message has been received and MUST
    TEXT[!MUST]:    simply drop it without further processing.
    TEXT[!MUST]: An
    TEXT[!MUST]:    implementation which receives any other change_cipher_spec value or
    TEXT[!MUST]:    which receives a protected change_cipher_spec record MUST abort the
    TEXT[!MUST]:    handshake with an "unexpected_message" alert.
    TEXT[!MUST]: If an implementation
    TEXT[!MUST]:    detects a change_cipher_spec record received before the first
    TEXT[!MUST]:    ClientHello message or after the peer's Finished message, it MUST be
    TEXT[!MUST]:    treated as an unexpected record type (though stateless servers may
    TEXT[!MUST]:    not be able to distinguish these cases from allowed cases).
    TEXT[!MUST]:    Implementations MUST NOT send record types not defined in this
    TEXT[!MUST]:    document unless negotiated by some extension.
    TEXT[!MUST]: If a TLS
    TEXT[!MUST]:    implementation receives an unexpected record type, it MUST terminate
    TEXT[!MUST]:    the connection with an "unexpected_message" alert.

  SECTION: [Record Layer](#section-5.1)
    TEXT[implementation]:    The record layer fragments information blocks into TLSPlaintext
    TEXT[implementation]:    records carrying data in chunks of 2^14 bytes or less.
    TEXT[!MUST]: Any future content types MUST specify appropriate
    TEXT[!MUST]:    rules.
    TEXT[!MAY]:    Handshake messages MAY be coalesced into a single TLSPlaintext record
    TEXT[!MAY]:    or fragmented across several records, provided that:
    TEXT[!MUST,implementation,test]:    -  Handshake messages MUST NOT be interleaved with other record
    TEXT[!MUST,implementation,test]:       types.
    TEXT[!MUST,implementation,test]: That is, if a handshake message is split over two or more
    TEXT[!MUST,implementation,test]:       records, there MUST NOT be any other records between them.
    TEXT[!MUST]:    -  Handshake messages MUST NOT span key changes.
    TEXT[!MUST]: Implementations
    TEXT[!MUST]:       MUST verify that all messages immediately preceding a key change
    TEXT[!MUST]:       align with a record boundary; if not, then they MUST terminate the
    TEXT[!MUST]:       connection with an "unexpected_message" alert.
    TEXT[!MUST]: Because the
    TEXT[!MUST]:       ClientHello, EndOfEarlyData, ServerHello, Finished, and KeyUpdate
    TEXT[!MUST]:       messages can immediately precede a key change, implementations
    TEXT[!MUST]:       MUST send these messages in alignment with a record boundary.
    TEXT[!MUST]:    Implementations MUST NOT send zero-length fragments of Handshake
    TEXT[!MUST]:    types, even if those fragments contain padding.
    TEXT[!MUST]:    Alert messages (Section 6) MUST NOT be fragmented across records, and
    TEXT[!MUST]:    multiple alert messages MUST NOT be coalesced into a single
    TEXT[!MUST]:    TLSPlaintext record.
    TEXT[!MUST]: In other words, a record with an Alert type
    TEXT[!MUST]:    MUST contain exactly one message.
    TEXT[!MAY]: Zero-length
    TEXT[!MAY]:    fragments of Application Data MAY be sent, as they are potentially
    TEXT[!MAY]:    useful as a traffic analysis countermeasure.
    TEXT[!MAY]: Application Data
    TEXT[!MAY]:    fragments MAY be split across multiple records or coalesced into a
    TEXT[!MAY]:    single record.
    TEXT[!MUST,implementation]:    legacy_record_version:  MUST be set to 0x0303 for all records
    TEXT[!MUST,implementation]:       generated by a TLS 1.3 implementation other than an initial
    TEXT[!MUST,implementation]:       ClientHello (i.e., one not generated after a HelloRetryRequest),
    TEXT[!MUST,implementation]:       where it MAY also be 0x0301 for compatibility purposes.
    TEXT[!MUST]: This
    TEXT[!MUST]:       field is deprecated and MUST be ignored for all purposes.
    TEXT[!MUST,exception]: The length MUST NOT exceed 2^14 bytes.
    TEXT[!MUST,exception]: An
    TEXT[!MUST,exception]:       endpoint that receives a record that exceeds this length MUST
    TEXT[!MUST,exception]:       terminate the connection with a "record_overflow" alert.
    TEXT[implementation]: This
    TEXT[implementation]:    version value is historical, deriving from the use of 0x0301 for
    TEXT[implementation]:    TLS 1.0 and 0x0300 for SSL 3.0.
    TEXT[!MUST,implementation]: In order to maximize backward
    TEXT[!MUST,implementation]:    compatibility, a record containing an initial ClientHello SHOULD have
    TEXT[!MUST,implementation]:    version 0x0301 (reflecting TLS 1.0)
    TEXT[!MUST]:  and a record containing a second
    TEXT[!MUST]:    ClientHello or a ServerHello MUST have version 0x0303 (reflecting
    TEXT[!MUST]:    TLS 1.2).
    TEXT[!MUST]: Note that Application Data
    TEXT[!MUST]:    records MUST NOT be written to the wire unprotected (see Section 2
    TEXT[!MUST]:    for details).

  SECTION: [Record Payload Protection](#section-5.2)
    TEXT[implementation]:    opaque_type:  The outer opaque_type field of a TLSCiphertext record
    TEXT[implementation]:       is always set to the value 23 (application_data) for outward
    TEXT[implementation]:       compatibility with middleboxes accustomed to parsing previous
    TEXT[implementation]:       versions of TLS.  The actual content type of the record is found
    TEXT[implementation]:       in TLSInnerPlaintext.type after decryption.
    TEXT[implementation]:    legacy_record_version:  The legacy_record_version field is always
    TEXT[implementation]:       0x0303.  TLS 1.3 TLSCiphertexts are not generated until after
    TEXT[implementation]:       TLS 1.3 has been negotiated, so there are no historical
    TEXT[implementation]:       compatibility concerns where other values might be received.  Note
    TEXT[implementation]:       that the handshake protocol, including the ClientHello and
    TEXT[implementation]:       ServerHello messages, authenticates the protocol version, so this
    TEXT[implementation]:       value is redundant.
    TEXT[implementation]:    length:  The length (in bytes) of the following
    TEXT[implementation]:       TLSCiphertext.encrypted_record, which is the sum of the lengths of
    TEXT[implementation]:       the content and the padding, plus one for the inner content type,
    TEXT[implementation]:       plus any expansion added by the AEAD algorithm.
    TEXT[!MUST,implementation]: The length
    TEXT[!MUST,implementation]:       MUST NOT exceed 2^14 + 256 bytes.
    TEXT[!MUST,implementation]: An endpoint that receives a
    TEXT[!MUST,implementation]:       record that exceeds this length MUST terminate the connection with
    TEXT[!MUST,implementation]:       a "record_overflow" alert.
    TEXT[!MUST]:    If the decryption fails, the receiver MUST terminate the connection
    TEXT[!MUST]:    with a "bad_record_mac" alert.
    TEXT[!MUST,implementation]:    An AEAD algorithm used in TLS 1.3 MUST NOT produce an expansion
    TEXT[!MUST,implementation]:    greater than 255 octets.
    TEXT[!MUST]: An endpoint that receives a record from its
    TEXT[!MUST]:    peer with TLSCiphertext.length larger than 2^14 + 256 octets MUST
    TEXT[!MUST]:    terminate the connection with a "record_overflow" alert.

  SECTION: [Per-Record Nonce](#section-5.3)
    TEXT[!MUST,implementation]: Each sequence number is
    TEXT[!MUST,implementation]:    set to zero at the beginning of a connection and whenever the key is
    TEXT[!MUST,implementation]:    changed; the first record transmitted under a particular traffic key
    TEXT[!MUST,implementation]:    MUST use sequence number 0.
    TEXT[!MUST]:    If a TLS implementation would need to wrap a sequence number, it MUST
    TEXT[!MUST]:    either rekey (Section 4.6.3) or terminate the connection.
    TEXT[!MUST]: An AEAD algorithm where N_MAX is less than 8 bytes
    TEXT[!MUST]:    MUST NOT be used with TLS.

  SECTION: [Record Padding](#section-5.4)
    TEXT[!MAY]:    When generating a TLSCiphertext record, implementations MAY choose to
    TEXT[!MAY]:    pad.
    TEXT[!MUST]: Implementations MUST set the
    TEXT[!MUST]:    padding octets to all zeros before encrypting.
    TEXT[test]:    Application Data records may contain a zero-length
    TEXT[test]:    TLSInnerPlaintext.content if the sender desires.
    TEXT[!MUST,test]: Implementations
    TEXT[!MUST,test]:    MUST NOT send Handshake and Alert records that have a zero-length
    TEXT[!MUST,test]:    TLSInnerPlaintext.content; if such a message is received, the
    TEXT[!MUST,test]:    receiving implementation MUST terminate the connection with an
    TEXT[!MUST,test]:    "unexpected_message" alert.
    TEXT[!MUST]:    Implementations MUST limit their scanning to the cleartext returned
    TEXT[!MUST]:    from the AEAD decryption.
    TEXT[!MUST,test]: If a receiving implementation does not
    TEXT[!MUST,test]:    find a non-zero octet in the cleartext, it MUST terminate the
    TEXT[!MUST,test]:    connection with an "unexpected_message" alert.
    TEXT[!MUST]:    The presence of padding does not change the overall record size
    TEXT[!MUST]:    limitations: the full encoded TLSInnerPlaintext MUST NOT exceed 2^14
    TEXT[!MUST]:    + 1 octets.

  SECTION: [Limits on Key Usage](#section-5.5)
    TEXT[!SHOULD]:    Implementations SHOULD do a key update as described in Section 4.6.3
    TEXT[!SHOULD]:    prior to reaching these limits.

  SECTION: [Alert Protocol](#section-6)
    TEXT[test]: The
    TEXT[test]:    "close_notify" alert is used to indicate orderly closure of one
    TEXT[test]:    direction of the connection.
    TEXT[!SHOULD,test]: Upon receiving such an alert, the TLS
    TEXT[!SHOULD,test]:    implementation SHOULD indicate end-of-data to the application.
    TEXT[!MUST,test]: Upon receiving an error alert, the TLS implementation
    TEXT[!MUST,test]:    SHOULD indicate an error to the application and MUST NOT allow any
    TEXT[!MUST,test]:    further data to be sent or received on the connection.
    TEXT[!MUST]: Servers and
    TEXT[!MUST]:    clients MUST forget the secret values and keys established in failed
    TEXT[!MUST]:    connections, with the exception of the PSKs associated with session
    TEXT[!MUST]:    tickets, which SHOULD be discarded if possible.
    TEXT[!MUST,test]:    All the alerts listed in Section 6.2 MUST be sent with
    TEXT[!MUST,test]:    AlertLevel=fatal and
    TEXT[!MUST,implementation,test]: MUST be treated as error alerts when received
    TEXT[!MUST,implementation,test]:    regardless of the AlertLevel in the message.
    TEXT[!MUST,implementation,test]: Unknown Alert types
    TEXT[!MUST,implementation,test]:    MUST be treated as error alerts.
    TEXT[!MUST]: Peers which receive a message which
    TEXT[!MUST]:    cannot be parsed according to the syntax (e.g., have a length
    TEXT[!MUST]:    extending beyond the message boundary or contain an out-of-range
    TEXT[!MUST]:    length) MUST terminate the connection with a "decode_error" alert.
    TEXT[!MUST]:    Peers which receive a message which is syntactically correct but
    TEXT[!MUST]:    semantically invalid (e.g., a DHE share of p - 1, or an invalid enum)
    TEXT[!MUST]:    MUST terminate the connection with an "illegal_parameter" alert.
    TEXT[implementation]:       enum {
    TEXT[implementation]:           close_notify(0),
    TEXT[implementation]:           unexpected_message(10),
    TEXT[implementation]:           bad_record_mac(20),
    TEXT[implementation]:           record_overflow(22),
    TEXT[implementation]:           handshake_failure(40),
    TEXT[implementation]:           bad_certificate(42),
    TEXT[implementation]:           unsupported_certificate(43),
    TEXT[implementation]:           certificate_revoked(44),
    TEXT[implementation]:           certificate_expired(45),
    TEXT[implementation]:           certificate_unknown(46),
    TEXT[implementation]:           illegal_parameter(47),
    TEXT[implementation]:           unknown_ca(48),
    TEXT[implementation]:           access_denied(49),
    TEXT[implementation]:           decode_error(50),
    TEXT[implementation]:           decrypt_error(51),
    TEXT[implementation]:           protocol_version(70),
    TEXT[implementation]:           insufficient_security(71),
    TEXT[implementation]:           internal_error(80),
    TEXT[implementation]:           inappropriate_fallback(86),
    TEXT[implementation]:           user_canceled(90),
    TEXT[implementation]:           missing_extension(109),
    TEXT[implementation]:           unsupported_extension(110),
    TEXT[implementation]:           unrecognized_name(112),
    TEXT[implementation]:           bad_certificate_status_response(113),
    TEXT[implementation]:           unknown_psk_identity(115),
    TEXT[implementation]:           certificate_required(116),
    TEXT[implementation]:           no_application_protocol(120),
    TEXT[implementation]:           (255)
    TEXT[implementation]:       } AlertDescription;

  SECTION: [Closure Alerts](#section-6.1)
    TEXT[!MUST,test]: Any data received
    TEXT[!MUST,test]:       after a closure alert has been received MUST be ignored.
    TEXT[!SHOULD]: This alert SHOULD be followed by a
    TEXT[!SHOULD]:       "close_notify".
    TEXT[!MAY,test]:    Either party MAY initiate a close of its write side of the connection
    TEXT[!MAY,test]:    by sending a "close_notify" alert.
    TEXT[test]:   Any data received after a closure
    TEXT[test]:    alert has been received MUST be ignored.
    TEXT[implementation,test]: If a transport-level close
    TEXT[implementation,test]:    is received prior to a "close_notify", the receiver cannot know that
    TEXT[implementation,test]:    all the data that was sent has been received.
    TEXT[!MUST,implementation,test]:    Each party MUST send a "close_notify" alert before closing its write
    TEXT[!MUST,implementation,test]:    side of the connection, unless it has already sent some error alert.
    TEXT[test]:    This does not have any effect on its read side of the connection.
    TEXT[implementation,test]:    Note that this is a change from versions of TLS prior to TLS 1.3 in
    TEXT[implementation,test]:    which implementations were required to react to a "close_notify" by
    TEXT[implementation,test]:    discarding pending writes and sending an immediate "close_notify"
    TEXT[implementation,test]:    alert of their own.
    TEXT[!MUST,implementation,test]:    If the application protocol using TLS provides that any data may be
    TEXT[!MUST,implementation,test]:    carried over the underlying transport after the TLS connection is
    TEXT[!MUST,implementation,test]:    closed, the TLS implementation MUST receive a "close_notify" alert
    TEXT[!MUST,implementation,test]:    before indicating end-of-data to the application layer.

  SECTION: [Error Alerts](#section-6.2)
    TEXT[!MUST,test]: Upon transmission or
    TEXT[!MUST,test]:    receipt of a fatal alert message, both parties MUST immediately close
    TEXT[!MUST,test]:    the connection.
    TEXT[!MUST,test]:    Whenever an implementation encounters a fatal error condition, it
    TEXT[!MUST,test]:    SHOULD send an appropriate fatal alert
    TEXT[!MUST,test]: and MUST close the connection
    TEXT[!MUST,test]:    without sending or receiving any additional data.
    TEXT[!SHOULD]: In the rest of
    TEXT[!SHOULD]:    this specification, when the phrases "terminate the connection" and
    TEXT[!SHOULD]:    "abort the handshake" are used without a specific alert it means that
    TEXT[!SHOULD]:    the implementation SHOULD send the alert indicated by the
    TEXT[!SHOULD]:    descriptions below.
    TEXT[!MUST,exception]: The phrases "terminate the connection with an X
    TEXT[!MUST,exception]:    alert" and "abort the handshake with an X alert" mean that the
    TEXT[!MUST,exception]:    implementation MUST send alert X if it sends any alert.
    TEXT[!SHOULD,test]: The
    TEXT[!SHOULD,test]:    implementation SHOULD provide a way to facilitate logging the sending
    TEXT[!SHOULD,test]:    and receiving of alerts.
    TEXT[implementation]:    bad_certificate:  A certificate was corrupt, contained signatures
    TEXT[implementation]:       that did not verify correctly, etc.
    TEXT[implementation]:    unsupported_certificate:  A certificate was of an unsupported type.
    TEXT[implementation]:    certificate_revoked:  A certificate was revoked by its signer.
    TEXT[implementation]:    certificate_expired:  A certificate has expired or is not currently
    TEXT[implementation]:       valid.
    TEXT[implementation]:    certificate_unknown:  Some other (unspecified) issue arose in
    TEXT[implementation]:       processing the certificate, rendering it unacceptable.
    TEXT[implementation]:    access_denied:  A valid certificate or PSK was received, but when
    TEXT[implementation]:       access control was applied, the sender decided not to proceed with
    TEXT[implementation]:       negotiation.
    TEXT[!MAY]:       Sending this alert is OPTIONAL; servers MAY instead choose to send
    TEXT[!MAY]:       a "decrypt_error" alert to merely indicate an invalid PSK
    TEXT[!MAY]:       identity.

  SECTION: [Key Schedule](#section-7.1)
    TEXT[implementation]:        Derive-Secret(Secret, Label, Messages) =
    TEXT[implementation]:             HKDF-Expand-Label(Secret, Label,
    TEXT[implementation]:                               Transcript-Hash(Messages), Hash.length)
    TEXT[implementation]: Note that in some cases a zero-
    TEXT[implementation]:    length Context (indicated by "") is passed to HKDF-Expand-Label
    TEXT[implementation]:    PSK ->  HKDF-Extract = Early Secret
    TEXT[implementation]:              +-----> Derive-Secret(., "ext binder" | "res binder", "")
    TEXT[implementation]:              |                     = binder_key
    TEXT[implementation]:              +-----> Derive-Secret(., "c e traffic", ClientHello)
    TEXT[implementation]:              |                     = client_early_traffic_secret
    TEXT[implementation]:        Derive-Secret(., "derived", "")
    TEXT[implementation]:    (EC)DHE -> HKDF-Extract = Handshake Secret
    TEXT[implementation]:              +-----> Derive-Secret(., "c hs traffic",
    TEXT[implementation]:              |                     ClientHello...ServerHello)
    TEXT[implementation]:              |                     = client_handshake_traffic_secret
    TEXT[implementation]:              +-----> Derive-Secret(., "s hs traffic",
    TEXT[implementation]:              |                     ClientHello...ServerHello)
    TEXT[implementation]:              |                     = server_handshake_traffic_secret
    TEXT[implementation]:        Derive-Secret(., "derived", "")
    TEXT[implementation]:    0 -> HKDF-Extract = Master Secret
    TEXT[implementation]:              +-----> Derive-Secret(., "c ap traffic",
    TEXT[implementation]:              |                     ClientHello...server Finished)
    TEXT[implementation]:              |                     = client_application_traffic_secret_0
    TEXT[implementation]:              +-----> Derive-Secret(., "s ap traffic",
    TEXT[implementation]:              |                     ClientHello...server Finished)
    TEXT[implementation]:              |                     = server_application_traffic_secret_0
    TEXT[implementation]:              +-----> Derive-Secret(., "exp master",
    TEXT[implementation]:              |                     ClientHello...server Finished)
    TEXT[implementation]:              |                     = exporter_master_secret
    TEXT[implementation]:              +-----> Derive-Secret(., "res master",
    TEXT[implementation]:                                    ClientHello...client Finished)
    TEXT[implementation]:                                    = resumption_master_secret
    TEXT[implementation]:    If a given secret is not available, then the 0-value consisting of a
    TEXT[implementation]:    string of Hash.length bytes set to zeros is used.
    TEXT[implementation]:    There are multiple potential Early Secret values, depending on which
    TEXT[implementation]:    PSK the server ultimately selects.  The client will need to compute
    TEXT[implementation]:    one for each potential PSK
    TEXT[implementation]: if no PSK is selected, it will then need
    TEXT[implementation]:    to compute the Early Secret corresponding to the zero PSK.
    TEXT[!SHOULD]:    Once all the values which are to be derived from a given secret have
    TEXT[!SHOULD]:    been computed, that secret SHOULD be erased.

  SECTION: [Updating Traffic Secrets](#section-7.2)
    TEXT[!SHOULD]:    Once client_/server_application_traffic_secret_N+1 and its associated
    TEXT[!SHOULD]:    traffic keys have been computed, implementations SHOULD delete
    TEXT[!SHOULD]:    client_/server_application_traffic_secret_N and its associated
    TEXT[!SHOULD]:    traffic keys.

  SECTION: [Traffic Key Calculation](#section-7.3)
    TEXT[implementation]:    The traffic keying material is generated from the following input
    TEXT[implementation]:    values:
    TEXT[implementation]:    -  A secret value
    TEXT[implementation]:    -  A purpose value indicating the specific value being generated
    TEXT[implementation]:    -  The length of the key being generated
    TEXT[implementation]:    The traffic keying material is generated from an input traffic secret
    TEXT[implementation]:    value using:
    TEXT[implementation]:    [sender]_write_key = HKDF-Expand-Label(Secret, "key", "", key_length)
    TEXT[implementation]:    [sender]_write_iv  = HKDF-Expand-Label(Secret, "iv", "", iv_length)

  SECTION: [Elliptic Curve Diffie-Hellman](#section-7.4.2)
    TEXT[!MUST]:    Note that this octet string ("Z" in IEEE 1363 terminology) as output
    TEXT[!MUST]:    by FE2OSP (the Field Element to Octet String Conversion Primitive)
    TEXT[!MUST]:    has constant length for any given field; leading zeros found in this
    TEXT[!MUST]:    octet string MUST NOT be truncated.
    TEXT[!SHOULD]:    For these curves, implementations SHOULD use the approach specified
    TEXT[!SHOULD]:    in [RFC7748] to calculate the Diffie-Hellman shared secret.
    TEXT[!MUST]:    Implementations MUST check whether the computed Diffie-Hellman shared
    TEXT[!MUST]:    secret is the all-zero value and abort if so, as described in
    TEXT[!MUST]:    Section 6 of [RFC7748].
    TEXT[!SHOULD]: If implementors use an alternative
    TEXT[!SHOULD]:    implementation of these elliptic curves, they SHOULD perform the
    TEXT[!SHOULD]:    additional checks specified in Section 7 of [RFC7748].

  SECTION: [Exporters](#section-7.5)
    TEXT[implementation]:    The exporter value is computed as:
    TEXT[implementation]:    TLS-Exporter(label, context_value, key_length) =
    TEXT[implementation]:        HKDF-Expand-Label(Derive-Secret(Secret, label, ""),
    TEXT[implementation]:                          "exporter", Hash(context_value), key_length)
    TEXT[!MUST]: Implementations MUST use the
    TEXT[!MUST]:    exporter_master_secret unless explicitly specified by the
    TEXT[!MUST]:    application.
    TEXT[!SHOULD]: A separate
    TEXT[!SHOULD]:    interface for the early exporter is RECOMMENDED; this avoids the
    TEXT[!SHOULD]:    exporter user accidentally using an early exporter when a regular one
    TEXT[!SHOULD]:    is desired or vice versa.
    TEXT[!MUST]: Future
    TEXT[!MUST]:    specifications MUST NOT define a use of exporters that permit both an
    TEXT[!MUST]:    empty context and no context with the same label.
    TEXT[!SHOULD]: New uses of
    TEXT[!SHOULD]:    exporters SHOULD provide a context in all exporter computations,
    TEXT[!SHOULD]:    though the value could be empty.

  SECTION: [0-RTT and Anti-Replay](#section-8)
    TEXT[!SHOULD]: Servers
    TEXT[!SHOULD]:    SHOULD provide that level of replay safety by implementing one of the
    TEXT[!SHOULD]:    methods described in this section or by equivalent means.
    TEXT[!MUST]: Therefore, in normal
    TEXT[!MUST]:    operation, clients will not know which, if any, of these mechanisms
    TEXT[!MUST]:    servers actually implement and hence MUST only send early data which
    TEXT[!MUST]:    they deem safe to be replayed.
    TEXT[!MUST]: The server MUST ensure that any
    TEXT[!MUST]:    instance of it (be it a machine, a thread, or any other entity within
    TEXT[!MUST]:    the relevant serving infrastructure) would accept 0-RTT for the same
    TEXT[!MUST]:    0-RTT handshake at most once; this limits the number of replays to
    TEXT[!MUST]:    the number of server instances in the deployment.
    TEXT[!SHOULD]: The "at most once per
    TEXT[!SHOULD]:    server instance" guarantee is a minimum requirement; servers SHOULD
    TEXT[!SHOULD]:    limit 0-RTT replays further when feasible.
    TEXT[!MUST]:    The second class of attack cannot be prevented at the TLS layer and
    TEXT[!MUST]:    MUST be dealt with by any application.

  SECTION: [Client Hello Recording](#section-8.2)
    TEXT[!MUST]: Servers MAY
    TEXT[!MUST]:    also implement data stores with false positives, such as Bloom
    TEXT[!MUST]:    filters, in which case they MUST respond to apparent replay by
    TEXT[!MUST]:    rejecting 0-RTT but MUST NOT abort the handshake.
    TEXT[!MUST]:    The server MUST derive the storage key only from validated sections
    TEXT[!MUST]:    of the ClientHello.
    TEXT[!SHOULD]:    When implementations are freshly started, they SHOULD reject 0-RTT as
    TEXT[!SHOULD]:    long as any portion of their recording window overlaps the startup
    TEXT[!SHOULD]:    time.

  SECTION: [Mandatory-to-Implement Cipher Suites](#section-9.1)
    TEXT[!MUST]:    A TLS-compliant application MUST implement the TLS_AES_128_GCM_SHA256
    TEXT[!MUST]:    [GCM] cipher suite and SHOULD implement the TLS_AES_256_GCM_SHA384
    TEXT[!MUST]:    [GCM] and TLS_CHACHA20_POLY1305_SHA256 [RFC8439] cipher suites (see
    TEXT[!MUST]:    Appendix B.4).
    TEXT[!MUST]:    A TLS-compliant application MUST support digital signatures with
    TEXT[!MUST]:    rsa_pkcs1_sha256 (for certificates), rsa_pss_rsae_sha256 (for
    TEXT[!MUST]:    CertificateVerify and certificates), and ecdsa_secp256r1_sha256.
    TEXT[!MUST]:    TLS-compliant application MUST support key exchange with secp256r1
    TEXT[!MUST]:    (NIST P-256) and SHOULD support key exchange with X25519 [RFC7748].

  SECTION: [Mandatory-to-Implement Extensions](#section-9.2)
    TEXT[!MUST]:    In the absence of an application profile standard specifying
    TEXT[!MUST]:    otherwise, a TLS-compliant application MUST implement the following
    TEXT[!MUST]:    TLS extensions:
    TEXT[!MUST]:    All implementations MUST send and use these extensions when offering
    TEXT[!MUST]:    applicable features:
    TEXT[!MUST]:    -  "supported_versions" is REQUIRED for all ClientHello, ServerHello,
    TEXT[!MUST]:       and HelloRetryRequest messages.
    TEXT[!MUST]:    -  "signature_algorithms" is REQUIRED for certificate authentication.
    TEXT[!MUST]:    -  "supported_groups" is REQUIRED for ClientHello messages using DHE
    TEXT[!MUST]:       or ECDHE key exchange.
    TEXT[!MUST]:    -  "key_share" is REQUIRED for DHE or ECDHE key exchange.
    TEXT[!MUST]:    -  "pre_shared_key" is REQUIRED for PSK key agreement.
    TEXT[!MUST]:    -  "psk_key_exchange_modes" is REQUIRED for PSK key agreement.
    TEXT[!MUST]: Such a ClientHello
    TEXT[!MUST]:    message MUST meet the following requirements:
    TEXT[!MUST]:    -  If not containing a "pre_shared_key" extension, it MUST contain
    TEXT[!MUST]:       both a "signature_algorithms" extension and a "supported_groups"
    TEXT[!MUST]:       extension.
    TEXT[!MUST]:    -  If containing a "supported_groups" extension, it MUST also contain
    TEXT[!MUST]:       a "key_share" extension, and vice versa.
    TEXT[!MUST]:    Servers receiving a ClientHello which does not conform to these
    TEXT[!MUST]:    requirements MUST abort the handshake with a "missing_extension"
    TEXT[!MUST]:    alert.
    TEXT[!MUST]:    Additionally, all implementations MUST support the use of the
    TEXT[!MUST]:    "server_name" extension with applications capable of using it.
    TEXT[!MAY]:    Servers MAY require clients to send a valid "server_name" extension.
    TEXT[!SHOULD]:    Servers requiring this extension SHOULD respond to a ClientHello
    TEXT[!SHOULD]:    lacking a "server_name" extension by terminating the connection with
    TEXT[!SHOULD]:    a "missing_extension" alert.

  SECTION: [Protocol Invariants](#section-9.3)
    TEXT[!MUST]:    This section describes invariants that TLS endpoints and middleboxes
    TEXT[!MUST]:    MUST follow.
    TEXT[!MAY]: At the same
    TEXT[!MAY]:    time, deployments update at different rates, so a newer client or
    TEXT[!MAY]:    server MAY continue to support older parameters, which would allow it
    TEXT[!MAY]:    to interoperate with older endpoints.
    TEXT[!MUST]:    For this to work, implementations MUST correctly handle extensible
    TEXT[!MUST]:    fields:
    TEXT[!MUST]:    -  A client sending a ClientHello MUST support all parameters
    TEXT[!MUST]:       advertised in it.
    TEXT[!MUST]:    -  A server receiving a ClientHello MUST correctly ignore all
    TEXT[!MUST]:       unrecognized cipher suites, extensions, and other parameters.
    TEXT[!MUST]: In
    TEXT[!MUST]:       TLS 1.3, a client receiving a CertificateRequest or
    TEXT[!MUST]:       NewSessionTicket MUST also ignore all unrecognized extensions.
    TEXT[!MUST]:    -  A middlebox which terminates a TLS connection MUST behave as a
    TEXT[!MUST]:       compliant TLS server (to the original client), including having a
    TEXT[!MUST]:       certificate which the client is willing to accept, and also as a
    TEXT[!MUST]:       compliant TLS client (to the original server), including verifying
    TEXT[!MUST]:       the original server's certificate.
    TEXT[!MUST]: In particular, it MUST
    TEXT[!MUST]:       generate its own ClientHello containing only parameters it
    TEXT[!MUST]:       understands, and it MUST generate a fresh ServerHello random
    TEXT[!MUST]:       value, rather than forwarding the endpoint's value.
    TEXT[!MUST]:    -  A middlebox which forwards ClientHello parameters it does not
    TEXT[!MUST]:       understand MUST NOT process any messages beyond that ClientHello.
    TEXT[!MUST]:       It MUST forward all subsequent traffic unmodified.
    TEXT[!MAY]: These additions MAY
    TEXT[!MAY]:       change any message beyond the ClientHello arbitrarily.

  SECTION: [IANA Considerations](#section-11)
    TEXT[!MUST]:       IESG Approval is REQUIRED for a Y->N transition.

  SECTION: [State Machine](#appendix-A)
    TEXT[implementation]: Actions which are taken only in certain circumstances
    TEXT[implementation]:    are indicated in [].
    TEXT[implementation]: The notation "K_{send,recv} = foo" means "set
    TEXT[implementation]:    the send/recv key to the given key".

  SECTION: [Client](#appendix-A.1)
    TEXT[implementation]:                               START <----+
    TEXT[implementation]:                Send ClientHello |        | Recv HelloRetryRequest
    TEXT[implementation]:           [K_send = early data] |        |
    TEXT[implementation]:                                 v        |
    TEXT[implementation]:            /                 WAIT_SH ----+
    TEXT[implementation]:            |                    | Recv ServerHello
    TEXT[implementation]:            |                    | K_recv = handshake
    TEXT[implementation]:        Can |                    V
    TEXT[implementation]:       send |                 WAIT_EE
    TEXT[implementation]:      early |                    | Recv EncryptedExtensions
    TEXT[implementation]:       data |           +--------+--------+
    TEXT[implementation]:            |     Using |                 | Using certificate
    TEXT[implementation]:            |       PSK |                 v
    TEXT[implementation]:            |           |            WAIT_CERT_CR
    TEXT[implementation]:            |           |        Recv |       | Recv CertificateRequest
    TEXT[implementation]:            |           | Certificate |       v
    TEXT[implementation]:            |           |             |    WAIT_CERT
    TEXT[implementation]:            |           |             |       | Recv Certificate
    TEXT[implementation]:            |           |             v       v
    TEXT[implementation]:            |           |              WAIT_CV
    TEXT[implementation]:            |           |                 | Recv CertificateVerify
    TEXT[implementation]:            |           +> WAIT_FINISHED <+
    TEXT[implementation]:            |                  | Recv Finished
    TEXT[implementation]:            \                  | [Send EndOfEarlyData]
    TEXT[implementation]:                               | K_send = handshake
    TEXT[implementation]:                               | [Send Certificate [+ CertificateVerify]]
    TEXT[implementation]:     Can send                  | Send Finished
    TEXT[implementation]:     app data   -->            | K_send = K_recv = application
    TEXT[implementation]:     after here                v
    TEXT[implementation]:                           CONNECTED
    TEXT[!SHOULD]: If clients need to send such alerts, they
    TEXT[!SHOULD]:    SHOULD first rekey to the handshake keys if possible.

  SECTION: [Server](#appendix-A.2)
    TEXT[implementation]:                               START <-----+
    TEXT[implementation]:                Recv ClientHello |         | Send HelloRetryRequest
    TEXT[implementation]:                                 v         |
    TEXT[implementation]:                              RECVD_CH ----+
    TEXT[implementation]:                                 | Select parameters
    TEXT[implementation]:                              NEGOTIATED
    TEXT[implementation]:                                 | Send ServerHello
    TEXT[implementation]:                                 | K_send = handshake
    TEXT[implementation]:                                 | Send EncryptedExtensions
    TEXT[implementation]:                                 | [Send CertificateRequest]
    TEXT[implementation]:  Can send                       | [Send Certificate + CertificateVerify]
    TEXT[implementation]:  app data                       | Send Finished
    TEXT[implementation]:  after   -->                    | K_send = application
    TEXT[implementation]:  here                  +--------+--------+
    TEXT[implementation]:               No 0-RTT |                 | 0-RTT
    TEXT[implementation]:                        |                 |
    TEXT[implementation]:    K_recv = handshake  |                 | K_recv = early data
    TEXT[implementation]:  [Skip decrypt errors] |    +------> WAIT_EOED -+
    TEXT[implementation]:                        |    |       Recv |      | Recv EndOfEarlyData
    TEXT[implementation]:                        |    | early data |      | K_recv = handshake
    TEXT[implementation]:                        |    +------------+      |
    TEXT[implementation]:                        |                        |
    TEXT[implementation]:                        +> WAIT_FLIGHT2 <--------+
    TEXT[implementation]:                        +--------+--------+
    TEXT[implementation]:                No auth |                 | Client auth
    TEXT[implementation]:                        |                 |
    TEXT[implementation]:                        |                 v
    TEXT[implementation]:                        |             WAIT_CERT
    TEXT[implementation]:                        |        Recv |       | Recv Certificate
    TEXT[implementation]:                        |       empty |       v
    TEXT[implementation]:                        | Certificate |    WAIT_CV
    TEXT[implementation]:                        |             |       | Recv
    TEXT[implementation]:                        |             v       | CertificateVerify
    TEXT[implementation]:                        +-> WAIT_FINISHED <---+
    TEXT[implementation]:                                 | Recv Finished
    TEXT[implementation]:                                 | K_recv = application
    TEXT[implementation]:                             CONNECTED

  SECTION: [Protocol Data Structures and Constant Values](#appendix-B)
    TEXT[!MUST]:    TLS 1.3 implementations MUST NOT send them but might receive them
    TEXT[!MUST]:    from older TLS implementations.

  SECTION: [Supported Groups Extension](#appendix-B.3.1.4)
    TEXT[!MUST]:    Values within "obsolete_RESERVED" ranges are used in previous
    TEXT[!MUST]:    versions of TLS and MUST NOT be offered or negotiated by TLS 1.3
    TEXT[!MUST]:    implementations.

  SECTION: [Random Number Generation and Seeding](#appendix-C.1)
    TEXT[!SHOULD]: It is RECOMMENDED to use
    TEXT[!SHOULD]:    an existing CSPRNG implementation in preference to crafting a new
    TEXT[!SHOULD]:    one.

  SECTION: [Certificates and Authentication](#appendix-C.2)
    TEXT[!SHOULD]:    Applications SHOULD also enforce minimum and maximum key sizes.

  SECTION: [Implementation Pitfalls](#appendix-C.3)
    TEXT[!SHOULD]:    -  Do you use a strong and, most importantly, properly seeded random
    TEXT[!SHOULD]:       number generator (see Appendix C.1) when generating Diffie-Hellman
    TEXT[!SHOULD]:       private values, the ECDSA "k" parameter, and other security-
    TEXT[!SHOULD]:       critical values?  It is RECOMMENDED that implementations implement
    TEXT[!SHOULD]:       "deterministic ECDSA" as specified in [RFC6979].

  SECTION: [Client Tracking Prevention](#appendix-C.4)
    TEXT[!SHOULD]:    Clients SHOULD NOT reuse a ticket for multiple connections.
    TEXT[!SHOULD]:    Servers that issue tickets SHOULD offer at least as many tickets as
    TEXT[!SHOULD]:    the number of connections that a client might use; for example, a web
    TEXT[!SHOULD]:    browser using HTTP/1.1 [RFC7230] might open six connections to a
    TEXT[!SHOULD]:    server.
    TEXT[!SHOULD]: Servers SHOULD issue new tickets with every connection.

  SECTION: [Unauthenticated Operation](#appendix-C.5)
    TEXT[!MUST]: If no such mechanism is used, then the connection has no
    TEXT[!MUST]:    protection against active man-in-the-middle attack; applications
    TEXT[!MUST]:    MUST NOT use TLS in such a way absent explicit configuration or a
    TEXT[!MUST]:    specific application profile.

  SECTION: [Backward Compatibility](#appendix-D)
    TEXT[!MUST]: The value of
    TEXT[!MUST]:    TLSPlaintext.legacy_record_version MUST be ignored by all
    TEXT[!MUST]:    implementations.
    TEXT[!MAY]: The value of TLSCiphertext.legacy_record_version is
    TEXT[!MAY]:    included in the additional data for deprotection but MAY otherwise be
    TEXT[!MAY]:    ignored or MAY be validated to match the fixed constant value.
    TEXT[!SHOULD]: In order to maximize
    TEXT[!SHOULD]:    interoperability with older endpoints, implementations that negotiate
    TEXT[!SHOULD]:    the use of TLS 1.0-1.2 SHOULD set the record layer version number to
    TEXT[!SHOULD]:    the negotiated version for the ServerHello and all records
    TEXT[!SHOULD]:    thereafter.
    TEXT[!SHOULD]:    For maximum compatibility with previously non-standard behavior and
    TEXT[!SHOULD]:    misconfigured deployments, all implementations SHOULD support
    TEXT[!SHOULD]:    validation of certification paths based on the expectations in this
    TEXT[!SHOULD]:    document, even when handling prior TLS versions' handshakes (see
    TEXT[!SHOULD]:    Section 4.4.2.2).
    TEXT[!SHOULD]: Because TLS 1.3 always hashes in the transcript
    TEXT[!SHOULD]:    up to the server Finished, implementations which support both TLS 1.3
    TEXT[!SHOULD]:    and earlier versions SHOULD indicate the use of the Extended Master
    TEXT[!SHOULD]:    Secret extension in their APIs whenever TLS 1.3 is used.

  SECTION: [Negotiating with an Older Server](#appendix-D.1)
    TEXT[!SHOULD]:    A client using a ticket for resumption SHOULD initiate the connection
    TEXT[!SHOULD]:    using the version that was previously negotiated.
    TEXT[!SHOULD]:    Note that 0-RTT data is not compatible with older servers and
    TEXT[!SHOULD]:    SHOULD NOT be sent absent knowledge that the server supports TLS 1.3.
    TEXT[!MUST]:    If the version chosen by the server is not supported by the client
    TEXT[!MUST]:    (or is not acceptable), the client MUST abort the handshake with a
    TEXT[!MUST]:    "protocol_version" alert.
    TEXT[!SHOULD]: Multiple connection attempts may be required
    TEXT[!SHOULD]:    in order to negotiate a backward-compatible connection; however, this
    TEXT[!SHOULD]:    practice is vulnerable to downgrade attacks and is NOT RECOMMENDED.

  SECTION: [Negotiating with an Older Client](#appendix-D.2)
    TEXT[test]:    A TLS server can also receive a ClientHello indicating a version
    TEXT[test]:    number smaller than its highest supported version.
    TEXT[!MUST,test]: If the
    TEXT[!MUST,test]:    "supported_versions" extension is present, the server MUST negotiate
    TEXT[!MUST,test]:    using that extension as described in Section 4.2.1.
    TEXT[!MUST]: If the
    TEXT[!MUST]:    "supported_versions" extension is not present, the server MUST
    TEXT[!MUST]:    negotiate the minimum of ClientHello.legacy_version and TLS 1.2.
    TEXT[!MUST]: If the "supported_versions" extension is absent and the
    TEXT[!MUST]:    server only supports versions greater than
    TEXT[!MUST]:    ClientHello.legacy_version, the server MUST abort the handshake with
    TEXT[!MUST]:    a "protocol_version" alert.
    TEXT[!MUST]: Servers will receive various
    TEXT[!MUST]:    TLS 1.x versions in this field, but its value MUST always be ignored.

  SECTION: [0-RTT Backward Compatibility](#appendix-D.3)
    TEXT[!MUST,implementation,test]:    A client that attempts to send 0-RTT data MUST fail a connection if
    TEXT[!MUST,implementation,test]:    it receives a ServerHello with TLS 1.2 or older.
    TEXT[!SHOULD]: To avoid a downgrade attack, the
    TEXT[!SHOULD]:    client SHOULD NOT disable TLS 1.3, only 0-RTT.
    TEXT[!SHOULD]:    To avoid this error condition, multi-server deployments SHOULD ensure
    TEXT[!SHOULD]:    a uniform and stable deployment of TLS 1.3 without 0-RTT prior to
    TEXT[!SHOULD]:    enabling 0-RTT.

  SECTION: [Middlebox Compatibility Mode](#appendix-D.4)
    TEXT[test]:    Field measurements [Ben17a] [Ben17b] [Res17a] [Res17b] have found
    TEXT[test]:    that a significant number of middleboxes misbehave when a TLS
    TEXT[test]:    client/server pair negotiates TLS 1.3.  Implementations can increase
    TEXT[test]:    the chance of making connections through those middleboxes by making
    TEXT[test]:    the TLS 1.3 handshake look more like a TLS 1.2 handshake:
    TEXT[implementation]:    -
    TEXT[implementation,test]: If not offering early data, the client sends a dummy
    TEXT[implementation,test]:       change_cipher_spec record (see the third paragraph of Section 5)
    TEXT[implementation,test]:       immediately before its second flight.  This may either be before
    TEXT[implementation,test]:       its second ClientHello or before its encrypted handshake flight.
    TEXT[implementation,test]:       If offering early data, the record is placed immediately after the
    TEXT[implementation,test]:       first ClientHello.
    TEXT[test]: The server sends a dummy change_cipher_spec record immediately
    TEXT[test]:       after its first handshake message.  This may either be after a
    TEXT[test]:       ServerHello or a HelloRetryRequest.
    TEXT[!MUST]:    change_cipher_spec at any time during the handshake, as they must be
    TEXT[!MUST]:    ignored by the peer, but if the client sends a non-empty session ID,
    TEXT[!MUST]:    the server MUST send the change_cipher_spec as described in this
    TEXT[!MUST]:    appendix.

  SECTION: [Security Restrictions Related to Backward Compatibility](#appendix-D.5)
    TEXT[!SHOULD]:    Implementations negotiating the use of older versions of TLS SHOULD
    TEXT[!SHOULD]:    prefer forward secret and AEAD cipher suites, when available.
    TEXT[!MUST]: Implementations MUST NOT offer or
    TEXT[!MUST]:    negotiate RC4 cipher suites for any version of TLS for any reason.
    TEXT[!MUST]:    Ciphers with a strength less than 112 bits MUST NOT be offered or
    TEXT[!MUST]:    negotiated for any version of TLS for any reason.
    TEXT[!MUST]:    The security of SSL 3.0 [RFC6101] is considered insufficient for the
    TEXT[!MUST]:    reasons enumerated in [RFC7568], and it MUST NOT be negotiated for
    TEXT[!MUST]:    any reason.
    TEXT[!MUST]:    The security of SSL 2.0 [SSL2] is considered insufficient for the
    TEXT[!MUST]:    reasons enumerated in [RFC6176], and it MUST NOT be negotiated for
    TEXT[!MUST]:    any reason.
    TEXT[!MUST]:    Implementations MUST NOT send an SSL version 2.0 compatible
    TEXT[!MUST]:    CLIENT-HELLO.
    TEXT[!MUST]: Implementations MUST NOT negotiate TLS 1.3 or later
    TEXT[!MUST]:    using an SSL version 2.0 compatible CLIENT-HELLO.
    TEXT[!SHOULD]: Implementations
    TEXT[!SHOULD]:    are NOT RECOMMENDED to accept an SSL version 2.0 compatible
    TEXT[!SHOULD]:    CLIENT-HELLO in order to negotiate older versions of TLS.
    TEXT[!MUST]:    Implementations MUST NOT send a ClientHello.legacy_version or
    TEXT[!MUST]:    ServerHello.legacy_version set to 0x0300 or less.
    TEXT[!MUST]: Any endpoint
    TEXT[!MUST]:    receiving a Hello message with ClientHello.legacy_version or
    TEXT[!MUST]:    ServerHello.legacy_version set to 0x0300 MUST abort the handshake
    TEXT[!MUST]:    with a "protocol_version" alert.
    TEXT[!MUST]:    Implementations MUST NOT send any records with a version less than
    TEXT[!MUST]:    0x0300.
    TEXT[!SHOULD]: Implementations SHOULD NOT accept any records with a version
    TEXT[!SHOULD]:    less than 0x0300 (but may inadvertently do so if the record version
    TEXT[!SHOULD]:    number is ignored completely).
    TEXT[!MUST]:    Implementations MUST NOT use the Truncated HMAC extension, defined in
    TEXT[!MUST]:    Section 7 of [RFC6066], as it is not applicable to AEAD algorithms
    TEXT[!MUST]:    and has been shown to be insecure in some scenarios.

  SECTION: [Handshake](#appendix-E.1)
    TEXT[!MUST]: Implementations
    TEXT[!MUST]:    MUST NOT combine external PSKs with certificate-based authentication
    TEXT[!MUST]:    of either the client or the server unless negotiated by some
    TEXT[!MUST]:    extension.
    TEXT[!MUST]:    Note: Exporters can produce arbitrary-length values; if exporters are
    TEXT[!MUST]:    to be used as channel bindings, the exported value MUST be large
    TEXT[!MUST]:    enough to provide collision resistance.

  SECTION: [Key Derivation and HKDF](#appendix-E.1.1)
    TEXT[!SHOULD]: This ordering should always be followed
    TEXT[!SHOULD]:    (including in future revisions of this document); in particular, one
    TEXT[!SHOULD]:    SHOULD NOT use an output of HKDF-Extract as an input to another
    TEXT[!SHOULD]:    application of HKDF-Extract without an HKDF-Expand in between.

  SECTION: [Exporter Independence](#appendix-E.1.4)
    TEXT[!SHOULD]: However, because these secrets can be used to compute any
    TEXT[!SHOULD]:    exporter value, they SHOULD be erased as soon as possible.
    TEXT[!SHOULD]: If the
    TEXT[!SHOULD]:    total set of exporter labels is known, then implementations SHOULD
    TEXT[!SHOULD]:    pre-compute the inner Derive-Secret stage of the exporter computation
    TEXT[!SHOULD]:    for all those labels, then erase the [early_]exporter_master_secret,
    TEXT[!SHOULD]:    followed by each inner value as soon as it is known that it will not
    TEXT[!SHOULD]:    be needed again.

  SECTION: [Replay Attacks on 0-RTT](#appendix-E.5)
    TEXT[!MUST]: Because clients
    TEXT[!MUST]:    do not know the exact details of server behavior, they MUST NOT send
    TEXT[!MUST]:    messages in early data which are not safe to have replayed and which
    TEXT[!MUST]:    they would not be willing to retry across multiple 1-RTT connections.
    TEXT[!MUST]:    Application protocols MUST NOT use 0-RTT data without a profile that
    TEXT[!MUST]:    defines its use.
    TEXT[!MUST]:    In addition, to avoid accidental misuse, TLS implementations MUST NOT
    TEXT[!MUST]:    enable 0-RTT (either sending or accepting) unless specifically
    TEXT[!MUST]:    requested by the application and MUST NOT automatically resend 0-RTT
    TEXT[!MUST]:    data if it is rejected by the server unless instructed by the
    TEXT[!MUST]:    application.
    TEXT[!MUST]: In order to allow applications to implement this kind of
    TEXT[!MUST]:    processing, TLS implementations MUST provide a way for the
    TEXT[!MUST]:    application to determine if the handshake has completed.

  SECTION: [Replay and Exporters](#appendix-E.5.1)
    TEXT[!SHOULD]:    In addition, the early exporter SHOULD NOT be used to generate
    TEXT[!SHOULD]:    server-to-client encryption keys because that would entail the reuse
    TEXT[!SHOULD]:    of those keys.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc8448
  SECTION: [Simple 1-RTT Handshake](#section-3)
    TEXT[test]:    {client}  create an ephemeral x25519 key pair:
    TEXT[test]:       private key (32 octets):  49 af 42 ba 7f 79 94 85 2d 71 3e f2 78
    TEXT[test]:          4b cb ca a7 91 1d e2 6a dc 56 42 cb 63 45 40 e7 ea 50 05
    TEXT[test]:       public key (32 octets):  99 38 1d e5 60 e4 bd 43 d2 3d 8e 43 5a 7d
    TEXT[test]:          ba fe b3 c0 6e 51 c1 3c ae 4d 54 13 69 1e 52 9a af 2c
    TEXT[test]:    {server}  extract secret "early":
    TEXT[test]:       salt:  0 (all zero octets)
    TEXT[test]:       IKM (32 octets):  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    TEXT[test]:          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    TEXT[test]:       secret (32 octets):  33 ad 0a 1c 60 7e c0 3b 09 e6 cd 98 93 68 0c
    TEXT[test]:          e2 10 ad f3 00 aa 1f 26 60 e1 b2 2e 10 f1 70 f9 2a
    TEXT[test]:    {server}  create an ephemeral x25519 key pair:
    TEXT[test]:       private key (32 octets):  b1 58 0e ea df 6d d5 89 b8 ef 4f 2d 56
    TEXT[test]:          52 57 8c c8 10 e9 98 01 91 ec 8d 05 83 08 ce a2 16 a2 1e
    TEXT[test]:       public key (32 octets):  c9 82 88 76 11 20 95 fe 66 76 2b db f7 c6
    TEXT[test]:          72 e1 56 d6 cc 25 3b 83 3d f1 dd 69 b1 b0 4e 75 1f 0f
    TEXT[test]:    {server}  extract secret "handshake":
    TEXT[test]:       salt (32 octets):  6f 26 15 a1 08 c7 02 c5 67 8f 54 fc 9d ba b6 97
    TEXT[test]:          16 c0 76 18 9c 48 25 0c eb ea c3 57 6c 36 11 ba
    TEXT[test]:       IKM (32 octets):  8b d4 05 4f b5 5b 9d 63 fd fb ac f9 f0 4b 9f 0d
    TEXT[test]:          35 e6 d6 3f 53 75 63 ef d4 62 72 90 0f 89 49 2d
    TEXT[test]:       secret (32 octets):  1d c8 26 e9 36 06 aa 6f dc 0a ad c1 2f 74 1b
    TEXT[test]:          01 04 6a a6 b9 9f 69 1e d2 21 a9 f0 ca 04 3f be ac
    TEXT[test]:    {server}  derive secret "tls13 c hs traffic":
    TEXT[test]:       PRK (32 octets):  1d c8 26 e9 36 06 aa 6f dc 0a ad c1 2f 74 1b 01
    TEXT[test]:          04 6a a6 b9 9f 69 1e d2 21 a9 f0 ca 04 3f be ac
    TEXT[test]:       hash (32 octets):  86 0c 06 ed c0 78 58 ee 8e 78 f0 e7 42 8c 58 ed
    TEXT[test]:          d6 b4 3f 2c a3 e6 e9 5f 02 ed 06 3c f0 e1 ca d8
    TEXT[test]:       info (54 octets):  00 20 12 74 6c 73 31 33 20 63 20 68 73 20 74 72
    TEXT[test]:          61 66 66 69 63 20 86 0c 06 ed c0 78 58 ee 8e 78 f0 e7 42 8c 58
    TEXT[test]:          ed d6 b4 3f 2c a3 e6 e9 5f 02 ed 06 3c f0 e1 ca d8
    TEXT[test]:       expanded (32 octets):  b3 ed db 12 6e 06 7f 35 a7 80 b3 ab f4 5e
    TEXT[test]:          2d 8f 3b 1a 95 07 38 f5 2e 96 00 74 6a 0e 27 a5 5a 21
    TEXT[test]:    {server}  derive secret "tls13 s hs traffic":
    TEXT[test]:       PRK (32 octets):  1d c8 26 e9 36 06 aa 6f dc 0a ad c1 2f 74 1b 01
    TEXT[test]:          04 6a a6 b9 9f 69 1e d2 21 a9 f0 ca 04 3f be ac
    TEXT[test]:       hash (32 octets):  86 0c 06 ed c0 78 58 ee 8e 78 f0 e7 42 8c 58 ed
    TEXT[test]:          d6 b4 3f 2c a3 e6 e9 5f 02 ed 06 3c f0 e1 ca d8
    TEXT[test]:       info (54 octets):  00 20 12 74 6c 73 31 33 20 73 20 68 73 20 74 72
    TEXT[test]:          61 66 66 69 63 20 86 0c 06 ed c0 78 58 ee 8e 78 f0 e7 42 8c 58
    TEXT[test]:          ed d6 b4 3f 2c a3 e6 e9 5f 02 ed 06 3c f0 e1 ca d8
    TEXT[test]:       expanded (32 octets):  b6 7b 7d 69 0c c1 6c 4e 75 e5 42 13 cb 2d
    TEXT[test]:          37 b4 e9 c9 12 bc de d9 10 5d 42 be fd 59 d3 91 ad 38
    TEXT[test]:    {server}  extract secret "master":
    TEXT[test]:       salt (32 octets):  43 de 77 e0 c7 77 13 85 9a 94 4d b9 db 25 90 b5
    TEXT[test]:          31 90 a6 5b 3e e2 e4 f1 2d d7 a0 bb 7c e2 54 b4
    TEXT[test]:       IKM (32 octets):  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    TEXT[test]:          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    TEXT[test]:       secret (32 octets):  18 df 06 84 3d 13 a0 8b f2 a4 49 84 4c 5f 8a
    TEXT[test]:          47 80 01 bc 4d 4c 62 79 84 d5 a4 1d a8 d0 40 29 19
    TEXT[test]:    {server}  derive write traffic keys for handshake data:
    TEXT[test]:       PRK (32 octets):  b6 7b 7d 69 0c c1 6c 4e 75 e5 42 13 cb 2d 37 b4
    TEXT[test]:          e9 c9 12 bc de d9 10 5d 42 be fd 59 d3 91 ad 38
    TEXT[test]:       key info (13 octets):  00 10 09 74 6c 73 31 33 20 6b 65 79 00
    TEXT[test]:       key expanded (16 octets):  3f ce 51 60 09 c2 17 27 d0 f2 e4 e8 6e
    TEXT[test]:          e4 03 bc
    TEXT[test]:       iv info (12 octets):  00 0c 08 74 6c 73 31 33 20 69 76 00
    TEXT[test]:       iv expanded (12 octets):  5d 31 3e b2 67 12 76 ee 13 00 0b 30
    TEXT[test]:    {server}  calculate finished "tls13 finished":
    TEXT[test]:       PRK (32 octets):  b6 7b 7d 69 0c c1 6c 4e 75 e5 42 13 cb 2d 37 b4
    TEXT[test]:          e9 c9 12 bc de d9 10 5d 42 be fd 59 d3 91 ad 38
    TEXT[test]:       hash (0 octets):  (empty)
    TEXT[test]:       info (18 octets):  00 20 0e 74 6c 73 31 33 20 66 69 6e 69 73 68 65
    TEXT[test]:          64 00
    TEXT[test]:       expanded (32 octets):  00 8d 3b 66 f8 16 ea 55 9f 96 b5 37 e8 85
    TEXT[test]:          c3 1f c0 68 bf 49 2c 65 2f 01 f2 88 a1 d8 cd c1 9f c8
    TEXT[test]:    {server}  derive secret "tls13 c ap traffic":
    TEXT[test]:       PRK (32 octets):  18 df 06 84 3d 13 a0 8b f2 a4 49 84 4c 5f 8a 47
    TEXT[test]:          80 01 bc 4d 4c 62 79 84 d5 a4 1d a8 d0 40 29 19
    TEXT[test]:       hash (32 octets):  96 08 10 2a 0f 1c cc 6d b6 25 0b 7b 7e 41 7b 1a
    TEXT[test]:          00 0e aa da 3d aa e4 77 7a 76 86 c9 ff 83 df 13
    TEXT[test]:       info (54 octets):  00 20 12 74 6c 73 31 33 20 63 20 61 70 20 74 72
    TEXT[test]:          61 66 66 69 63 20 96 08 10 2a 0f 1c cc 6d b6 25 0b 7b 7e 41 7b
    TEXT[test]:          1a 00 0e aa da 3d aa e4 77 7a 76 86 c9 ff 83 df 13
    TEXT[test]:       expanded (32 octets):  9e 40 64 6c e7 9a 7f 9d c0 5a f8 88 9b ce
    TEXT[test]:          65 52 87 5a fa 0b 06 df 00 87 f7 92 eb b7 c1 75 04 a5
    TEXT[test]:    {server}  derive secret "tls13 s ap traffic":
    TEXT[test]:       PRK (32 octets):  18 df 06 84 3d 13 a0 8b f2 a4 49 84 4c 5f 8a 47
    TEXT[test]:          80 01 bc 4d 4c 62 79 84 d5 a4 1d a8 d0 40 29 19
    TEXT[test]:       hash (32 octets):  96 08 10 2a 0f 1c cc 6d b6 25 0b 7b 7e 41 7b 1a
    TEXT[test]:          00 0e aa da 3d aa e4 77 7a 76 86 c9 ff 83 df 13
    TEXT[test]:       info (54 octets):  00 20 12 74 6c 73 31 33 20 73 20 61 70 20 74 72
    TEXT[test]:          61 66 66 69 63 20 96 08 10 2a 0f 1c cc 6d b6 25 0b 7b 7e 41 7b
    TEXT[test]:          1a 00 0e aa da 3d aa e4 77 7a 76 86 c9 ff 83 df 13
    TEXT[test]:       expanded (32 octets):  a1 1a f9 f0 55 31 f8 56 ad 47 11 6b 45 a9
    TEXT[test]:          50 32 82 04 b4 f4 4b fb 6b 3a 4b 4f 1f 3f cb 63 16 43
    TEXT[test]:    {server}  derive secret "tls13 exp master":
    TEXT[test]:       PRK (32 octets):  18 df 06 84 3d 13 a0 8b f2 a4 49 84 4c 5f 8a 47
    TEXT[test]:          80 01 bc 4d 4c 62 79 84 d5 a4 1d a8 d0 40 29 19
    TEXT[test]:       hash (32 octets):  96 08 10 2a 0f 1c cc 6d b6 25 0b 7b 7e 41 7b 1a
    TEXT[test]:          00 0e aa da 3d aa e4 77 7a 76 86 c9 ff 83 df 13
    TEXT[test]:       info (52 octets):  00 20 10 74 6c 73 31 33 20 65 78 70 20 6d 61 73
    TEXT[test]:          74 65 72 20 96 08 10 2a 0f 1c cc 6d b6 25 0b 7b 7e 41 7b 1a 00
    TEXT[test]:          0e aa da 3d aa e4 77 7a 76 86 c9 ff 83 df 13
    TEXT[test]:       expanded (32 octets):  fe 22 f8 81 17 6e da 18 eb 8f 44 52 9e 67
    TEXT[test]:          92 c5 0c 9a 3f 89 45 2f 68 d8 ae 31 1b 43 09 d3 cf 50
    TEXT[test]:    {server}  derive write traffic keys for application data:
    TEXT[test]:       PRK (32 octets):  a1 1a f9 f0 55 31 f8 56 ad 47 11 6b 45 a9 50 32
    TEXT[test]:          82 04 b4 f4 4b fb 6b 3a 4b 4f 1f 3f cb 63 16 43
    TEXT[test]:       key info (13 octets):  00 10 09 74 6c 73 31 33 20 6b 65 79 00
    TEXT[test]:       key expanded (16 octets):  9f 02 28 3b 6c 9c 07 ef c2 6b b9 f2 ac
    TEXT[test]:          92 e3 56
    TEXT[test]:       iv info (12 octets):  00 0c 08 74 6c 73 31 33 20 69 76 00
    TEXT[test]:       iv expanded (12 octets):  cf 78 2b 88 dd 83 54 9a ad f1 e9 84
    TEXT[test]:    {server}  derive read traffic keys for handshake data:
    TEXT[test]:       PRK (32 octets):  b3 ed db 12 6e 06 7f 35 a7 80 b3 ab f4 5e 2d 8f
    TEXT[test]:          3b 1a 95 07 38 f5 2e 96 00 74 6a 0e 27 a5 5a 21
    TEXT[test]:       key info (13 octets):  00 10 09 74 6c 73 31 33 20 6b 65 79 00
    TEXT[test]:       key expanded (16 octets):  db fa a6 93 d1 76 2c 5b 66 6a f5 d9 50
    TEXT[test]:          25 8d 01
    TEXT[test]:       iv info (12 octets):  00 0c 08 74 6c 73 31 33 20 69 76 00
    TEXT[test]:       iv expanded (12 octets):  5b d3 c7 1b 83 6e 0b 76 bb 73 26 5f
    TEXT[test]:    {client}  extract secret "early" (same as server early secret)
    TEXT[test]:    {client}  extract secret "handshake" (same as server handshake
    TEXT[test]:       secret)
    TEXT[test]:    {client}  derive secret "tls13 c hs traffic" (same as server)
    TEXT[test]:    {client}  derive secret "tls13 s hs traffic" (same as server)
    TEXT[test]:    {client}  extract secret "master" (same as server master secret)
    TEXT[test]:    {client}  derive read traffic keys for handshake data (same as server
    TEXT[test]:       handshake data write traffic keys)
    TEXT[test]:    {client}  calculate finished "tls13 finished" (same as server)
    TEXT[test]:    {client}  derive secret "tls13 c ap traffic" (same as server)
    TEXT[test]:    {client}  derive secret "tls13 s ap traffic" (same as server)
    TEXT[test]:    {client}  derive secret "tls13 exp master" (same as server)
    TEXT[test]:    {client}  derive write traffic keys for handshake data (same as
    TEXT[test]:       server handshake data read traffic keys)
    TEXT[test]:    {client}  derive read traffic keys for application data (same as
    TEXT[test]:       server application data write traffic keys)
    TEXT[test]:    {client}  calculate finished "tls13 finished":
    TEXT[test]:       PRK (32 octets):  b3 ed db 12 6e 06 7f 35 a7 80 b3 ab f4 5e 2d 8f
    TEXT[test]:          3b 1a 95 07 38 f5 2e 96 00 74 6a 0e 27 a5 5a 21
    TEXT[test]:       hash (0 octets):  (empty)
    TEXT[test]:       info (18 octets):  00 20 0e 74 6c 73 31 33 20 66 69 6e 69 73 68 65
    TEXT[test]:          64 00
    TEXT[test]:       expanded (32 octets):  b8 0a d0 10 15 fb 2f 0b d6 5f f7 d4 da 5d
    TEXT[test]:          6b f8 3f 84 82 1d 1f 87 fd c7 d3 c7 5b 5a 7b 42 d9 c4
    TEXT[test]:    {client}  derive write traffic keys for application data:
    TEXT[test]:       PRK (32 octets):  9e 40 64 6c e7 9a 7f 9d c0 5a f8 88 9b ce 65 52
    TEXT[test]:          87 5a fa 0b 06 df 00 87 f7 92 eb b7 c1 75 04 a5
    TEXT[test]:       key info (13 octets):  00 10 09 74 6c 73 31 33 20 6b 65 79 00
    TEXT[test]:       key expanded (16 octets):  17 42 2d da 59 6e d5 d9 ac d8 90 e3 c6
    TEXT[test]:          3f 50 51
    TEXT[test]:       iv info (12 octets):  00 0c 08 74 6c 73 31 33 20 69 76 00
    TEXT[test]:       iv expanded (12 octets):  5b 78 92 3d ee 08 57 90 33 e5 23 d9
    TEXT[test]:    {client}  derive secret "tls13 res master":
    TEXT[test]:       PRK (32 octets):  18 df 06 84 3d 13 a0 8b f2 a4 49 84 4c 5f 8a 47
    TEXT[test]:          80 01 bc 4d 4c 62 79 84 d5 a4 1d a8 d0 40 29 19
    TEXT[test]:       hash (32 octets):  20 91 45 a9 6e e8 e2 a1 22 ff 81 00 47 cc 95 26
    TEXT[test]:          84 65 8d 60 49 e8 64 29 42 6d b8 7c 54 ad 14 3d
    TEXT[test]:       info (52 octets):  00 20 10 74 6c 73 31 33 20 72 65 73 20 6d 61 73
    TEXT[test]:          74 65 72 20 20 91 45 a9 6e e8 e2 a1 22 ff 81 00 47 cc 95 26 84
    TEXT[test]:          65 8d 60 49 e8 64 29 42 6d b8 7c 54 ad 14 3d
    TEXT[test]:       expanded (32 octets):  7d f2 35 f2 03 1d 2a 05 12 87 d0 2b 02 41
    TEXT[test]:          b0 bf da f8 6c c8 56 23 1f 2d 5a ba 46 c4 34 ec 19 6c
    TEXT[test]:    {server}  derive read traffic keys for application data (same as
    TEXT[test]:       client application data write traffic keys)
    TEXT[test]:    {server}  derive secret "tls13 res master" (same as client)
    TEXT[test]:    {server}  generate resumption secret "tls13 resumption":
    TEXT[implementation,test]:       PRK (32 octets):  7d f2 35 f2 03 1d 2a 05 12 87 d0 2b 02 41 b0 bf
    TEXT[implementation,test]:          da f8 6c c8 56 23 1f 2d 5a ba 46 c4 34 ec 19 6c
    TEXT[test]:       hash (2 octets):  00 00
    TEXT[test]:       info (22 octets):  00 20 10 74 6c 73 31 33 20 72 65 73 75 6d 70 74
    TEXT[test]:          69 6f 6e 02 00 00
    TEXT[implementation,test]:       expanded (32 octets):  4e cd 0e b6 ec 3b 4d 87 f5 d6 02 8f 92 2c
    TEXT[implementation,test]:          a4 c5 85 1a 27 7f d4 13 11 c9 e6 2d 2c 94 92 e1 c4 f3
    TEXT[test]:    {server}  construct a NewSessionTicket handshake message:
    TEXT[implementation,test]:       NewSessionTicket (205 octets):  04 00 00 c9 00 00 00 1e fa d6 aa
    TEXT[implementation,test]:          c5 02 00 00 00 b2 2c 03 5d 82 93 59 ee 5f f7 af 4e c9 00 00 00
    TEXT[implementation,test]:          00 26 2a 64 94 dc 48 6d 2c 8a 34 cb 33 fa 90 bf 1b 00 70 ad 3c
    TEXT[implementation,test]:          49 88 83 c9 36 7c 09 a2 be 78 5a bc 55 cd 22 60 97 a3 a9 82 11
    TEXT[implementation,test]:          72 83 f8 2a 03 a1 43 ef d3 ff 5d d3 6d 64 e8 61 be 7f d6 1d 28
    TEXT[implementation,test]:          27 db 27 9c ce 14 50 77 d4 54 a3 66 4d 4e 6d a4 d2 9e e0 37 25
    TEXT[implementation,test]:          a6 a4 da fc d0 fc 67 d2 ae a7 05 29 51 3e 3d a2 67 7f a5 90 6c
    TEXT[implementation,test]:          5b 3f 7d 8f 92 f2 28 bd a4 0d da 72 14 70 f9 fb f2 97 b5 ae a6
    TEXT[implementation,test]:          17 64 6f ac 5c 03 27 2e 97 07 27 c6 21 a7 91 41 ef 5f 7d e6 50
    TEXT[implementation,test]:          5e 5b fb c3 88 e9 33 43 69 40 93 93 4a e4 d3 57 00 08 00 2a 00
    TEXT[implementation,test]:          04 00 00 04 00

  SECTION: [Resumed 0-RTT Handshake](#section-4)
    TEXT[test]:    {client}  extract secret "early":
    TEXT[test]:       salt:  0 (all zero octets)
    TEXT[test]:       IKM (32 octets):  4e cd 0e b6 ec 3b 4d 87 f5 d6 02 8f 92 2c a4 c5
    TEXT[test]:          85 1a 27 7f d4 13 11 c9 e6 2d 2c 94 92 e1 c4 f3
    TEXT[test]:       secret (32 octets):  9b 21 88 e9 b2 fc 6d 64 d7 1d c3 29 90 0e 20
    TEXT[test]:          bb 41 91 50 00 f6 78 aa 83 9c bb 79 7c b7 d8 33 2c
    TEXT[test]:       PRK (32 octets):  69 fe 13 1a 3b ba d5 d6 3c 64 ee bc c3 0e 39 5b
    TEXT[test]:          9d 81 07 72 6a 13 d0 74 e3 89 db c8 a4 e4 72 56
    TEXT[test]:    {client}  send handshake record:
    TEXT[test]:       payload (512 octets):  01 00 01 fc 03 03 1b c3 ce b6 bb e3 9c ff
    TEXT[test]:          93 83 55 b5 a5 0a db 6d b2 1b 7a 6a f6 49 d7 b4 bc 41 9d 78 76
    TEXT[test]:          48 7d 95 00 00 06 13 01 13 03 13 02 01 00 01 cd 00 00 00 0b 00
    TEXT[test]:          09 00 00 06 73 65 72 76 65 72 ff 01 00 01 00 00 0a 00 14 00 12
    TEXT[test]:          00 1d 00 17 00 18 00 19 01 00 01 01 01 02 01 03 01 04 00 33 00
    TEXT[test]:          26 00 24 00 1d 00 20 e4 ff b6 8a c0 5f 8d 96 c9 9d a2 66 98 34
    TEXT[test]:          6c 6b e1 64 82 ba dd da fe 05 1a 66 b4 f1 8d 66 8f 0b 00 2a 00
    TEXT[test]:          00 00 2b 00 03 02 03 04 00 0d 00 20 00 1e 04 03 05 03 06 03 02
    TEXT[test]:          03 08 04 08 05 08 06 04 01 05 01 06 01 02 01 04 02 05 02 06 02
    TEXT[test]:          02 02 00 2d 00 02 01 01 00 1c 00 02 40 01 00 15 00 57 00 00 00
    TEXT[test]:          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    TEXT[test]:          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    TEXT[test]:          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    TEXT[test]:          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    TEXT[test]:          00 29 00 dd 00 b8 00 b2 2c 03 5d 82 93 59 ee 5f f7 af 4e c9 00
    TEXT[test]:          00 00 00 26 2a 64 94 dc 48 6d 2c 8a 34 cb 33 fa 90 bf 1b 00 70
    TEXT[test]:          ad 3c 49 88 83 c9 36 7c 09 a2 be 78 5a bc 55 cd 22 60 97 a3 a9
    TEXT[test]:          82 11 72 83 f8 2a 03 a1 43 ef d3 ff 5d d3 6d 64 e8 61 be 7f d6
    TEXT[test]:          1d 28 27 db 27 9c ce 14 50 77 d4 54 a3 66 4d 4e 6d a4 d2 9e e0
    TEXT[test]:          37 25 a6 a4 da fc d0 fc 67 d2 ae a7 05 29 51 3e 3d a2 67 7f a5
    TEXT[test]:          90 6c 5b 3f 7d 8f 92 f2 28 bd a4 0d da 72 14 70 f9 fb f2 97 b5
    TEXT[test]:          ae a6 17 64 6f ac 5c 03 27 2e 97 07 27 c6 21 a7 91 41 ef 5f 7d
    TEXT[test]:          e6 50 5e 5b fb c3 88 e9 33 43 69 40 93 93 4a e4 d3 57 fa d6 aa
    TEXT[test]:          cb 00 21 20 3a dd 4f b2 d8 fd f8 22 a0 ca 3c f7 67 8e f5 e8 8d
    TEXT[test]:          ae 99 01 41 c5 92 4d 57 bb 6f a3 1b 9e 5f 9d
    TEXT[test]:       complete record (517 octets):  16 03 01 02 00 01 00 01 fc 03 03 1b
    TEXT[test]:          c3 ce b6 bb e3 9c ff 93 83 55 b5 a5 0a db 6d b2 1b 7a 6a f6 49
    TEXT[test]:          d7 b4 bc 41 9d 78 76 48 7d 95 00 00 06 13 01 13 03 13 02 01 00
    TEXT[test]:          01 cd 00 00 00 0b 00 09 00 00 06 73 65 72 76 65 72 ff 01 00 01
    TEXT[test]:          00 00 0a 00 14 00 12 00 1d 00 17 00 18 00 19 01 00 01 01 01 02
    TEXT[test]:          01 03 01 04 00 33 00 26 00 24 00 1d 00 20 e4 ff b6 8a c0 5f 8d
    TEXT[test]:          96 c9 9d a2 66 98 34 6c 6b e1 64 82 ba dd da fe 05 1a 66 b4 f1
    TEXT[test]:          8d 66 8f 0b 00 2a 00 00 00 2b 00 03 02 03 04 00 0d 00 20 00 1e
    TEXT[test]:          04 03 05 03 06 03 02 03 08 04 08 05 08 06 04 01 05 01 06 01 02
    TEXT[test]:          01 04 02 05 02 06 02 02 02 00 2d 00 02 01 01 00 1c 00 02 40 01
    TEXT[test]:          00 15 00 57 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    TEXT[test]:          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    TEXT[test]:          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    TEXT[test]:          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    TEXT[test]:          00 00 00 00 00 00 00 00 29 00 dd 00 b8 00 b2 2c 03 5d 82 93 59
    TEXT[test]:          ee 5f f7 af 4e c9 00 00 00 00 26 2a 64 94 dc 48 6d 2c 8a 34 cb
    TEXT[test]:          33 fa 90 bf 1b 00 70 ad 3c 49 88 83 c9 36 7c 09 a2 be 78 5a bc
    TEXT[test]:          55 cd 22 60 97 a3 a9 82 11 72 83 f8 2a 03 a1 43 ef d3 ff 5d d3
    TEXT[test]:          6d 64 e8 61 be 7f d6 1d 28 27 db 27 9c ce 14 50 77 d4 54 a3 66
    TEXT[test]:          4d 4e 6d a4 d2 9e e0 37 25 a6 a4 da fc d0 fc 67 d2 ae a7 05 29
    TEXT[test]:          51 3e 3d a2 67 7f a5 90 6c 5b 3f 7d 8f 92 f2 28 bd a4 0d da 72
    TEXT[test]:          14 70 f9 fb f2 97 b5 ae a6 17 64 6f ac 5c 03 27 2e 97 07 27 c6
    TEXT[test]:          21 a7 91 41 ef 5f 7d e6 50 5e 5b fb c3 88 e9 33 43 69 40 93 93
    TEXT[test]:          4a e4 d3 57 fa d6 aa cb 00 21 20 3a dd 4f b2 d8 fd f8 22 a0 ca
    TEXT[test]:          3c f7 67 8e f5 e8 8d ae 99 01 41 c5 92 4d 57 bb 6f a3 1b 9e 5f
    TEXT[test]:          9d
    TEXT[test]:    {client}  derive secret "tls13 c e traffic":
    TEXT[test]:       PRK (32 octets):  9b 21 88 e9 b2 fc 6d 64 d7 1d c3 29 90 0e 20 bb
    TEXT[test]:          41 91 50 00 f6 78 aa 83 9c bb 79 7c b7 d8 33 2c
    TEXT[test]:       hash (32 octets):  08 ad 0f a0 5d 7c 72 33 b1 77 5b a2 ff 9f 4c 5b
    TEXT[test]:          8b 59 27 6b 7f 22 7f 13 a9 76 24 5f 5d 96 09 13
    TEXT[test]:       info (53 octets):  00 20 11 74 6c 73 31 33 20 63 20 65 20 74 72 61
    TEXT[test]:          66 66 69 63 20 08 ad 0f a0 5d 7c 72 33 b1 77 5b a2 ff 9f 4c 5b
    TEXT[test]:          8b 59 27 6b 7f 22 7f 13 a9 76 24 5f 5d 96 09 13
    TEXT[test]:       expanded (32 octets):  3f bb e6 a6 0d eb 66 c3 0a 32 79 5a ba 0e
    TEXT[test]:          ff 7e aa 10 10 55 86 e7 be 5c 09 67 8d 63 b6 ca ab 62
    TEXT[test]:    {client}  derive write traffic keys for early application data:
    TEXT[test]:       PRK (32 octets):  3f bb e6 a6 0d eb 66 c3 0a 32 79 5a ba 0e ff 7e
    TEXT[test]:          aa 10 10 55 86 e7 be 5c 09 67 8d 63 b6 ca ab 62
    TEXT[test]:       key info (13 octets):  00 10 09 74 6c 73 31 33 20 6b 65 79 00
    TEXT[test]:       key expanded (16 octets):  92 02 05 a5 b7 bf 21 15 e6 fc 5c 29 42
    TEXT[test]:          83 4f 54
    TEXT[test]:       iv info (12 octets):  00 0c 08 74 6c 73 31 33 20 69 76 00
    TEXT[test]:       iv expanded (12 octets):  6d 47 5f 09 93 c8 e5 64 61 0d b2 b9
    TEXT[test]:    {client}  send application_data record:
    TEXT[test]:       payload (6 octets):  41 42 43 44 45 46
    TEXT[test]:       complete record (28 octets):  17 03 03 00 17 ab 1d f4 20 e7 5c 45
    TEXT[test]:          7a 7c c5 d2 84 4f 76 d5 ae e4 b4 ed bf 04 9b e0
    TEXT[test]:    {server}  extract secret "early" (same as client early secret)
    TEXT[test]:    {server}  derive secret "tls13 c e traffic" (same as client)
    TEXT[test]:    {server}  derive read traffic keys for early application data (same
    TEXT[test]:       as client early application data write traffic keys)
    TEXT[test]:       complete record (26 octets):  17 03 03 00 15 ac a6 fc 94 48 41 29
    TEXT[test]:          8d f9 95 93 72 5f 9b f9 75 44 29 b1 2f 09

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc8701
  SECTION: [GREASE Values](#section-2)
    TEXT[test]:    The following values are reserved as GREASE values for
    TEXT[test]:    PskKeyExchangeModes:
    TEXT[test]:       0x0B
    TEXT[test]:       0x2A
    TEXT[test]:       0x49
    TEXT[test]:       0x68
    TEXT[test]:       0x87
    TEXT[test]:       0xA6
    TEXT[test]:       0xC5
    TEXT[test]:       0xE4

  SECTION: [Client Behavior](#section-3.1)
    TEXT[test]: A client MAY select one or more GREASE PskKeyExchangeMode values
    TEXT[test]:       and advertise them in the "psk_key_exchange_modes" extension, if
    TEXT[test]:       sent.

  SECTION: [Server Behavior](#section-3.2)
    TEXT[test]:    When processing a ClientHello, servers MUST NOT treat GREASE values
    TEXT[test]:    differently from any unknown value.  Servers MUST NOT negotiate any
    TEXT[test]:    GREASE value when offered in a ClientHello.  Servers MUST correctly
    TEXT[test]:    ignore unknown values in a ClientHello and attempt to negotiate with
    TEXT[test]:    one of the remaining parameters.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc9001
  SECTION: [Key Update](#section-6)
    TEXT[test]: Endpoints MUST treat the
    TEXT[test]:    receipt of a TLS KeyUpdate message as a connection error of type
    TEXT[test]:    0x010a, equivalent to a fatal TLS alert of unexpected_message

  SECTION: [QUIC Transport Parameters Extension](#section-8.2)
    TEXT[implementation]:       enum {
    TEXT[implementation]:          quic_transport_parameters(0x39), (65535)
    TEXT[implementation]:       } ExtensionType;
    TEXT[test]: Endpoints
    TEXT[test]:    MUST send the quic_transport_parameters extension; endpoints that
    TEXT[test]:    receive ClientHello or EncryptedExtensions messages without the
    TEXT[test]:    quic_transport_parameters extension MUST close the connection with an
    TEXT[test]:    error of type 0x016d (equivalent to a fatal TLS missing_extension
    TEXT[test]:    alert

  SECTION: [Prohibit TLS Middlebox Compatibility Mode](#section-8.4)
    TEXT[implementation]: A server SHOULD treat the receipt of a
    TEXT[implementation]:    TLS ClientHello with a non-empty legacy_session_id field as a
    TEXT[implementation]:    connection error of type PROTOCOL_VIOLATION.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc9151
  SECTION: [Acceptable Elliptic Curve Cryptography (ECC) Curves](#section-5.1)
    TEXT[implementation]: CNSA (D)TLS
    TEXT[implementation]:    connections MUST use secp384r1

  SECTION: [Acceptable RSA Schemes, Parameters, and Checks](#section-5.2)
    TEXT[implementation]: CNSA] specifies a minimum modulus size of 3072 bits; however, only
    TEXT[implementation]:    two modulus sizes (3072 bits and 4096 bits) are supported by this
    TEXT[implementation]:    profile.
