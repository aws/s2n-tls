import "DRBG.cry";

////////////////////////////////////////////////////////////////////////////////
// Generic utility functions
////////////////////////////////////////////////////////////////////////////////

let alloc_init ty v = do {
    p <- crucible_alloc ty;
    crucible_points_to p v;
    return p;
};

let ptr_to_fresh n ty = do {
    x <- crucible_fresh_var n ty;
    p <- alloc_init ty (crucible_term x);
    return (x, p);
};

let blocksize = 16; // blocklen / 8
let keysize = 16; // keylen / 8
let seedsize = 32;

let i8 = llvm_int 8;
let i32 = llvm_int 32;
let i64 = llvm_int 64;
let tm = crucible_term;

let bytes_type n = llvm_array n i8;
let alloc_bytes n = crucible_alloc (bytes_type n);

////////////////////////////////////////////////////////////////////////////////
// Convenient Cryptol definitions
////////////////////////////////////////////////////////////////////////////////

let {{

max_seq_number : [blocksize*8]
max_seq_number = ~zero

drbg_generate_seedlen : s2n_drbg -> [seedlen] -> Bit -> ([seedlen], s2n_drbg)
drbg_generate_seedlen = drbg_generate `{n=seedlen,blocks=2}

}};

// A symbolic variable representing the entropy returned by the system.
fake_entropy <- fresh_symbolic "fake_entropy" {| [seedsize*8] |};

////////////////////////////////////////////////////////////////////////////////
// Types specific to s2n
////////////////////////////////////////////////////////////////////////////////

let ctx_type = bytes_type keysize;
let alloc_ctx = crucible_alloc ctx_type;
let fresh_ctx n = ptr_to_fresh n ctx_type;

let blob_type = llvm_struct "struct.s2n_blob";
let alloc_blob n = do {
    p <- crucible_alloc blob_type;
    datap <- alloc_bytes n;
    crucible_points_to (crucible_field p "data") datap;
    crucible_points_to (crucible_field p "size") (tm {{ `n : [32] }});
    return (p, datap);
};

let drbg_state n = do {
    state <- crucible_alloc (llvm_struct "struct.s2n_drbg");
    (key, keyp) <- ptr_to_fresh "key" (bytes_type keysize);
    bytes_used <- crucible_fresh_var (str_concat n "->bytes_used") i64;
    v <- crucible_fresh_var (str_concat n "->v") (bytes_type blocksize);
    crucible_points_to (crucible_field state "bytes_used") (tm bytes_used);
    crucible_points_to (crucible_field state "ctx") keyp;
    crucible_points_to (crucible_field state "v") (tm v);
    crucible_points_to (crucible_field state "entropy_generator") crucible_null;
    crucible_points_to (crucible_field state "generation") (tm {{ 0 : [32] }});
    crucible_precond {{ bytes_used < (`reseed_limit : [64]) }};
    return ( state
           , keyp
           , {{ { bytes_used = bytes_used
               , ctx = { key = join key }
               , v = join v
               } }}
           );
};

let ensure_drbg_state p keyp s = do {
    crucible_points_to (crucible_field p "bytes_used") (tm {{ s.bytes_used }});
    crucible_points_to_untyped keyp (tm {{
        split s.ctx.key : [keysize][8]
    }});
    crucible_points_to (crucible_field p "v") (tm {{
        split s.v : [blocksize][8]
    }});
};

////////////////////////////////////////////////////////////////////////////////
// Assumed specifications
////////////////////////////////////////////////////////////////////////////////

let aes_128_ecb_spec = do {
    crucible_execute_func [];
    r <- crucible_fresh_pointer (bytes_type keysize);
    crucible_return r;
};

let cipher_new_spec = do {
    crucible_execute_func [];
    r <- alloc_bytes keysize;
    crucible_return r;
};

let cipher_init_spec = do {
    ctx <- alloc_ctx;
    crucible_execute_func [ctx];
};

let cipher_free_spec = do {
    ctx <- alloc_ctx;
    crucible_execute_func [ctx];
};

let cipher_cleanup_spec = do {
    ctx <- alloc_ctx;
    crucible_execute_func [ctx];
    crucible_points_to ctx (tm {{ zero : [keysize][8] }});
    crucible_return (tm {{ 1 : [32] }});
};

let encryptInit_spec = do {
    ctx <- alloc_ctx;
    st <- crucible_fresh_pointer (bytes_type keysize);
    (key, keyp) <- ptr_to_fresh "key" (bytes_type keysize);
    crucible_execute_func [ctx, st, crucible_null, keyp, crucible_null];
    crucible_points_to ctx (tm key);
    crucible_return (tm {{ 1 : [32] }});
};

let encryptUpdate_spec n = do {
    (key, keyp) <- fresh_ctx "key";
    outp <- alloc_bytes n;
    (msg, msgp) <- ptr_to_fresh "msg" (bytes_type n);
    lenp <- alloc_init i32 (tm {{ `n : [32] }});
    crucible_execute_func [keyp, outp, lenp, msgp, tm {{ `blocksize : [32] }} ];
    crucible_points_to outp (tm {{
        split (block_encrypt (join key) (join msg)) : [blocksize][8]
    }});
    crucible_points_to lenp (tm {{ `n : [32] }});
    crucible_points_to msgp (tm msg);
    crucible_return (tm {{ 1 : [32] }});
};

let get_urandom_spec = do {
    (p, datap) <- alloc_blob seedsize;
    crucible_execute_func [p];
    crucible_points_to datap (tm {{ split fake_entropy : [seedsize][8] }});
    crucible_return (tm {{ 0 : [32] }});
};

let supports_rdrand_spec = do {
    crucible_execute_func [];
    r <- crucible_fresh_var "supports_rdrand" i32;
    crucible_return (tm r);
};

////////////////////////////////////////////////////////////////////////////////
// Specifications to be verified
////////////////////////////////////////////////////////////////////////////////

let block_encrypt_spec = do {
    (key, keyp) <- ptr_to_fresh "ctx" (bytes_type keysize);
    (msg, msgp) <- ptr_to_fresh "msg" (bytes_type blocksize);
    outp <- alloc_bytes blocksize;
    crucible_execute_func [keyp, msgp, outp];
    crucible_points_to outp (tm {{
        split (block_encrypt (join key) (join msg)) : [blocksize][8]
    }});
    crucible_return (tm {{ 0 : [32] }});
};

let blob_zero_spec n = do {
    (p, datap) <- alloc_blob n;
    crucible_execute_func [p];
    crucible_points_to datap (tm {{ zero : [n][8] }});
    crucible_return (tm {{ 0 : [32] }});
};

let increment_sequence_number_spec = do {
    (p, datap) <- alloc_blob blocksize;
    v <- crucible_fresh_var "v" (bytes_type blocksize);
    crucible_points_to datap (tm v);
    crucible_precond {{ join v < max_seq_number }}; // Overflow not allowed
    crucible_execute_func [p];
    let res = {{ split ((join v) + 1) : [blocksize][8] }};
    crucible_points_to datap (tm res);
    crucible_return (tm {{ 0 : [32] }});
};

let bits_spec n = do {
    (sp, keyp, s) <- drbg_state "drbg";
    (outp, datap) <- alloc_blob n;
    crucible_precond {{ s.v < max_seq_number - `(n / blocksize) }};
    crucible_execute_func [sp, outp];
    let res = {{ drbg_generate_internal `{n=n*8} s }};
    crucible_points_to datap (tm {{ split res.0 : [n][8] }});
    crucible_points_to (crucible_field outp "data") datap;
    crucible_points_to (crucible_field outp "size") (tm {{ `n : [32] }});
    ensure_drbg_state sp keyp {{ res.1 }};
    crucible_return (tm {{ 0 : [32] }});
};

let update_spec n = do {
    (sp, keyp, s) <- drbg_state "drbg";
    (providedp, datap) <- alloc_blob n;
    data <- crucible_fresh_var "data" (bytes_type n);
    crucible_points_to datap (tm data);
    // Avoid overflowing sequence number
    crucible_precond {{ s.v < max_seq_number - `(n / blocksize) }};
    crucible_execute_func [sp, providedp];
    ensure_drbg_state sp keyp {{ drbg_update (join data) s }};
    crucible_return (tm {{ 0 : [32] }});
};


let seed_spec n = do {
    (sp, keyp, s) <- drbg_state "drbg";
    (psp, datap) <- alloc_blob n;
    data <- crucible_fresh_var "data" (bytes_type n);
    crucible_points_to datap (tm data);
    // Avoid overflowing sequence number
    crucible_precond {{ s.v < max_seq_number - `(n / blocksize) }};
    crucible_execute_func [sp, psp];
    ensure_drbg_state sp keyp {{ drbg_reseed s fake_entropy (join data) }};
    crucible_return (tm {{ 0 : [32] }});
};

let instantiate_spec n = do {
    (sp, keyp, s) <- drbg_state "drbg";
    (psp, datap) <- alloc_blob n;
    data <- crucible_fresh_var "data" (bytes_type n);
    crucible_points_to datap (tm data);
    // Avoid overflowing sequence number
    crucible_precond {{ s.v < max_seq_number - `(n / blocksize) }};
    crucible_execute_func [sp, psp];
    newkeyp <- crucible_alloc (bytes_type keysize);
    crucible_points_to (crucible_field sp "ctx") newkeyp;
    ensure_drbg_state sp newkeyp {{ drbg_instantiate fake_entropy (join data) }};
    crucible_return (tm {{ 0 : [32] }});
};

let generate_spec = do {
    (sp, keyp, s) <- drbg_state "drbg";
    (psp, datap) <- alloc_blob seedsize;
    // Avoid overflowing sequence number
    crucible_precond {{ s.v < max_seq_number - `(2*seedsize / blocksize) }};
    crucible_precond {{ s.bytes_used < (`reseed_limit / 2 : [64]) }};
    crucible_execute_func [sp, psp];
    let {{ res = drbg_generate_seedlen s fake_entropy False }};
    crucible_points_to datap (tm {{ split res.0 : [seedsize][8] }});
    ensure_drbg_state sp keyp {{ res.1 }};
    crucible_return (tm {{ 0 : [32] }});
};

// TODO: incomplete
let wipe_spec = do {
    (sp, keyp, s) <- drbg_state "drbg";
    crucible_execute_func [sp];
    crucible_points_to (crucible_field sp "v") (tm {{ zero : [blocksize][8] }});
    crucible_return (tm {{ 0 : [32] }});
};

let bytes_used_spec = do {
    (sp, keyp, s) <- drbg_state "drbg";
    crucible_execute_func[sp];
    crucible_return (tm {{ drop s.bytes_used : [32] }});
};

////////////////////////////////////////////////////////////////////////////////
// Bitcode processing
////////////////////////////////////////////////////////////////////////////////

m <- llvm_load_module "../../bitcode/all_llvm.bc";

////////////////////////////////////////////////////////////////////////////////
// Assumptions about external functions
////////////////////////////////////////////////////////////////////////////////

aes_128_ecb_ov <- crucible_llvm_unsafe_assume_spec m "EVP_aes_128_ecb" aes_128_ecb_spec;
cipher_new_ov <- crucible_llvm_unsafe_assume_spec m "EVP_CIPHER_CTX_new" cipher_new_spec;

cipher_free_ov <- crucible_llvm_unsafe_assume_spec m "EVP_CIPHER_CTX_free" cipher_free_spec;

cipher_cleanup_ov <- crucible_llvm_unsafe_assume_spec m "EVP_CIPHER_CTX_cleanup" cipher_cleanup_spec;

encryptInit_ov <- crucible_llvm_unsafe_assume_spec m "EVP_EncryptInit_ex"
    encryptInit_spec;

encryptUpdate_ov <- crucible_llvm_unsafe_assume_spec m "EVP_EncryptUpdate"
    (encryptUpdate_spec 16);

supports_rdrand_ov <- crucible_llvm_unsafe_assume_spec m "s2n_cpu_supports_rdrand" supports_rdrand_spec;

get_urandom_ov <- crucible_llvm_unsafe_assume_spec m "s2n_get_urandom_data" get_urandom_spec;

////////////////////////////////////////////////////////////////////////////////
// Proofs about internal functions
////////////////////////////////////////////////////////////////////////////////

zero_ov_block <- crucible_llvm_verify m "s2n_blob_zero" [] false (blob_zero_spec blocksize) yices;
zero_ov_seed <- crucible_llvm_verify m "s2n_blob_zero" [] false (blob_zero_spec seedsize) yices;
zero_ov_drbg <- crucible_llvm_verify m "s2n_blob_zero" [] false (blob_zero_spec 48) yices;

inc_ov <- crucible_llvm_verify m "s2n_increment_sequence_number" [] false increment_sequence_number_spec yices;

crucible_llvm_verify m "s2n_drbg_wipe" [cipher_free_ov, cipher_cleanup_ov, zero_ov_drbg] false wipe_spec yices;

crucible_llvm_verify m "s2n_drbg_bytes_used" [] false bytes_used_spec yices;

blk_enc_ov <- crucible_llvm_verify m "s2n_drbg_block_encrypt" [encryptUpdate_ov] false block_encrypt_spec (unint_yices ["block_encrypt"]);

bits_ov <- crucible_llvm_verify m "s2n_drbg_bits" [inc_ov, encryptUpdate_ov, blk_enc_ov] false (bits_spec seedsize) (unint_yices ["block_encrypt"]);

update_ov <- crucible_llvm_verify m "s2n_drbg_update" [bits_ov, encryptInit_ov, aes_128_ecb_ov] false (update_spec seedsize) (unint_yices ["block_encrypt"]);

seed_ov <- crucible_llvm_verify m "s2n_drbg_seed" [get_urandom_ov, update_ov] false (seed_spec seedsize) (unint_yices ["block_encrypt"]);

instantiate_ov <- crucible_llvm_verify m "s2n_drbg_instantiate" [zero_ov_block, zero_ov_seed, cipher_new_ov, encryptInit_ov, aes_128_ecb_ov, seed_ov, supports_rdrand_ov] false(instantiate_spec seedsize) (unint_yices ["block_encrypt"]);

generate_ov <- crucible_llvm_verify m "s2n_drbg_generate" [seed_ov, bits_ov, update_ov] false generate_spec (unint_yices ["block_encrypt"]);
