// This module contains a high-level model of the cork-uncork state
// machine. This state machine only tracks the current sender (client,
// server or both) and is driven by the new value of the 'writer' field
// of the handshake state machine state (the 'handshake_action').
//
// It also contains a predicate that states the high-level model
// simulates the lower-level model of s2n_advance_message in Cryptol
// and is verified in the SAW proof script.
//

// Finally, the property we want to prove is about not corking or
// uncorking a socket twice in a row. It is encoded in 'noDoubleCorkUncork'.


module CorkUncork where

import Cryptol::Extras
import s2n_advance_message

type State = ([2], [2])
(clientSender : [2]) = 0
(serverSender : [2]) = 1
(appData      : [2]) = 2

(corked : [2]) = 1
(uncorked : [2]) = 0

//TODO: here we really need partial functions and check that only the
//part we implement is actually used.
writer2sender : [8] -> [2]
writer2sender w = if w == 'C' then clientSender else
                  if w == 'S' then serverSender else
                                   appData

corkAdapt : [1] -> [2]
corkAdapt c = zero # c

corkedFromConn : connection -> [1]
corkedFromConn conn = if mode_writer conn.mode == (ACTIVE_STATE conn).writer then 1
                      else 0

//if low level can make a step, then the high level can. If the low
//level cannot make a step, then the high level can't also
highLevelSimulatesLowLevel : connection -> Bit
highLevelSimulatesLowLevel conn_old =
   if (valid_handshake conn_old.handshake /\ conn_old.mode == S2N_SERVER /\ conn_old.corked_io == 1 /\ (conn_old.corked == corkedFromConn conn_old)) then state_new == (cork_transition state_old writer_new)
   else True
   where conn_new   = advance_message conn_old
         writer_old = (ACTIVE_STATE conn_old).writer
         writer_new = (ACTIVE_STATE conn_new).writer
         state_old  = (writer2sender writer_old, corkAdapt conn_old.corked)
         state_new  = (writer2sender writer_new, corkAdapt conn_new.corked)
         input      = writer_new

// A (failing) simulation relation that omits the "only in server
// mode" precondition.
highLevelDoesNotSimulateLowLevel : connection -> Bit
highLevelDoesNotSimulateLowLevel conn_old =
   if (valid_handshake conn_old.handshake /\ conn_old.corked_io == 1 /\ (conn_old.corked == corkedFromConn conn_old)) then state_new == (cork_transition state_old writer_new)
   else True
   where conn_new   = advance_message conn_old
         writer_old = (ACTIVE_STATE conn_old).writer
         writer_new = (ACTIVE_STATE conn_new).writer
         state_old  = (writer2sender writer_old, corkAdapt conn_old.corked)
         state_new  = (writer2sender writer_new, corkAdapt conn_new.corked)
         input      = writer_new

// The abstract transition function for the cork/uncork state machine
cork_transition : State -> [8] -> State
cork_transition (s, corking) c =
  if (s == clientSender) then
     if c == 'C' then (clientSender, corking)
     else if c == 'S' then (serverSender, corking + 1)
          else (appData, corking)
  else if s == serverSender then
     if c == 'C' then (clientSender, corking - 1)
     else if c == 'S' then (serverSender, corking)
          else (appData, corking - 1)
  else (appData, corking)

// generate a trace of states for the standard cork/uncork state //
// machine (assumes socket is initially uncorked) given a list of input
// actions (new writers)
run : {n} [n][8] -> [n+1]State
run writers = scanl cork_transition (clientSender, uncorked) writers

// returns the last state of the 
exec : {n} (fin n) => [n][8] -> State
exec writers = foldl cork_transition (clientSender, uncorked) writers

// there is no uncorking or corking twice in a row
noDoubleCorkUncork : [12][8] -> Bit
noDoubleCorkUncork writers = and (map corkingInBounds (run writers))

corkingInBounds : State -> Bit
corkingInBounds (_, corking) = corking == corked \/ corking == uncorked
